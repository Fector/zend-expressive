{
    "docs": [
        {
            "location": "/",
            "text": "Expressive: PSR-7 Middleware in Minutes\n\n\nExpressive builds on \nStratigility\n\nto provide a minimalist \nPSR-7\n middleware\nframework for PHP, with the following features:\n\n\n\n\nRouting. Choose your own router; we support:\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-router\n\n\n\n\n\n\nDI Containers, via \nPSR-11 Container\n.\n  All middleware composed in Expressive may be retrieved from the composed\n  container.\n\n\nOptionally, templating. We support:\n\n\nPlates\n\n\nTwig\n\n\nZF2's PhpRenderer\n\n\n\n\n\n\nError handling. Create templated error pages, or use tools like\n  \nwhoops\n for debugging purposes.\n\n\nNested middleware applications. Write an application, and compose it later\n  in another, optionally under a separate subpath.\n\n\nSimplified installation\n. Our custom\n  \nComposer\n-based installer prompts you for your\n  initial stack choices, giving you exactly the base you want to start from.\n\n\n\n\nEssentially, Expressive allows \nyou\n to develop using the tools \nyou\n prefer,\nand provides minimal structure and facilities to ease your development.\n\n\nShould I choose it over Zend\\Mvc?\nThat\u2019s a good question. \nHere\u2019s what we recommend.\n\n\nIf you\u2019re keen to get started, then \nkeep reading\n\nand get started writing your first middleware application today!",
            "title": "Home"
        },
        {
            "location": "/#expressive-psr-7-middleware-in-minutes",
            "text": "Expressive builds on  Stratigility \nto provide a minimalist  PSR-7  middleware\nframework for PHP, with the following features:   Routing. Choose your own router; we support:  Aura.Router  FastRoute  zend-router    DI Containers, via  PSR-11 Container .\n  All middleware composed in Expressive may be retrieved from the composed\n  container.  Optionally, templating. We support:  Plates  Twig  ZF2's PhpRenderer    Error handling. Create templated error pages, or use tools like\n   whoops  for debugging purposes.  Nested middleware applications. Write an application, and compose it later\n  in another, optionally under a separate subpath.  Simplified installation . Our custom\n   Composer -based installer prompts you for your\n  initial stack choices, giving you exactly the base you want to start from.   Essentially, Expressive allows  you  to develop using the tools  you  prefer,\nand provides minimal structure and facilities to ease your development.  Should I choose it over Zend\\Mvc?\nThat\u2019s a good question.  Here\u2019s what we recommend.  If you\u2019re keen to get started, then  keep reading \nand get started writing your first middleware application today!",
            "title": "Expressive: PSR-7 Middleware in Minutes"
        },
        {
            "location": "/getting-started/features/",
            "text": "Overview\n\n\nExpressive allows you to write \nPSR-7\n\n\nmiddleware\n\napplications for the web.\n\n\nPSR-7 is a standard defining HTTP message interfaces; these are the incoming\nrequest and outgoing response for your application. By using PSR-7, we ensure\nthat your applications will work in other PSR-7 contexts.\n\n\nMiddleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.\n\n\nMiddleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.\n\n\nWith Expressive, you can build PSR-7-based middleware applications:\n\n\n\n\nAPIs\n\n\nWebsites\n\n\nSingle Page Applications\n\n\nand more.\n\n\n\n\nFeatures\n\n\nExpressive builds on \nzend-stratigility\n\nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:\n\n\n\n\nRouting\n\n\n\n\nStratigility provides limited, literal matching only. Expressive allows you\n  to utilize dynamic routing capabilities from a variety of routers, providing\n  much more fine-grained matching capabilities. The routing layer also allows\n  restricting matched routes to specific HTTP methods, and will return \"405 Not\n  Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP\n  methods for invalid requests.\n\n\nRouting is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-mvc router.\n\n\n\n\nPSR-11 Container\n\n\n\n\nExpressive encourages the use of Dependency Injection, and defines its\n  \nApplication\n class to compose a PSR-11 \nContainerInterface\n\n  instance. The container is used to lazy-load middleware, whether it is\n  piped (Stratigility interface) or routed (Expressive).\n\n\n\n\nTemplating\n\n\n\n\nWhile Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.\n\n\n\n\nError Handling\n\n\n\n\nApplications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own \nErrorHandler\n implementation, providing\n  specialized error response generators that can perform templating or use\n  Whoops.\n\n\nFlow Overview\n\n\nBelow is a diagram detailing the workflow used by Expressive.\n\n\n\n\nThe \nApplication\n acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.\n\n\nThe \nApplication\n dispatches each middleware. Each middleware receives a request\nand a delegate for handing off processing of the request should the middleware\nnot be able to fully process it itself. Internally, the delegate composes a\nqueue of middleware, and invokes the next in the queue when invoked.\n\n\nAny given middleware can return a \nresponse\n, at which point execution winds\nits way back out the onion.\n\n\n\n\nPipelines\n\n\nThe terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a \nqueue\n, which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:\n\n\n\n\nIn most cases, the entire queue \nwill not\n be traversed.\n\n\nThe inner-most layer of the onion represents the last item in the queue, and\n  should be guaranteed to return a response; usually this is indicative of\n  a malformed request (HTTP 400 response status) and/or inability to route\n  the middleware to a handler (HTTP 404 response status).\n\n\nResponses are returned back \nthrough\n the pipeline, in reverse order of\n  traversal.\n\n\n\n\nDouble pass middleware\n\n\nThe system described above is what is known as \nlambda middleware\n. Each\nmiddleware receives the request and the delegate, and you pass only the\nrequest to the delegate when wanting to hand off processing:\n\n\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Test', time());\n}\n\n\n\nIn Expressive 1.X, the default middleware style was what is known as \ndouble\npass\n middleware. Double pass middleware receives both the request and a\nresponse in addition to the delegate, and passes both the request and response\nto the delegate when invoking it:\n\n\nfunction (ServerRequestInterface $request, ResponseInterface $response, callable $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Test', time());\n}\n\n\n\nIt is termed \"double pass\" because you pass both the request and response when\ndelegating to the next layer.\n\n\nExpressive 2.X still supports double-pass middleware, though we recommend the\nlambda style.\n\n\nStratigility 1.X Error Middleware\n\n\nThe Expressive 1.X series was based on Stratigility 1.X, which had a concept\nof \nerror middleware\n. This was middleware that either implemented\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n, or the \"error middleware\"\nsignature of:\n\n\nfunction (\n    $error,\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n)\n\n\n\nSuch middleware would be invoked by calling \n$next()\n with a third argument\nrepresenting the error:\n\n\nreturn $next($request, $response, $error);\n\n\n\nBecause this middleware would only be invoked in these special conditions,\nwe recommended piping such middleware \nlast\n in the queue.\n\n\nStarting with Expressive 1.1, this feature was deprecated, in favor of\nusing standard middleware with try/catch blocks internally for error\nhandling. As such, we still document it, for our 1.X users, but recommend\nmigrating to the suggested error handling practices.\n\n\n\n\nThe \nApplication\n allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.\n\n\nYou can attach middleware manually, in which case the pipeline is executed in\nthe order of attachment, or use configuration. When you use configuration, you\nwill specify a priority integer to dictate the order in which middleware should\nbe attached. Middleware specifying high integer priorities are attached (and\nthus executed) earlier, while those specifying lower and/or negative integers\nare attached later. The default priority is 1.\n\n\nExpressive provides default implementations of \"routing\" and \"dispatch\"\nmiddleware, which you either attach to the middleware pipeline manually, or via\nconfiguration. These are implemented as the classes\n\nZend\\Expressive\\Middleware\\RouteMiddleware\n and\n\nZend\\Expressive\\Middleware\\DispatchMiddleware\n, respectively.\n\n\nRouting within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:\n\n\n\n\nmap a GET request to the path \n/api/ping\n to the \nPingMiddleware\n\n\nmap a POST request to the path \n/contact/process\n to the \nHandleContactMiddleware\n\n\netc.\n\n\n\n\nDispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation.\n\n\nThe majority of your application will consist of routing rules that map to\nrouted middleware.\n\n\nMiddleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:\n\n\n\n\nbootstrapping\n\n\nparsing of request body parameters\n\n\naddition of debugging tools\n\n\nembedded Expressive applications that you want to match at a given literal\n  path\n\n\netc.\n\n\n\n\nSuch middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.\n\n\nMiddleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:\n\n\n\n\nrouting failed\n\n\nrouted middleware called on the next middleware instead of returning a response.\n\n\n\n\nAs such, the largest use case for such middleware is to provide a \"default\"\nerror response for your application, usually as an HTTP 404 Not Found response.\n\n\nThe main points to remember are:\n\n\n\n\nThe application is a queue, and operates in FIFO order.\n\n\nEach middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.\n\n\nMost of the time, you will be defining \nrouted middleware\n, and the routing\n  rules that map to them.\n\n\nYou\n get to control the workflow of your application by deciding the order in\n  which middleware is queued.",
            "title": "Overview and Features"
        },
        {
            "location": "/getting-started/features/#overview",
            "text": "Expressive allows you to write  PSR-7  middleware \napplications for the web.  PSR-7 is a standard defining HTTP message interfaces; these are the incoming\nrequest and outgoing response for your application. By using PSR-7, we ensure\nthat your applications will work in other PSR-7 contexts.  Middleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.  Middleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.  With Expressive, you can build PSR-7-based middleware applications:   APIs  Websites  Single Page Applications  and more.",
            "title": "Overview"
        },
        {
            "location": "/getting-started/features/#features",
            "text": "Expressive builds on  zend-stratigility \nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:   Routing   Stratigility provides limited, literal matching only. Expressive allows you\n  to utilize dynamic routing capabilities from a variety of routers, providing\n  much more fine-grained matching capabilities. The routing layer also allows\n  restricting matched routes to specific HTTP methods, and will return \"405 Not\n  Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP\n  methods for invalid requests.  Routing is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-mvc router.   PSR-11 Container   Expressive encourages the use of Dependency Injection, and defines its\n   Application  class to compose a PSR-11  ContainerInterface \n  instance. The container is used to lazy-load middleware, whether it is\n  piped (Stratigility interface) or routed (Expressive).   Templating   While Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.   Error Handling   Applications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own  ErrorHandler  implementation, providing\n  specialized error response generators that can perform templating or use\n  Whoops.",
            "title": "Features"
        },
        {
            "location": "/getting-started/features/#flow-overview",
            "text": "Below is a diagram detailing the workflow used by Expressive.   The  Application  acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.  The  Application  dispatches each middleware. Each middleware receives a request\nand a delegate for handing off processing of the request should the middleware\nnot be able to fully process it itself. Internally, the delegate composes a\nqueue of middleware, and invokes the next in the queue when invoked.  Any given middleware can return a  response , at which point execution winds\nits way back out the onion.",
            "title": "Flow Overview"
        },
        {
            "location": "/getting-started/features/#pipelines",
            "text": "The terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a  queue , which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:   In most cases, the entire queue  will not  be traversed.  The inner-most layer of the onion represents the last item in the queue, and\n  should be guaranteed to return a response; usually this is indicative of\n  a malformed request (HTTP 400 response status) and/or inability to route\n  the middleware to a handler (HTTP 404 response status).  Responses are returned back  through  the pipeline, in reverse order of\n  traversal.",
            "title": "Pipelines"
        },
        {
            "location": "/getting-started/features/#double-pass-middleware",
            "text": "The system described above is what is known as  lambda middleware . Each\nmiddleware receives the request and the delegate, and you pass only the\nrequest to the delegate when wanting to hand off processing:  function (ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Test', time());\n}  In Expressive 1.X, the default middleware style was what is known as  double\npass  middleware. Double pass middleware receives both the request and a\nresponse in addition to the delegate, and passes both the request and response\nto the delegate when invoking it:  function (ServerRequestInterface $request, ResponseInterface $response, callable $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Test', time());\n}  It is termed \"double pass\" because you pass both the request and response when\ndelegating to the next layer.  Expressive 2.X still supports double-pass middleware, though we recommend the\nlambda style.",
            "title": "Double pass middleware"
        },
        {
            "location": "/getting-started/features/#stratigility-1x-error-middleware",
            "text": "The Expressive 1.X series was based on Stratigility 1.X, which had a concept\nof  error middleware . This was middleware that either implemented Zend\\Stratigility\\ErrorMiddlewareInterface , or the \"error middleware\"\nsignature of:  function (\n    $error,\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n)  Such middleware would be invoked by calling  $next()  with a third argument\nrepresenting the error:  return $next($request, $response, $error);  Because this middleware would only be invoked in these special conditions,\nwe recommended piping such middleware  last  in the queue.  Starting with Expressive 1.1, this feature was deprecated, in favor of\nusing standard middleware with try/catch blocks internally for error\nhandling. As such, we still document it, for our 1.X users, but recommend\nmigrating to the suggested error handling practices.   The  Application  allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.  You can attach middleware manually, in which case the pipeline is executed in\nthe order of attachment, or use configuration. When you use configuration, you\nwill specify a priority integer to dictate the order in which middleware should\nbe attached. Middleware specifying high integer priorities are attached (and\nthus executed) earlier, while those specifying lower and/or negative integers\nare attached later. The default priority is 1.  Expressive provides default implementations of \"routing\" and \"dispatch\"\nmiddleware, which you either attach to the middleware pipeline manually, or via\nconfiguration. These are implemented as the classes Zend\\Expressive\\Middleware\\RouteMiddleware  and Zend\\Expressive\\Middleware\\DispatchMiddleware , respectively.  Routing within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:   map a GET request to the path  /api/ping  to the  PingMiddleware  map a POST request to the path  /contact/process  to the  HandleContactMiddleware  etc.   Dispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation.  The majority of your application will consist of routing rules that map to\nrouted middleware.  Middleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:   bootstrapping  parsing of request body parameters  addition of debugging tools  embedded Expressive applications that you want to match at a given literal\n  path  etc.   Such middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.  Middleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:   routing failed  routed middleware called on the next middleware instead of returning a response.   As such, the largest use case for such middleware is to provide a \"default\"\nerror response for your application, usually as an HTTP 404 Not Found response.  The main points to remember are:   The application is a queue, and operates in FIFO order.  Each middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.  Most of the time, you will be defining  routed middleware , and the routing\n  rules that map to them.  You  get to control the workflow of your application by deciding the order in\n  which middleware is queued.",
            "title": "Stratigility 1.X Error Middleware"
        },
        {
            "location": "/getting-started/standalone/",
            "text": "Quick Start: Standalone Usage\n\n\nExpressive allows you to get started at your own pace. You can start with\nthe simplest example, detailed below, or move on to a more structured,\nconfiguration-driven approach as detailed in the \nuse case examples\n.\n\n\n1. Create a new project directory\n\n\nFirst, let's create a new project directory and enter it:\n\n\n$ mkdir expressive\n$ cd expressive\n\n\n\n2. Install Expressive\n\n\nIf you haven't already, \ninstall Composer\n. Once you\nhave, we can install Expressive, along with a router and a container:\n\n\n$ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager\n\n\n\n\n\nRouters\n\n\nExpressive needs a routing implementation in order to create routed\nmiddleware. We suggest FastRoute in the quick start, but you can also\ncurrently choose from Aura.Router and zend-router.\n\n\nContainers\n\n\nWe highly recommend using dependency injection containers with Expressive;\nthey allow you to define dependencies for your middleware, as well as to lazy\nload your middleware only when it needs to be executed. We suggest\nzend-servicemanager in the quick start, but you can also use any container\nsupporting \nPSR-11 Container\n.\n\n\n\n\n3. Create a web root directory\n\n\nYou'll need a directory from which to serve your application, and for security\nreasons, it's a good idea to keep it separate from your source code. We'll\ncreate a \npublic/\n directory for this:\n\n\n$ mkdir public\n\n\n\n4. Create your bootstrap script\n\n\nNext, we'll create a bootstrap script. Such scripts typically setup the\nenvironment, setup the application, and invoke it. This needs to be in our web\nroot, and we want it to intercept any incoming request; as such, we'll use\n\npublic/index.php\n:\n\n\n<?php\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\AppFactory;\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$app = AppFactory::create();\n\n$app->get('/', function ($request, DelegateInterface $delegate) {\n    return new TextResponse('Hello, world!');\n});\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->run();\n\n\n\n\n\nRewriting URLs\n\n\nMany web servers will not rewrite URLs to the bootstrap script by default. If\nyou use Apache, for instance, you'll need to setup rewrite rules to ensure\nyour bootstrap is invoked for unknown URLs. We'll cover that in a later\nchapter.\n\n\nRouting and dispatching\n\n\nNote the lines from the above:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nExpressive's \nApplication\n class provides two separate middlewares, one for\nrouting, and one for dispatching middleware matched by routing. This allows\nyou to slip in validations between the two activities if desired. They are\nnot automatically piped to the application, however, to allow exactly that\nsituation, which means they must be piped manually.\n\n\n\n\n5. Start a web server\n\n\nSince we're just testing out the basic functionality of our application, we'll\nuse PHP's \nbuilt-in web server\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ php -S 0.0.0.0:8080 -t public/\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\n\n\nTip: Serve via Composer\n\n\nTo simplify starting up a local web server, try adding the following to your\n\ncomposer.json\n:\n\n\n\"scripts\": {\n    \"serve\": \"php -S 0.0.0.0:8080 -t public/\"\n}\n\n\n\nOnce you've added that, you can fire up the web server using:\n\n\n$ composer serve\n\n\n\nSetting a timeout\n\n\nComposer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the \nphp -S\n command that \ncomposer serve\n spawns continues running\nas a background process, but on other systems halts when the timeout occurs.\n\n\nAs such, we recommend running the \nserve\n script using a timeout. This can\nbe done by using \ncomposer run\n to execute the \nserve\n script, with a\n\n--timeout\n option. When set to \n0\n, as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via\n\nCtrl-C\n). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:\n\n\n$ composer run --timeout=86400 serve\n\n\n\n\n\nNext steps\n\n\nAt this point, you have a working zend-expressive application, that responds to\na single route. From here, you may want to read up on:\n\n\n\n\nApplications\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling\n\n\n\n\nAdditionally, we have more \nuse case examples\n.",
            "title": "Quick Start: Standalone"
        },
        {
            "location": "/getting-started/standalone/#quick-start-standalone-usage",
            "text": "Expressive allows you to get started at your own pace. You can start with\nthe simplest example, detailed below, or move on to a more structured,\nconfiguration-driven approach as detailed in the  use case examples .",
            "title": "Quick Start: Standalone Usage"
        },
        {
            "location": "/getting-started/standalone/#1-create-a-new-project-directory",
            "text": "First, let's create a new project directory and enter it:  $ mkdir expressive\n$ cd expressive",
            "title": "1. Create a new project directory"
        },
        {
            "location": "/getting-started/standalone/#2-install-expressive",
            "text": "If you haven't already,  install Composer . Once you\nhave, we can install Expressive, along with a router and a container:  $ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager",
            "title": "2. Install Expressive"
        },
        {
            "location": "/getting-started/standalone/#routers",
            "text": "Expressive needs a routing implementation in order to create routed\nmiddleware. We suggest FastRoute in the quick start, but you can also\ncurrently choose from Aura.Router and zend-router.",
            "title": "Routers"
        },
        {
            "location": "/getting-started/standalone/#containers",
            "text": "We highly recommend using dependency injection containers with Expressive;\nthey allow you to define dependencies for your middleware, as well as to lazy\nload your middleware only when it needs to be executed. We suggest\nzend-servicemanager in the quick start, but you can also use any container\nsupporting  PSR-11 Container .",
            "title": "Containers"
        },
        {
            "location": "/getting-started/standalone/#3-create-a-web-root-directory",
            "text": "You'll need a directory from which to serve your application, and for security\nreasons, it's a good idea to keep it separate from your source code. We'll\ncreate a  public/  directory for this:  $ mkdir public",
            "title": "3. Create a web root directory"
        },
        {
            "location": "/getting-started/standalone/#4-create-your-bootstrap-script",
            "text": "Next, we'll create a bootstrap script. Such scripts typically setup the\nenvironment, setup the application, and invoke it. This needs to be in our web\nroot, and we want it to intercept any incoming request; as such, we'll use public/index.php :  <?php\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\AppFactory;\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$app = AppFactory::create();\n\n$app->get('/', function ($request, DelegateInterface $delegate) {\n    return new TextResponse('Hello, world!');\n});\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->run();",
            "title": "4. Create your bootstrap script"
        },
        {
            "location": "/getting-started/standalone/#rewriting-urls",
            "text": "Many web servers will not rewrite URLs to the bootstrap script by default. If\nyou use Apache, for instance, you'll need to setup rewrite rules to ensure\nyour bootstrap is invoked for unknown URLs. We'll cover that in a later\nchapter.",
            "title": "Rewriting URLs"
        },
        {
            "location": "/getting-started/standalone/#routing-and-dispatching",
            "text": "Note the lines from the above:  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();  Expressive's  Application  class provides two separate middlewares, one for\nrouting, and one for dispatching middleware matched by routing. This allows\nyou to slip in validations between the two activities if desired. They are\nnot automatically piped to the application, however, to allow exactly that\nsituation, which means they must be piped manually.",
            "title": "Routing and dispatching"
        },
        {
            "location": "/getting-started/standalone/#5-start-a-web-server",
            "text": "Since we're just testing out the basic functionality of our application, we'll\nuse PHP's  built-in web server .  From the project root directory, execute the following:  $ php -S 0.0.0.0:8080 -t public/  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!",
            "title": "5. Start a web server"
        },
        {
            "location": "/getting-started/standalone/#tip-serve-via-composer",
            "text": "To simplify starting up a local web server, try adding the following to your composer.json :  \"scripts\": {\n    \"serve\": \"php -S 0.0.0.0:8080 -t public/\"\n}  Once you've added that, you can fire up the web server using:  $ composer serve",
            "title": "Tip: Serve via Composer"
        },
        {
            "location": "/getting-started/standalone/#setting-a-timeout",
            "text": "Composer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the  php -S  command that  composer serve  spawns continues running\nas a background process, but on other systems halts when the timeout occurs.  As such, we recommend running the  serve  script using a timeout. This can\nbe done by using  composer run  to execute the  serve  script, with a --timeout  option. When set to  0 , as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via Ctrl-C ). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:  $ composer run --timeout=86400 serve",
            "title": "Setting a timeout"
        },
        {
            "location": "/getting-started/standalone/#next-steps",
            "text": "At this point, you have a working zend-expressive application, that responds to\na single route. From here, you may want to read up on:   Applications  Containers  Routing  Templating  Error Handling   Additionally, we have more  use case examples .",
            "title": "Next steps"
        },
        {
            "location": "/getting-started/skeleton/",
            "text": "Quick Start: Using the Skeleton + Installer\n\n\nThe easiest way to get started with Expressive is to use the \nskeleton\napplication and installer\n.\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.\n\n\nCreate a new project\n\n\nFirst, we'll create a new project, using Composer's \ncreate-project\n command:\n\n\n$ composer create-project zendframework/zend-expressive-skeleton expressive\n\n\n\nThis will prompt you to choose:\n\n\n\n\n\n\nWhether to install a minimal skeleton (no default middleware), a flat\n  application structure (all code under \nsrc/\n), or a modular structure\n  (directories under \nsrc/\n are modules, each with source code and potentially\n  templates, configuration, assets, etc.).\n\n\n\n\n\n\nA dependency injection container. We recommend using the default, Zend\n  ServiceManager.\n\n\n\n\n\n\nA router. We recommend using the default, FastRoute.\n\n\n\n\n\n\nA template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.\n\n\n\n\n\n\nAn error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.\n\n\n\n\n\n\nStart a web server\n\n\nThe Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using \nbuilt-in web\nserver\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ composer run --timeout=0 serve\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\n\n\nSetting a timeout\n\n\nComposer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the \nphp -S\n command that \ncomposer serve\n spawns continues running\nas a background process, but on other systems halts when the timeout occurs.\n\n\nAs such, we recommend running the \nserve\n script using a timeout. This can\nbe done by using \ncomposer run\n to execute the \nserve\n script, with a\n\n--timeout\n option. When set to \n0\n, as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via\n\nCtrl-C\n). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:\n\n\n$ composer run --timeout=86400 serve\n\n\n\n\n\nDevelopment Tools\n\n\nStarting in version 2 of the skeleton, we ship tools to make development easier.\n\n\nDevelopment Mode\n\n\nzf-development-mode\n allows \nyou to enable and disable development mode from your cli.\n\n\n$ composer development-enable  # enable development mode\n$ composer development-disable # disable development mode\n$ composer development-status  # show development status\n\n\n\nThe development configuration is set in \nconfig/autoload/development.local.php.dist\n.\nIt also allows you to specify configuration and modules that should only be enabled \nwhen in development, and not when in production.\n\n\nClear config cache\n\n\nProduction settings are the default, which means enabling the configuration cache. \nHowever, it must be easy for developers to clear the configuration cache. That's\nwhat this command does.\n\n\n$ composer clear-config-cache\n\n\n\nTesting Your Code\n\n\nPHPUnit\n and \n\nPHP_CodeSniffer\n are now\ninstalled by default. To execute tests and detect coding standards violations,\nrun the following command: \n\n\n$ composer check\n\n\n\nSecurity Advisories\n\n\nWe have included the \nsecurity-advisories\n\npackage to notify you about installed dependencies with known security\nvulnerabilities. Each time you run \ncomposer update\n, \ncomposer install\n, or\n\ncomposer require\n, it prevents installation of software with known and\ndocumented security issues.\n\n\nModules\n\n\nComposer will prompt you during installation to ask if you want a\nminimal application (no structure or default middleware provided), flat\napplication (all source code under the same tree, and the default selection), or\nmodular application. This latter option is new in the version 2 series, and\nallows you to segregate discrete areas of application functionality into\n\nmodules\n, which can contain source code, templates, assets, and more; these can\nlater be repackaged for re-use if desired.\n\n\nSupport for modules is available via the\n\nzend-component-installer\n\nand \nzend-config-aggregator\n\npackages; the \nzend-expressive-tooling\n.\npackage provides tools for creating and manipulating modules in your\napplication.\n\n\nComponent Installer\n\n\nWhenever you add a component or module that exposes itself as such, the \n\nzend-component-installer\n \ncomposer plugin will prompt you, asking if and where you want to inject its\nconfiguration. This ensures that components are wired automatically for you.\n\n\nIn most cases, you will choose to inject in the \nconfig/config.php\n file; for\ntools intended only for usage during development, choose\n\nconfig/development.config.php.dist\n.\n\n\nConfig Aggregator\n\n\nThe \nzend-config-aggregator\n\nlibrary collects and merges configuration from different sources. It also supports \nconfiguration caching.\n\n\nAs an example, your \nconfig/config.php\n file might read as follows in order to\naggregate configuration from development mode settings, application\nconfiguration, and theoretical \nUser\n, \nBlog\n, and \nApp\n modules:\n\n\n<?php // config/config.php\n\n$aggregator = new ConfigAggregator([\n    // Module configuration\n    App\\ConfigProvider::class,\n    BlogModule\\ConfigProvider::class,\n    UserModule\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], 'data/config-cache.php');\n\nreturn $aggregator->getMergedConfig();\n\n\n\nThe configuration is merged in the same order as it is passed, with later entries \nhaving precedence.\n\n\nConfig Providers\n\n\nConfigAggregator\n works by aggregating \"Config Providers\" passed to its\nconstructor. Each provider should be a callable class that requires no\nconstructor parameters, where invocation returns a configuration array (or a PHP\ngenerator) to be merged.\n\n\nLibraries or modules can have configuration providers that provide default values \nfor a library or module. For the \nUserModule\\ConfigProvider\n class loaded in the\n\nConfigAggregator\n above, the \nConfigProvider\n might look like this:\n\n\n<?php\n\nnamespace UserModule;\n\nclass ConfigProvider\n{\n    /**\n     * Returns the configuration array\n     *\n     * To add some sort of a structure, each section is defined in a separate\n     * method which returns an array with its configuration.\n     *\n     * @return array\n     */\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'users'        => $this->getConfig(),\n        ];\n    }\n\n    /**\n     * Returns the container dependencies\n     *\n     * @return array\n     */\n    public function getDependencies()\n    {\n        return [\n            'factories'  => [\n                Action\\LoginAction::class =>\n                    Factory\\Action\\LoginActionFactory::class,\n\n                Middleware\\AuthenticationMiddleware::class =>\n                    Factory\\Middleware\\AuthenticationMiddlewareFactory::class,\n            ],\n        ];\n    }\n\n    /**\n     * Returns the default module configuration\n     *\n     * @return array\n     */\n    public function getConfig()\n    {\n        return [\n            'paths' => [\n                'enable_registration' => true,\n                'enable_username'     => false,\n                'enable_display_name' => true,\n            ],\n        ];\n    }\n}\n\n\n\nexpressive-module command\n\n\nTo aid in the creation, registration, and deregistration of modules in your\napplication, the installer will add the \nzendframework/zend-expressive-tooling\n\nas a development requirement when you choose the modular application layout.\n\n\nThe tool is available from your application root directory via\n\n./vendor/bin/expressive-module\n. For brevity, we will only reference the tool's\nname, \nexpressive-module\n, when describing its capabilities.\n\n\nThis tool provides the following functionality:\n\n\n\n\nexpressive-module create <modulename>\n will create the default directory\n  structure for the named module, create a \nConfigProvider\n for the module, add\n  an autoloading rule to \ncomposer.json\n, and register the \nConfigProvider\n with\n  the application configuration.\n\n\nexpressive-module register <modulename>\n will add an autoloading rule to\n  \ncomposer.json\n for the module, and register its \nConfigProvider\n, if found,\n  with the application configuration.\n\n\nexpressive-module deregister <modulename>\n will remove any autoloading rules\n  for the module from \ncomposer.json\n, and deregister its \nConfigProvider\n, if\n  found, from the application configuration.\n\n\n\n\nYou can find out more about its features in the \ncommand line tooling\ndocumentation\n.\n\n\nAdding Middleware\n\n\nThe skeleton makes the assumption that you will be writing your middleware as\nclasses, and uses \npiping and routing\n to add \nyour middleware.\n\n\nPiping\n\n\nPiping\n is a foundation feature of the \nunderlying \nzend-stratigility\n\nimplementation. You can setup the middleware pipeline in \nconfig/pipeline.php\n.\nIn this section, we'll demonstrate setting up a basic pipeline that includes\nerror handling, segregated applications, routing, middleware dispatch, and more.\n\n\nThe error handler should be the first (most outer) middleware to catch all \nexceptions.\n\n\n$app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);  \n\n\n\nAfter the \nErrorHandler\n you can pipe more middleware that you want to execute \non every request, such as bootstrapping, pre-conditions, and modifications to \noutgoing responses:\n\n\n$app->pipe(ServerUrlMiddleware::class);  \n\n\n\nPiped middleware may be either callables or service names. Middleware may also \nbe passed as an array; each item in the array must resolve to middleware \neventually (i.e., callable or service name); underneath, Expressive creates\n\nZend\\Stratigility\\MiddlewarePipe\n instances with each of the middleware listed\npiped to it.\n\n\nMiddleware can be attached to specific paths, allowing you to mix and match\napplications under a common domain. The handlers in each middleware attached \nthis way will see a URI with the \nMATCHED PATH SEGMENT REMOVED!!!\n\n\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);    \n\n\n\nNext, you should register the routing middleware in the middleware pipeline:\n\n\n$app->pipeRoutingMiddleware();\n\n\n\nAdd more middleware that needs to introspect the routing results; this might \ninclude:\n\n\n\n\nhandling for HTTP \nHEAD\n requests\n\n\nhandling for HTTP \nOPTIONS\n requests\n\n\nmiddleware for handling URI generation\n\n\nroute-based authentication\n\n\nroute-based validation\n\n\netc.\n\n\n\n\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n\n\n\nNext, register the dispatch middleware in the middleware pipeline:\n\n\n$app->pipeDispatchMiddleware();\n\n\n\nAt this point, if no response is return by any middleware, we need to provide a\nway of notifying the user of this; by default, we use the \nNotFoundHandler\n, but\nyou can provide any other fallback middleware you wish:\n\n\n$app->pipe(NotFoundHandler::class);\n\n\n\nThe full example then looks something like this:\n\n\n// In config/pipeline.php:\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);\n\n// These assume that the variables listed are defined in this scope:\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n$app->pipeRoutingMiddleware();\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n$app->pipe(NotFoundHandler::class);\n\n\n\nRouting\n\n\nRouting\n is an additional feature\nprovided by Expressive. Routing is setup in \nconfig/routes.php\n.\n\n\nYou can setup routes with a single request method:\n\n\n$app->get('/', App\\Action\\HomePageAction::class, 'home');\n$app->post('/album', App\\Action\\AlbumCreateAction::class, 'album.create');\n$app->put('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.put');\n$app->patch('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.patch');\n$app->delete('/album/:id', App\\Action\\AlbumDeleteAction::class, 'album.delete');\n\n\n\nOr with multiple request methods:\n\n\n$app->route('/contact', App\\Action\\ContactAction::class, ['GET', 'POST', ...], 'contact');\n\n\n\nOr handling all request methods:\n\n\n$app->route('/contact', App\\Action\\ContactAction::class)->setName('contact');\n\n\n\nAlternately, to be explicit, the above could be written as:\n\n\n$app->route(\n  '/contact',\n  App\\Action\\ContactAction::class,\n  Zend\\Expressive\\Router\\Route::HTTP_METHOD_ANY,\n  'contact'\n);  \n\n\n\nWe recommend a single middleware class per combination of route and request\nmethod.\n\n\nNext Steps\n\n\nThe skeleton provides a default structure for templates, if you choose to use them. \nLet's see how you can create your first vanilla middleware, and templated middleware.\n\n\nCreating middleware\n\n\nTo create middleware, create a class implementing\n\nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n. This interface defines a\nsingle method, \nprocess()\n, which accepts a\n\nPsr\\Http\\Message\\ServerRequestInterface\n instance and an\n\nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instance.\n\n\n\n\nLegacy double-pass middleware\n\n\nPrior to Expressive 2.0, the default middleware style was what is termed\n\"double-pass\", for the fact that it passes both the request and response between\nlayers. This middleware did not require an interface, and relied on a\nconventional definition of:\n\n\nuse Psr\\Http\\Message;\n\nfunction (\n  Message\\ServerRequestInterface $request,\n  Message\\ResponseInterface $response,\n  callable $next\n) : Message\\ResponseInterface\n\n\n\nWhile this style of middleware is still quite wide-spread and used in a number\nof projects, it has some flaws. Chief among them is the fact that middleware\nshould not rely on the \n$response\n instance provided to them (as it may have\nmodifications unacceptable for the current context), and that a response\nreturned from inner layers may not be based off the \n$response\n provided to them\n(as inner layers may create and return a completely different response).\n\n\nStarting in Expressive 2.0, we add support for\n\nhttp-interop/http-middleware\n,\nwhich is a working group of \nPHP-FIG\n dedicated to\ncreating a common middleware standard. This middleware uses what is termed\na \"single-pass\" or \"lambda\" architecture, whereby only the request instance is\npassed between layers. We now recommend writing middleware using the\nhttp-middleware interfaces for all new middleware.\n\n\nMiddleware using the double-pass style is still accepted by Expressive, but\nsupport for it will be discontinued once http-middleware is formally approved\nby PHP-FIG.\n\n\n\n\nThe skeleton defines an \nApp\n namespace for you, and suggests placing middleware\nunder the namespace \nApp\\Action\n.\n\n\nLet's create a \"Hello\" action. Place the following in\n\nsrc/App/Action/HelloAction.php\n:\n\n\n<?php\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass HelloAction implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // On all PHP versions:\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        // Or, on PHP 7+:\n        $target = $request->getQueryParams()['target'] ?? 'World';\n\n        $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\n\n        return new HtmlResponse(sprintf(\n            '<h1>Hello, %s!</h1>',\n            $target\n        ));\n    }\n}\n\n\n\nThe above looks for a query string parameter \"target\", and uses its value to\nprovide a message, which is then returned in an HTML response.\n\n\nNow we need to inform the application of this middleware, and indicate what\npath will invoke it. Open the file \nconfig/autoload/dependencies.global.php\n.\nEdit that file to add an \ninvokable\n entry for the new middleware:\n\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'invokables' => [\n            App\\Action\\HelloAction::class => App\\Action\\HelloAction::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nNow open the file \nconfig/routes.php\n, and add the following at the bottom of\nthe file:\n\n\n$app->get('/hello', App\\Action\\HelloAction::class, 'hello');\n\n\n\nOnce you've completed the above, give it a try by going to each of the\nfollowing URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYou should see the message change as you go between the two URIs!\n\n\nUsing templates\n\n\nYou likely don't want to hardcode HTML into your middleware; so, let's use\ntemplates. This particular exercise assumes you chose to use the\n\nPlates\n integration.\n\n\nTemplates are installed under the \ntemplates/\n subdirectory. By default, we also\nregister the template namespace \napp\n to correspond with the \ntemplates/app\n\nsubdirectory. Create the file \ntemplates/app/hello-world.phtml\n with the\nfollowing contents:\n\n\n<?php $this->layout('layout::default', ['title' => 'Greetings']) ?>\n\n<h2>Hello, <?= $this->e($target) ?></h2>\n\n\n\nNow that we have a template, we need to:\n\n\n\n\nInject a renderer into our action class.\n\n\nUse the renderer to render the contents.\n\n\n\n\nReplace your \nsrc/App/Action/HelloAction.php\n file with the following contents:\n\n\n<?php\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloAction implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // On all PHP versions:\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        // Or, on PHP 7+:\n        $target = $request->getQueryParams()['target'] ?? 'World';\n\n        return new HtmlResponse(\n            $this->renderer->render('app::hello-world', ['target' => $target])\n        );\n    }\n}\n\n\n\nThe above modifies the class to accept a renderer to the constructor, and then\ncalls on it to render a template. Note that we no longer need to escape our\ntarget; the template takes care of that for us.\n\n\nHow does the template renderer get into the action? The answer is dependency \ninjection.\n\n\nFor the next part of the example, we'll be creating and wiring a factory for\ncreating the \nHelloAction\n instance; the example assumes you used the default\nselection for a dependency injection container, zend-servicemanager.\n\n\nzend-servicemanager provides a tool for generating factories based on\nreflecting a class; we'll use that to generate our factory:\n\n\n$ ./vendor/bin/generate-factory-for-class \"App\\\\Action\\\\HelloAction\" > src/App/Action/HelloActionFactory.php\n\n\n\nWith that in place, we'll now update our configuration. Open the file\n\nconfig/autoload/dependencies.global.php\n; we'll remove the \ninvokables\n entry\nwe created previously, and add a \nfactories\n entry:\n\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'invokables' => [\n            // Remove this entry:\n            App\\Action\\HelloAction::class => App\\Action\\HelloAction::class,\n        ],\n        'factories' => [\n            /* ... */\n            // Add this:\n            App\\Action\\HelloAction::class => App\\Action\\HelloActionFactory::class,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nSave that file, and now re-visit the URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYour page should now have the same layout as the landing page of the skeleton\napplication!\n\n\nCongratulations!\n\n\nCongratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:\n\n\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling",
            "title": "Quick Start: Skeleton Installer"
        },
        {
            "location": "/getting-started/skeleton/#quick-start-using-the-skeleton-installer",
            "text": "The easiest way to get started with Expressive is to use the  skeleton\napplication and installer .\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.",
            "title": "Quick Start: Using the Skeleton + Installer"
        },
        {
            "location": "/getting-started/skeleton/#create-a-new-project",
            "text": "First, we'll create a new project, using Composer's  create-project  command:  $ composer create-project zendframework/zend-expressive-skeleton expressive  This will prompt you to choose:    Whether to install a minimal skeleton (no default middleware), a flat\n  application structure (all code under  src/ ), or a modular structure\n  (directories under  src/  are modules, each with source code and potentially\n  templates, configuration, assets, etc.).    A dependency injection container. We recommend using the default, Zend\n  ServiceManager.    A router. We recommend using the default, FastRoute.    A template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.    An error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.",
            "title": "Create a new project"
        },
        {
            "location": "/getting-started/skeleton/#start-a-web-server",
            "text": "The Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using  built-in web\nserver .  From the project root directory, execute the following:  $ composer run --timeout=0 serve  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!",
            "title": "Start a web server"
        },
        {
            "location": "/getting-started/skeleton/#setting-a-timeout",
            "text": "Composer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the  php -S  command that  composer serve  spawns continues running\nas a background process, but on other systems halts when the timeout occurs.  As such, we recommend running the  serve  script using a timeout. This can\nbe done by using  composer run  to execute the  serve  script, with a --timeout  option. When set to  0 , as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via Ctrl-C ). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:  $ composer run --timeout=86400 serve",
            "title": "Setting a timeout"
        },
        {
            "location": "/getting-started/skeleton/#development-tools",
            "text": "Starting in version 2 of the skeleton, we ship tools to make development easier.",
            "title": "Development Tools"
        },
        {
            "location": "/getting-started/skeleton/#development-mode",
            "text": "zf-development-mode  allows \nyou to enable and disable development mode from your cli.  $ composer development-enable  # enable development mode\n$ composer development-disable # disable development mode\n$ composer development-status  # show development status  The development configuration is set in  config/autoload/development.local.php.dist .\nIt also allows you to specify configuration and modules that should only be enabled \nwhen in development, and not when in production.",
            "title": "Development Mode"
        },
        {
            "location": "/getting-started/skeleton/#clear-config-cache",
            "text": "Production settings are the default, which means enabling the configuration cache. \nHowever, it must be easy for developers to clear the configuration cache. That's\nwhat this command does.  $ composer clear-config-cache",
            "title": "Clear config cache"
        },
        {
            "location": "/getting-started/skeleton/#testing-your-code",
            "text": "PHPUnit  and  PHP_CodeSniffer  are now\ninstalled by default. To execute tests and detect coding standards violations,\nrun the following command:   $ composer check",
            "title": "Testing Your Code"
        },
        {
            "location": "/getting-started/skeleton/#security-advisories",
            "text": "We have included the  security-advisories \npackage to notify you about installed dependencies with known security\nvulnerabilities. Each time you run  composer update ,  composer install , or composer require , it prevents installation of software with known and\ndocumented security issues.",
            "title": "Security Advisories"
        },
        {
            "location": "/getting-started/skeleton/#modules",
            "text": "Composer will prompt you during installation to ask if you want a\nminimal application (no structure or default middleware provided), flat\napplication (all source code under the same tree, and the default selection), or\nmodular application. This latter option is new in the version 2 series, and\nallows you to segregate discrete areas of application functionality into modules , which can contain source code, templates, assets, and more; these can\nlater be repackaged for re-use if desired.  Support for modules is available via the zend-component-installer \nand  zend-config-aggregator \npackages; the  zend-expressive-tooling .\npackage provides tools for creating and manipulating modules in your\napplication.",
            "title": "Modules"
        },
        {
            "location": "/getting-started/skeleton/#component-installer",
            "text": "Whenever you add a component or module that exposes itself as such, the  zend-component-installer  \ncomposer plugin will prompt you, asking if and where you want to inject its\nconfiguration. This ensures that components are wired automatically for you.  In most cases, you will choose to inject in the  config/config.php  file; for\ntools intended only for usage during development, choose config/development.config.php.dist .",
            "title": "Component Installer"
        },
        {
            "location": "/getting-started/skeleton/#config-aggregator",
            "text": "The  zend-config-aggregator \nlibrary collects and merges configuration from different sources. It also supports \nconfiguration caching.  As an example, your  config/config.php  file might read as follows in order to\naggregate configuration from development mode settings, application\nconfiguration, and theoretical  User ,  Blog , and  App  modules:  <?php // config/config.php\n\n$aggregator = new ConfigAggregator([\n    // Module configuration\n    App\\ConfigProvider::class,\n    BlogModule\\ConfigProvider::class,\n    UserModule\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], 'data/config-cache.php');\n\nreturn $aggregator->getMergedConfig();  The configuration is merged in the same order as it is passed, with later entries \nhaving precedence.",
            "title": "Config Aggregator"
        },
        {
            "location": "/getting-started/skeleton/#config-providers",
            "text": "ConfigAggregator  works by aggregating \"Config Providers\" passed to its\nconstructor. Each provider should be a callable class that requires no\nconstructor parameters, where invocation returns a configuration array (or a PHP\ngenerator) to be merged.  Libraries or modules can have configuration providers that provide default values \nfor a library or module. For the  UserModule\\ConfigProvider  class loaded in the ConfigAggregator  above, the  ConfigProvider  might look like this:  <?php\n\nnamespace UserModule;\n\nclass ConfigProvider\n{\n    /**\n     * Returns the configuration array\n     *\n     * To add some sort of a structure, each section is defined in a separate\n     * method which returns an array with its configuration.\n     *\n     * @return array\n     */\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'users'        => $this->getConfig(),\n        ];\n    }\n\n    /**\n     * Returns the container dependencies\n     *\n     * @return array\n     */\n    public function getDependencies()\n    {\n        return [\n            'factories'  => [\n                Action\\LoginAction::class =>\n                    Factory\\Action\\LoginActionFactory::class,\n\n                Middleware\\AuthenticationMiddleware::class =>\n                    Factory\\Middleware\\AuthenticationMiddlewareFactory::class,\n            ],\n        ];\n    }\n\n    /**\n     * Returns the default module configuration\n     *\n     * @return array\n     */\n    public function getConfig()\n    {\n        return [\n            'paths' => [\n                'enable_registration' => true,\n                'enable_username'     => false,\n                'enable_display_name' => true,\n            ],\n        ];\n    }\n}",
            "title": "Config Providers"
        },
        {
            "location": "/getting-started/skeleton/#expressive-module-command",
            "text": "To aid in the creation, registration, and deregistration of modules in your\napplication, the installer will add the  zendframework/zend-expressive-tooling \nas a development requirement when you choose the modular application layout.  The tool is available from your application root directory via ./vendor/bin/expressive-module . For brevity, we will only reference the tool's\nname,  expressive-module , when describing its capabilities.  This tool provides the following functionality:   expressive-module create <modulename>  will create the default directory\n  structure for the named module, create a  ConfigProvider  for the module, add\n  an autoloading rule to  composer.json , and register the  ConfigProvider  with\n  the application configuration.  expressive-module register <modulename>  will add an autoloading rule to\n   composer.json  for the module, and register its  ConfigProvider , if found,\n  with the application configuration.  expressive-module deregister <modulename>  will remove any autoloading rules\n  for the module from  composer.json , and deregister its  ConfigProvider , if\n  found, from the application configuration.   You can find out more about its features in the  command line tooling\ndocumentation .",
            "title": "expressive-module command"
        },
        {
            "location": "/getting-started/skeleton/#adding-middleware",
            "text": "The skeleton makes the assumption that you will be writing your middleware as\nclasses, and uses  piping and routing  to add \nyour middleware.",
            "title": "Adding Middleware"
        },
        {
            "location": "/getting-started/skeleton/#piping",
            "text": "Piping  is a foundation feature of the \nunderlying  zend-stratigility \nimplementation. You can setup the middleware pipeline in  config/pipeline.php .\nIn this section, we'll demonstrate setting up a basic pipeline that includes\nerror handling, segregated applications, routing, middleware dispatch, and more.  The error handler should be the first (most outer) middleware to catch all \nexceptions.  $app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);    After the  ErrorHandler  you can pipe more middleware that you want to execute \non every request, such as bootstrapping, pre-conditions, and modifications to \noutgoing responses:  $app->pipe(ServerUrlMiddleware::class);    Piped middleware may be either callables or service names. Middleware may also \nbe passed as an array; each item in the array must resolve to middleware \neventually (i.e., callable or service name); underneath, Expressive creates Zend\\Stratigility\\MiddlewarePipe  instances with each of the middleware listed\npiped to it.  Middleware can be attached to specific paths, allowing you to mix and match\napplications under a common domain. The handlers in each middleware attached \nthis way will see a URI with the  MATCHED PATH SEGMENT REMOVED!!!  $app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);      Next, you should register the routing middleware in the middleware pipeline:  $app->pipeRoutingMiddleware();  Add more middleware that needs to introspect the routing results; this might \ninclude:   handling for HTTP  HEAD  requests  handling for HTTP  OPTIONS  requests  middleware for handling URI generation  route-based authentication  route-based validation  etc.   $app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);  Next, register the dispatch middleware in the middleware pipeline:  $app->pipeDispatchMiddleware();  At this point, if no response is return by any middleware, we need to provide a\nway of notifying the user of this; by default, we use the  NotFoundHandler , but\nyou can provide any other fallback middleware you wish:  $app->pipe(NotFoundHandler::class);  The full example then looks something like this:  // In config/pipeline.php:\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);\n\n// These assume that the variables listed are defined in this scope:\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n$app->pipeRoutingMiddleware();\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n$app->pipe(NotFoundHandler::class);",
            "title": "Piping"
        },
        {
            "location": "/getting-started/skeleton/#routing",
            "text": "Routing  is an additional feature\nprovided by Expressive. Routing is setup in  config/routes.php .  You can setup routes with a single request method:  $app->get('/', App\\Action\\HomePageAction::class, 'home');\n$app->post('/album', App\\Action\\AlbumCreateAction::class, 'album.create');\n$app->put('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.put');\n$app->patch('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.patch');\n$app->delete('/album/:id', App\\Action\\AlbumDeleteAction::class, 'album.delete');  Or with multiple request methods:  $app->route('/contact', App\\Action\\ContactAction::class, ['GET', 'POST', ...], 'contact');  Or handling all request methods:  $app->route('/contact', App\\Action\\ContactAction::class)->setName('contact');  Alternately, to be explicit, the above could be written as:  $app->route(\n  '/contact',\n  App\\Action\\ContactAction::class,\n  Zend\\Expressive\\Router\\Route::HTTP_METHOD_ANY,\n  'contact'\n);    We recommend a single middleware class per combination of route and request\nmethod.",
            "title": "Routing"
        },
        {
            "location": "/getting-started/skeleton/#next-steps",
            "text": "The skeleton provides a default structure for templates, if you choose to use them. \nLet's see how you can create your first vanilla middleware, and templated middleware.",
            "title": "Next Steps"
        },
        {
            "location": "/getting-started/skeleton/#creating-middleware",
            "text": "To create middleware, create a class implementing Interop\\Http\\ServerMiddleware\\MiddlewareInterface . This interface defines a\nsingle method,  process() , which accepts a Psr\\Http\\Message\\ServerRequestInterface  instance and an Interop\\Http\\ServerMiddleware\\DelegateInterface  instance.",
            "title": "Creating middleware"
        },
        {
            "location": "/getting-started/skeleton/#legacy-double-pass-middleware",
            "text": "Prior to Expressive 2.0, the default middleware style was what is termed\n\"double-pass\", for the fact that it passes both the request and response between\nlayers. This middleware did not require an interface, and relied on a\nconventional definition of:  use Psr\\Http\\Message;\n\nfunction (\n  Message\\ServerRequestInterface $request,\n  Message\\ResponseInterface $response,\n  callable $next\n) : Message\\ResponseInterface  While this style of middleware is still quite wide-spread and used in a number\nof projects, it has some flaws. Chief among them is the fact that middleware\nshould not rely on the  $response  instance provided to them (as it may have\nmodifications unacceptable for the current context), and that a response\nreturned from inner layers may not be based off the  $response  provided to them\n(as inner layers may create and return a completely different response).  Starting in Expressive 2.0, we add support for http-interop/http-middleware ,\nwhich is a working group of  PHP-FIG  dedicated to\ncreating a common middleware standard. This middleware uses what is termed\na \"single-pass\" or \"lambda\" architecture, whereby only the request instance is\npassed between layers. We now recommend writing middleware using the\nhttp-middleware interfaces for all new middleware.  Middleware using the double-pass style is still accepted by Expressive, but\nsupport for it will be discontinued once http-middleware is formally approved\nby PHP-FIG.   The skeleton defines an  App  namespace for you, and suggests placing middleware\nunder the namespace  App\\Action .  Let's create a \"Hello\" action. Place the following in src/App/Action/HelloAction.php :  <?php\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass HelloAction implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // On all PHP versions:\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        // Or, on PHP 7+:\n        $target = $request->getQueryParams()['target'] ?? 'World';\n\n        $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\n\n        return new HtmlResponse(sprintf(\n            '<h1>Hello, %s!</h1>',\n            $target\n        ));\n    }\n}  The above looks for a query string parameter \"target\", and uses its value to\nprovide a message, which is then returned in an HTML response.  Now we need to inform the application of this middleware, and indicate what\npath will invoke it. Open the file  config/autoload/dependencies.global.php .\nEdit that file to add an  invokable  entry for the new middleware:  return [\n    'dependencies' => [\n        /* ... */\n        'invokables' => [\n            App\\Action\\HelloAction::class => App\\Action\\HelloAction::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Now open the file  config/routes.php , and add the following at the bottom of\nthe file:  $app->get('/hello', App\\Action\\HelloAction::class, 'hello');  Once you've completed the above, give it a try by going to each of the\nfollowing URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   You should see the message change as you go between the two URIs!",
            "title": "Legacy double-pass middleware"
        },
        {
            "location": "/getting-started/skeleton/#using-templates",
            "text": "You likely don't want to hardcode HTML into your middleware; so, let's use\ntemplates. This particular exercise assumes you chose to use the Plates  integration.  Templates are installed under the  templates/  subdirectory. By default, we also\nregister the template namespace  app  to correspond with the  templates/app \nsubdirectory. Create the file  templates/app/hello-world.phtml  with the\nfollowing contents:  <?php $this->layout('layout::default', ['title' => 'Greetings']) ?>\n\n<h2>Hello, <?= $this->e($target) ?></h2>  Now that we have a template, we need to:   Inject a renderer into our action class.  Use the renderer to render the contents.   Replace your  src/App/Action/HelloAction.php  file with the following contents:  <?php\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloAction implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // On all PHP versions:\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        // Or, on PHP 7+:\n        $target = $request->getQueryParams()['target'] ?? 'World';\n\n        return new HtmlResponse(\n            $this->renderer->render('app::hello-world', ['target' => $target])\n        );\n    }\n}  The above modifies the class to accept a renderer to the constructor, and then\ncalls on it to render a template. Note that we no longer need to escape our\ntarget; the template takes care of that for us.  How does the template renderer get into the action? The answer is dependency \ninjection.  For the next part of the example, we'll be creating and wiring a factory for\ncreating the  HelloAction  instance; the example assumes you used the default\nselection for a dependency injection container, zend-servicemanager.  zend-servicemanager provides a tool for generating factories based on\nreflecting a class; we'll use that to generate our factory:  $ ./vendor/bin/generate-factory-for-class \"App\\\\Action\\\\HelloAction\" > src/App/Action/HelloActionFactory.php  With that in place, we'll now update our configuration. Open the file config/autoload/dependencies.global.php ; we'll remove the  invokables  entry\nwe created previously, and add a  factories  entry:  return [\n    'dependencies' => [\n        /* ... */\n        'invokables' => [\n            // Remove this entry:\n            App\\Action\\HelloAction::class => App\\Action\\HelloAction::class,\n        ],\n        'factories' => [\n            /* ... */\n            // Add this:\n            App\\Action\\HelloAction::class => App\\Action\\HelloActionFactory::class,\n        ],\n        /* ... */\n    ],\n];  Save that file, and now re-visit the URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   Your page should now have the same layout as the landing page of the skeleton\napplication!",
            "title": "Using templates"
        },
        {
            "location": "/getting-started/skeleton/#congratulations",
            "text": "Congratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:   Containers  Routing  Templating  Error Handling",
            "title": "Congratulations!"
        },
        {
            "location": "/features/middleware-types/",
            "text": "Middleware Types\n\n\nExpressive allows you to compose applications out of \npipeline\n and \nrouted\n\nmiddleware.\n\n\nPipeline\n middleware is middleware that defines the workflow of your\napplication. These generally run on every execution of the application, and\ninclude such aspects as:\n\n\n\n\nError handling\n\n\nLocale detection\n\n\nSession setup\n\n\nAuthentication and authorization\n\n\n\n\nRouted\n middleware is middleware that responds only to specific URI paths and\nHTTP methods. As an example, you might want middleware that only responds to\nHTTP POST requests to the path \n/users\n.\n\n\nExpressive allows you to define middleware using any of the following:\n\n\n\n\nhttp-interop/http-middleware\n\n  instances (starting in Expressive 2.X).\n\n\nCallable middleware that implements the http-interop/http-middleware signature\n  (starting in Expressive 2.X).\n\n\nCallable \"double-pass\" middleware (as used in Expressive 1.X, and supported in\n  Expressive 2.X).\n\n\nService names resolving to one of the above middleware types.\n\n\nMiddleware pipelines expressed as arrays of the above middleware types.\n\n\n\n\nhttp-interop/http-middleware\n\n\nThe http-interop/http-middleware project is the basis for the proposed PSR-15\nspecification, which covers HTTP Server Middleware that consumes\n\nPSR-7\n HTTP messages. The project defines two\ninterfaces, \nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n and \n\nInterop\\Http\\ServerMiddleware\\DelegateInterface\n. Expressive accepts middleware\nthat implements the \nMiddlewareInterface\n. As an example:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass SomeMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do something and return a response, or\n        // delegate to another handler capable of\n        // returning a response via:\n        //\n        // return $delegate->process($request);\n    }\n}\n\n\n\nIf you are using PHP 7 or above, you could also implement such middleware via an\nanonymous class.\n\n\nCallable http-middleware\n\n\nSometimes you may not want to create a class for one-off middleware. As such,\nExpressive allows you to provide a PHP callable that uses the same signature as\n\nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    // do something and return a response, or\n    // delegate to another handler capable of\n    // returning a response via:\n    //\n    // return $delegate->process($request);\n}\n\n\n\nOne note: the \n$request\n argument does not require a typehint, and examples\nthroughout the manual will omit the typehint when demonstrating callable\nmiddleware.\n\n\nDouble-pass middleware\n\n\nExpressive 1.X was based on Stratigility 1.X, which allowed middleware with the\nfollowing signature:\n\n\n<?php\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction(\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    // Process the request and return a response,\n    // or delegate to another process to handle\n    // the request via:\n    //\n    // return $next($request, $response);\n}\n\n\n\nThis middleware is called \"double-pass\" due to the fact that it requires both\nthe request and response arguments.\n\n\nIn such middleware, no typehints are \nrequired\n, but they are \nencouraged\n.\nAdditionally, we encourage users to \nnever\n use the provided \n$response\n\nargument, but instead create a concrete response to return, or manipulate the\nresponse returned by \n$next\n; this prevents a number of potential error\nconditions that may otherwise occur due to incomplete or mutated response state.\n\n\nThis middleware is still supported in Expressive 2.X, but we encourage users to\nadopt http-interop/http-middleware signatures, as we will be deprecating\ndouble-pass middleware eventually.\n\n\nService-based middleware\n\n\nWe encourage the use of a dependency injection container for providing your\nmiddleware. As such, Expressive also allows you to use \nservice names\n for both\npipeline and routed middleware. Generally, service names will be the specific\nmiddleware class names, but can be any valid string that resolves to a service.\n\n\nWhen Expressive is provided a service name for middleware, it internally\ndecorates the middleware in a \nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n\ninstance, allowing it to be loaded only when dispatched.\n\n\nMiddleware pipelines\n\n\nExpressive allows any pipeline or routed middleware to be self-contained\n\nmiddleware pipelines\n.\nTo prevent the need for instantiating a \nZend\\Stratigility\\MiddlewarePipe\n or\n\nZend\\Expressive\\Application\n instance when defining the pipeline, Expressive\nallows you to provide an array of middleware:\n\n\n// Pipeline middleware:\n$app->pipe([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n// Routed middleware:\n$app->get([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n\n\nThe values in these arrays may be any valid middleware type as defined in this\nchapter.",
            "title": "Middleware Types"
        },
        {
            "location": "/features/middleware-types/#middleware-types",
            "text": "Expressive allows you to compose applications out of  pipeline  and  routed \nmiddleware.  Pipeline  middleware is middleware that defines the workflow of your\napplication. These generally run on every execution of the application, and\ninclude such aspects as:   Error handling  Locale detection  Session setup  Authentication and authorization   Routed  middleware is middleware that responds only to specific URI paths and\nHTTP methods. As an example, you might want middleware that only responds to\nHTTP POST requests to the path  /users .  Expressive allows you to define middleware using any of the following:   http-interop/http-middleware \n  instances (starting in Expressive 2.X).  Callable middleware that implements the http-interop/http-middleware signature\n  (starting in Expressive 2.X).  Callable \"double-pass\" middleware (as used in Expressive 1.X, and supported in\n  Expressive 2.X).  Service names resolving to one of the above middleware types.  Middleware pipelines expressed as arrays of the above middleware types.",
            "title": "Middleware Types"
        },
        {
            "location": "/features/middleware-types/#http-interophttp-middleware",
            "text": "The http-interop/http-middleware project is the basis for the proposed PSR-15\nspecification, which covers HTTP Server Middleware that consumes PSR-7  HTTP messages. The project defines two\ninterfaces,  Interop\\Http\\ServerMiddleware\\MiddlewareInterface  and  Interop\\Http\\ServerMiddleware\\DelegateInterface . Expressive accepts middleware\nthat implements the  MiddlewareInterface . As an example:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass SomeMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do something and return a response, or\n        // delegate to another handler capable of\n        // returning a response via:\n        //\n        // return $delegate->process($request);\n    }\n}  If you are using PHP 7 or above, you could also implement such middleware via an\nanonymous class.",
            "title": "http-interop/http-middleware"
        },
        {
            "location": "/features/middleware-types/#callable-http-middleware",
            "text": "Sometimes you may not want to create a class for one-off middleware. As such,\nExpressive allows you to provide a PHP callable that uses the same signature as Interop\\Http\\ServerMiddleware\\MiddlewareInterface :  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    // do something and return a response, or\n    // delegate to another handler capable of\n    // returning a response via:\n    //\n    // return $delegate->process($request);\n}  One note: the  $request  argument does not require a typehint, and examples\nthroughout the manual will omit the typehint when demonstrating callable\nmiddleware.",
            "title": "Callable http-middleware"
        },
        {
            "location": "/features/middleware-types/#double-pass-middleware",
            "text": "Expressive 1.X was based on Stratigility 1.X, which allowed middleware with the\nfollowing signature:  <?php\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction(\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    // Process the request and return a response,\n    // or delegate to another process to handle\n    // the request via:\n    //\n    // return $next($request, $response);\n}  This middleware is called \"double-pass\" due to the fact that it requires both\nthe request and response arguments.  In such middleware, no typehints are  required , but they are  encouraged .\nAdditionally, we encourage users to  never  use the provided  $response \nargument, but instead create a concrete response to return, or manipulate the\nresponse returned by  $next ; this prevents a number of potential error\nconditions that may otherwise occur due to incomplete or mutated response state.  This middleware is still supported in Expressive 2.X, but we encourage users to\nadopt http-interop/http-middleware signatures, as we will be deprecating\ndouble-pass middleware eventually.",
            "title": "Double-pass middleware"
        },
        {
            "location": "/features/middleware-types/#service-based-middleware",
            "text": "We encourage the use of a dependency injection container for providing your\nmiddleware. As such, Expressive also allows you to use  service names  for both\npipeline and routed middleware. Generally, service names will be the specific\nmiddleware class names, but can be any valid string that resolves to a service.  When Expressive is provided a service name for middleware, it internally\ndecorates the middleware in a  Zend\\Expressive\\Middleware\\LazyLoadingMiddleware \ninstance, allowing it to be loaded only when dispatched.",
            "title": "Service-based middleware"
        },
        {
            "location": "/features/middleware-types/#middleware-pipelines",
            "text": "Expressive allows any pipeline or routed middleware to be self-contained middleware pipelines .\nTo prevent the need for instantiating a  Zend\\Stratigility\\MiddlewarePipe  or Zend\\Expressive\\Application  instance when defining the pipeline, Expressive\nallows you to provide an array of middleware:  // Pipeline middleware:\n$app->pipe([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n// Routed middleware:\n$app->get([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);  The values in these arrays may be any valid middleware type as defined in this\nchapter.",
            "title": "Middleware pipelines"
        },
        {
            "location": "/features/application/",
            "text": "Applications\n\n\nIn zend-expressive, you define a \nZend\\Expressive\\Application\n instance and\nexecute it. The \nApplication\n instance is itself \nmiddleware\n\nthat composes:\n\n\n\n\na \nrouter\n, for dynamically routing requests to middleware.\n\n\na \ndependency injection container\n, for retrieving\n  middleware to dispatch.\n\n\na \ndefault delegate\n (Expressive 2.X)\n  or \nfinal handler\n\n\nan \nemitter\n,\n  for emitting the response when application execution is complete.\n\n\n\n\nYou can define the \nApplication\n instance in several ways:\n\n\n\n\nDirect instantiation, which requires providing several dependencies.\n\n\nThe \nAppFactory\n, which will use some common defaults, but allows injecting alternate\n  container and/or router implementations.\n\n\nVia a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.\n\n\n\n\nRegardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.\n\n\nInstantiation\n\n\nAs noted at the start of this document, we provide several ways to create an\n\nApplication\n instance.\n\n\nConstructor\n\n\nIf you wish to manually instantiate the \nApplication\n instance, it has the\nfollowing constructor:\n\n\n\n\nExpressive 2.X:\n\n\n\n\n/**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Psr\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate\n *     Delegate to invoke when the internal middleware pipeline is exhausted\n *     without returning a response.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Psr\\Container\\ContainerInterface $container = null,\n    Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);\n\n\n\n\n\nExpressive 1.X:\n\n\n\n\n/**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Psr\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|callable $finalHandler Final handler to use when $out is not\n *     provided on invocation.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Psr\\Container\\ContainerInterface $container = null,\n    callable $finalHandler = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);\n\n\n\nIf no container is provided at instantiation, then all routed and piped\nmiddleware \nmust\n be provided as callables.\n\n\nAppFactory\n\n\nZend\\Expressive\\AppFactory\n provides a convenience layer for creating an\n\nApplication\n instance; it makes the assumption that you will use defaults in\nmost situations, and likely only change which container and/or router you wish\nto use. It has the following signature:\n\n\nAppFactory::create(\n    Psr\\Container\\ContainerInterface $container = null,\n    Zend\\Expressive\\Router\\RouterInterface $router = null\n);\n\n\n\nWhen no container or router are provided, it defaults to:\n\n\n\n\nzend-servicemanager for the container.\n\n\nFastRoute for the router.\n\n\n\n\nContainer factory\n\n\nWe also provide a factory that can be consumed by a\n\ncontainer-interop\n\ndependency injection container; see the \ncontainer factories documentation\n\nfor details.\n\n\nAdding routable middleware\n\n\nWe \ndiscuss routing vs piping elsewhere\n; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.\n\n\nRegardless of which \nrouter implementation\n you use, you\ncan use the following methods to provide routable middleware:\n\n\nroute()\n\n\nroute()\n has the following signature:\n\n\npublic function route(\n    $pathOrRoute,\n    $middleware = null,\n    array $methods = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nwhere:\n\n\n\n\n$pathOrRoute\n may be either a string path to match, or a\n  \nZend\\Expressive\\Router\\Route\n instance.\n\n\n$middleware\n \nmust\n be present if \n$pathOrRoute\n is a string path, and\n  \nmust\n be:\n\n\na callable;\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class;\n\n\nan array of any of the above; these will be composed in order into a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\n\n\n$methods\n must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.\n\n\n$name\n is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on \nroute naming\n\n  for details.\n\n\n\n\nThis method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.\n\n\nget(), post(), put(), patch(), delete(), any()\n\n\nEach of the methods \nget()\n, \npost()\n, \nput()\n, \npatch()\n, \ndelete()\n, and \nany()\n\nproxies to \nroute()\n and has the signature:\n\n\nfunction (\n    $pathOrRoute,\n    $middleware = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nEssentially, each calls \nroute()\n and specifies an array consisting solely of\nthe corresponding HTTP method for the \n$methods\n argument.\n\n\nPiping\n\n\nBecause zend-expressive builds on \nzend-stratigility\n,\nand, more specifically, its \nMiddlewarePipe\n definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.\n\n\nThe signature of \npipe()\n is:\n\n\npublic function pipe($pathOrMiddleware, $middleware = null)\n\n\n\nwhere:\n\n\n\n\n$pathOrMiddleware\n is either a string URI path (for path segregation), a\n  callable middleware, or the service name for a middleware to fetch from the\n  composed container.\n\n\n$middleware\n is required if \n$pathOrMiddleware\n is a string URI path. It can\n  be one of:\n\n\na callable;\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class;\n\n\nan array of any of the above; these will be composed in order into a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\n\n\n\n\nUnlike \nZend\\Stratigility\\MiddlewarePipe\n, \nApplication::pipe()\n \nallows\nfetching middleware by service name\n. This facility allows lazy-loading of\nmiddleware only when it is invoked. Internally, it wraps the call to fetch and\ndispatch the middleware inside a closure.\n\n\nAdditionally, we define a new method, \npipeErrorHandler()\n, with the following\nsignature:\n\n\npublic function pipeErrorHandler($pathOrMiddleware, $middleware = null)\n\n\n\nIt acts just like \npipe()\n except when the middleware specified is a service\nname; in that particular case, when it wraps the middleware in a closure, it\nuses the error handler signature:\n\n\nfunction ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next);\n\n\n\nRead the section on \npiping vs routing\n for more information.\n\n\nRegistering routing and dispatch middleware\n\n\nRouting is accomplished via a dedicated middleware method,\n\nApplication::routeMiddleware()\n; similarly, dispatching of routed middleware\nhas a corresponding instance middleware method, \nApplication::dispatchMiddleware()\n.\nEach can be piped/registered with other middleware platforms if desired.\n\n\nThese methods \nMUST\n be piped to the application so that the application will\nroute and dispatch routed middleware. This is done using the following methods:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nSee the section on \npiping\n to see how you can register\nnon-routed middleware and create layered middleware applications.\n\n\nRetrieving dependencies\n\n\nAs noted in the intro, the \nApplication\n class has several dependencies. Some of\nthese may allow further configuration, or may be useful on their own, and have\nmethods for retrieving them. They include:\n\n\n\n\ngetContainer()\n: returns the composed \ncontainer-interop\n\n  instance (used to retrieve routed middleware).\n\n\ngetEmitter()\n: returns the composed\n  \nemitter\n,\n  typically a \nZend\\Expressive\\Emitter\\EmitterStack\n instance.\n\n\ngetDefaultDelegate()\n: (Since 2.0) retrieves the default delegate to use when the internal middleware pipeline is exhausted without returning a response. If none is provided at instantiation, this method will do one of the following:\n\n\nIf no container is composed, instanatiates a\n  \nZend\\Expressive\\Delegate\\NotFoundDelegate\n using the composed response\n  prototype only.\n\n\nIf a container is composed, but does not have the\n  \nZend\\Expressive\\Delegate\\DefaultDelegate\n service, it creates and invokes an\n  instance of \nZend\\Expressive\\Container\\NotFoundDelegateFactory\n, passing it\n  the composed container, and uses the value created.\n\n\nIf a container is composed and contains the \nZend\\Expressive\\Delegate\\DefaultDelegate\n\n  service, it returns that.\n\n\n\n\n\n\ngetFinalHandler(ResponseInterface $response = null)\n: (\nREMOVED in version 2.0\n)\n  retrieves the final handler instance. This is middleware with the signature\n  \nfunction ($request, $response, $error = null)\n, and it is invoked when the\n  middleware pipeline queue is depleted and no response has been returned.\n\n\n\n\nExecuting the application: run()\n\n\nWhen the application is completely setup, you can execute it with the \nrun()\n\nmethod. The method may be called with no arguments, but has the following\nsignature:\n\n\npublic function run(\n    ServerRequestInterface $request = null,\n    ResponseInterface $response = null\n);",
            "title": "Applications"
        },
        {
            "location": "/features/application/#applications",
            "text": "In zend-expressive, you define a  Zend\\Expressive\\Application  instance and\nexecute it. The  Application  instance is itself  middleware \nthat composes:   a  router , for dynamically routing requests to middleware.  a  dependency injection container , for retrieving\n  middleware to dispatch.  a  default delegate  (Expressive 2.X)\n  or  final handler  an  emitter ,\n  for emitting the response when application execution is complete.   You can define the  Application  instance in several ways:   Direct instantiation, which requires providing several dependencies.  The  AppFactory , which will use some common defaults, but allows injecting alternate\n  container and/or router implementations.  Via a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.   Regardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.",
            "title": "Applications"
        },
        {
            "location": "/features/application/#instantiation",
            "text": "As noted at the start of this document, we provide several ways to create an Application  instance.",
            "title": "Instantiation"
        },
        {
            "location": "/features/application/#constructor",
            "text": "If you wish to manually instantiate the  Application  instance, it has the\nfollowing constructor:   Expressive 2.X:   /**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Psr\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate\n *     Delegate to invoke when the internal middleware pipeline is exhausted\n *     without returning a response.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Psr\\Container\\ContainerInterface $container = null,\n    Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);   Expressive 1.X:   /**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Psr\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|callable $finalHandler Final handler to use when $out is not\n *     provided on invocation.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Psr\\Container\\ContainerInterface $container = null,\n    callable $finalHandler = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);  If no container is provided at instantiation, then all routed and piped\nmiddleware  must  be provided as callables.",
            "title": "Constructor"
        },
        {
            "location": "/features/application/#appfactory",
            "text": "Zend\\Expressive\\AppFactory  provides a convenience layer for creating an Application  instance; it makes the assumption that you will use defaults in\nmost situations, and likely only change which container and/or router you wish\nto use. It has the following signature:  AppFactory::create(\n    Psr\\Container\\ContainerInterface $container = null,\n    Zend\\Expressive\\Router\\RouterInterface $router = null\n);  When no container or router are provided, it defaults to:   zend-servicemanager for the container.  FastRoute for the router.",
            "title": "AppFactory"
        },
        {
            "location": "/features/application/#container-factory",
            "text": "We also provide a factory that can be consumed by a container-interop \ndependency injection container; see the  container factories documentation \nfor details.",
            "title": "Container factory"
        },
        {
            "location": "/features/application/#adding-routable-middleware",
            "text": "We  discuss routing vs piping elsewhere ; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.  Regardless of which  router implementation  you use, you\ncan use the following methods to provide routable middleware:",
            "title": "Adding routable middleware"
        },
        {
            "location": "/features/application/#route",
            "text": "route()  has the following signature:  public function route(\n    $pathOrRoute,\n    $middleware = null,\n    array $methods = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route  where:   $pathOrRoute  may be either a string path to match, or a\n   Zend\\Expressive\\Router\\Route  instance.  $middleware   must  be present if  $pathOrRoute  is a string path, and\n   must  be:  a callable;  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class;  an array of any of the above; these will be composed in order into a\n   Zend\\Stratigility\\MiddlewarePipe  instance.    $methods  must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.  $name  is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on  route naming \n  for details.   This method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.",
            "title": "route()"
        },
        {
            "location": "/features/application/#get-post-put-patch-delete-any",
            "text": "Each of the methods  get() ,  post() ,  put() ,  patch() ,  delete() , and  any() \nproxies to  route()  and has the signature:  function (\n    $pathOrRoute,\n    $middleware = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route  Essentially, each calls  route()  and specifies an array consisting solely of\nthe corresponding HTTP method for the  $methods  argument.",
            "title": "get(), post(), put(), patch(), delete(), any()"
        },
        {
            "location": "/features/application/#piping",
            "text": "Because zend-expressive builds on  zend-stratigility ,\nand, more specifically, its  MiddlewarePipe  definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.  The signature of  pipe()  is:  public function pipe($pathOrMiddleware, $middleware = null)  where:   $pathOrMiddleware  is either a string URI path (for path segregation), a\n  callable middleware, or the service name for a middleware to fetch from the\n  composed container.  $middleware  is required if  $pathOrMiddleware  is a string URI path. It can\n  be one of:  a callable;  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class;  an array of any of the above; these will be composed in order into a\n   Zend\\Stratigility\\MiddlewarePipe  instance.     Unlike  Zend\\Stratigility\\MiddlewarePipe ,  Application::pipe()   allows\nfetching middleware by service name . This facility allows lazy-loading of\nmiddleware only when it is invoked. Internally, it wraps the call to fetch and\ndispatch the middleware inside a closure.  Additionally, we define a new method,  pipeErrorHandler() , with the following\nsignature:  public function pipeErrorHandler($pathOrMiddleware, $middleware = null)  It acts just like  pipe()  except when the middleware specified is a service\nname; in that particular case, when it wraps the middleware in a closure, it\nuses the error handler signature:  function ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next);  Read the section on  piping vs routing  for more information.",
            "title": "Piping"
        },
        {
            "location": "/features/application/#registering-routing-and-dispatch-middleware",
            "text": "Routing is accomplished via a dedicated middleware method, Application::routeMiddleware() ; similarly, dispatching of routed middleware\nhas a corresponding instance middleware method,  Application::dispatchMiddleware() .\nEach can be piped/registered with other middleware platforms if desired.  These methods  MUST  be piped to the application so that the application will\nroute and dispatch routed middleware. This is done using the following methods:  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();  See the section on  piping  to see how you can register\nnon-routed middleware and create layered middleware applications.",
            "title": "Registering routing and dispatch middleware"
        },
        {
            "location": "/features/application/#retrieving-dependencies",
            "text": "As noted in the intro, the  Application  class has several dependencies. Some of\nthese may allow further configuration, or may be useful on their own, and have\nmethods for retrieving them. They include:   getContainer() : returns the composed  container-interop \n  instance (used to retrieve routed middleware).  getEmitter() : returns the composed\n   emitter ,\n  typically a  Zend\\Expressive\\Emitter\\EmitterStack  instance.  getDefaultDelegate() : (Since 2.0) retrieves the default delegate to use when the internal middleware pipeline is exhausted without returning a response. If none is provided at instantiation, this method will do one of the following:  If no container is composed, instanatiates a\n   Zend\\Expressive\\Delegate\\NotFoundDelegate  using the composed response\n  prototype only.  If a container is composed, but does not have the\n   Zend\\Expressive\\Delegate\\DefaultDelegate  service, it creates and invokes an\n  instance of  Zend\\Expressive\\Container\\NotFoundDelegateFactory , passing it\n  the composed container, and uses the value created.  If a container is composed and contains the  Zend\\Expressive\\Delegate\\DefaultDelegate \n  service, it returns that.    getFinalHandler(ResponseInterface $response = null) : ( REMOVED in version 2.0 )\n  retrieves the final handler instance. This is middleware with the signature\n   function ($request, $response, $error = null) , and it is invoked when the\n  middleware pipeline queue is depleted and no response has been returned.",
            "title": "Retrieving dependencies"
        },
        {
            "location": "/features/application/#executing-the-application-run",
            "text": "When the application is completely setup, you can execute it with the  run() \nmethod. The method may be called with no arguments, but has the following\nsignature:  public function run(\n    ServerRequestInterface $request = null,\n    ResponseInterface $response = null\n);",
            "title": "Executing the application: run()"
        },
        {
            "location": "/features/container/intro/",
            "text": "Containers\n\n\nExpressive promotes and advocates the usage of\n\nDependency Injection\n/\nInversion of Control\n\n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:\n\n\n\n\n\n\nDefining \napplication\n dependencies: routers, template engines, error\n  handlers, even the \nApplication\n instance itself.\n\n\n\n\n\n\nDefining \nmiddleware\n and related dependencies.\n\n\n\n\n\n\nThe \nApplication\n instance itself stores a container, from which it fetches\nmiddleware when ready to dispatch it; this encourages the idea of defining\nmiddleware-specific dependencies, and factories for ensuring they are injected.\n\n\nTo facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against \nPSR-11 Container\n,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.\n\n\nAt this time, we document support for the following specific containers:\n\n\n\n\nzend-servicemanager\n\n\npimple-interop\n\n\naura.di\n\n\n\n\n\n\nService Names\n\n\nWe recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.\n\n\nFollowing these practices encourages the following:\n\n\n\n\nConsumers have a reasonable idea of what the service should return.\n\n\nUsing interface names as service names promotes re-use and substitution.\n\n\n\n\nIn a few cases, we define \"meta\" names. These are cases where there is no\nclear typehint to follow (e.g., most middleware only uses \ncallable\n as a\ntypehint, or where we want to imply specific configuration is necessary (e.g.,\n\nWhoops\n requires specific configuration to\nwork correctly with Expressive, and thus we do not want a generic service name\nfor it). We try to keep these to a minimum, however.",
            "title": "Introduction"
        },
        {
            "location": "/features/container/intro/#containers",
            "text": "Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control \n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:    Defining  application  dependencies: routers, template engines, error\n  handlers, even the  Application  instance itself.    Defining  middleware  and related dependencies.    The  Application  instance itself stores a container, from which it fetches\nmiddleware when ready to dispatch it; this encourages the idea of defining\nmiddleware-specific dependencies, and factories for ensuring they are injected.  To facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against  PSR-11 Container ,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.  At this time, we document support for the following specific containers:   zend-servicemanager  pimple-interop  aura.di",
            "title": "Containers"
        },
        {
            "location": "/features/container/intro/#service-names",
            "text": "We recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.  Following these practices encourages the following:   Consumers have a reasonable idea of what the service should return.  Using interface names as service names promotes re-use and substitution.   In a few cases, we define \"meta\" names. These are cases where there is no\nclear typehint to follow (e.g., most middleware only uses  callable  as a\ntypehint, or where we want to imply specific configuration is necessary (e.g., Whoops  requires specific configuration to\nwork correctly with Expressive, and thus we do not want a generic service name\nfor it). We try to keep these to a minimum, however.",
            "title": "Service Names"
        },
        {
            "location": "/features/container/factories/",
            "text": "Provided Factories\n\n\nExpressive provides several factories compatible with\n\nPSR-11 Container\n to facilitate \nsetting up common dependencies. The following is a list of provided\ncontainers, what they will create, the suggested service name, and any\nadditional dependencies they may require.\n\n\nAll factories, unless noted otherwise, are in the \nZend\\Expressive\\Container\n\nnamespace, and define an \n__invoke()\n method that accepts an\n\nPsr\\Container\\ContainerInterface\n instance as the sole argument.\n\n\nApplicationFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Application\n\n\nSuggested Name\n: \nZend\\Expressive\\Application\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n. When provided, the service will\n  be used to construct the \nApplication\n instance; otherwise, an FastRoute router\n  implementation will be used.\n\n\nZend\\Expressive\\Delegate\\DefaultDelegate\n. This should return an\n  \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instance to process\n  when the middleware pipeline is exhausted without returning a response;\n  by default, this will be a \nZend\\Expressive\\Delegate\\NotFoundDelegate\n\n  instance.\n\n\nZend\\Diactoros\\Response\\EmitterInterface\n. If none is provided, an instance\n  of \nZend\\Expressive\\Emitter\\EmitterStack\n composing a\n  \nZend\\Diactoros\\Response\\SapiEmitter\n instance will be used.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This \nmay\n be used to seed the\n  application instance with pipeline middleware and/or routed\n  middleware (see more below).\n\n\n\n\n\n\n\n\nAdditionally, the container instance itself is injected into the \nApplication\n\ninstance.\n\n\nWhen the \nconfig\n service is present, the factory can utilize several keys in\norder to seed the \nApplication\n instance:\n\n\n\n\n\n\nprogrammatic_pipeline\n (bool) (Since 1.1.0): when enabled,\n  \nmiddleware_pipeline\n and \nroutes\n configuration are ignored, and the factory\n  will assume that these are injected programmatically elsewhere.\n\n\n\n\n\n\nraise_throwables\n (bool) (Since 1.1.0; obsolete as of 2.0.0): when enabled, \n  this flag will prevent the Stratigility middleware dispatcher from catching\n  exceptions, and instead allow them to bubble outwards.\n\n\n\n\n\n\nmiddleware_pipeline\n can be used to seed the middleware pipeline:\n\n\n\n\n\n\n'middleware_pipeline' => [\n    // An array of middleware to register.\n    [ /* ... */ ],\n\n    // Expressive 1.0:\n    Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n\n    // Expressive 1.1 and above (above constants will still work, though):\n    Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n\n    [ /* ... */ ],\n],\n\n\n\nEach item of the array, other than the entries for routing and dispatch\n  middleware, must be an array itself, with the following structure:\n\n\n[\n    // required:\n    'middleware' => 'Name of middleware service, valid middleware, or an array of these',\n    // optional:\n    'path'  => '/path/to/match',\n    'priority' => 1, // Integer\n\n    // optional under Expressive 1.X; ignored under 2.X:\n    'error' => false, // boolean\n],\n\n\n\nThe \nmiddleware\n key itself is the middleware to execute, and must be a\n  service name resolving to valid middleware, middleware instances (either\n  http-interop middleware or callable double-pass middleware), or an array of\n  these values. If an array is provided, the specified middleware will be\n  composed into a \nZend\\Stratigility\\MiddlewarePipe\n instance. \n\n\nIf the \npath\n key is present, that key will be used to segregate the\n  middleware to a specific matched path (in other words, it will not execute if\n  the path is not matched).\n\n\nThe \npriority\n defaults to 1, and follows the semantics of\n  \nSplPriorityQueue\n: higher integer values\n  indicate higher priority (will execute earlier), while lower/negative integer\n  values indicate lower priority (will execute last). Default priority is 1; use\n  granular priority values to specify the order in which middleware should be\n  piped to the application.\n\n\nYou \ncan\n specify keys for each middleware specification. These will be\n  ignored by the factory, but can be useful when merging several configurations\n  into one for the application.\n\n\nUnder Expressive 1.X, if the \nerror\n key is present and boolean \ntrue\n, then\n  the middleware will be registered as error middleware. (This is necessary due\n  to the fact that the factory defines a callable wrapper around middleware to\n  enable lazy-loading of middleware.) We recommend \nnot\n using this feature;\n  see the chapter on \nerror handling\n for details.\n\n\n\n\nroutes\n is used to define routed middleware. The value must be an array,\n  consisting of arrays defining each middleware:\n\n\n\n\n'routes' => [\n    [\n        'path' => '/path/to/match',\n        'middleware' => 'Middleware service name, valid middleware, or array of these values',\n        'allowed_methods' => ['GET', 'POST', 'PATCH'],\n        'options' => [\n            'stuff' => 'to',\n            'pass'  => 'to',\n            'the'   => 'underlying router',\n        ],\n    ],\n    // etc.\n],\n\n\n\nEach route \nrequires\n:\n\n\n- `path`: the path to match. Format will be based on the router you choose for\n  your project.\n\n- `middleware`: a service name resolving to valid middleware, valid\n  middleware (either http-interop middleware or callable double-pass\n  middleware), or an array of such values (which will be composed into\n  a `Zend\\Stratigility\\MiddlewarePipe` instance); this middleware will be\n  dispatched when the route matches.\n\n\n\n\nOptionally, the route definition may provide:\n\n\n- `allowed_methods`: an array of allowed HTTP methods. If not provided, the\n  application assumes any method is allowed.\n\n- `name`: if not provided, the path will be used as the route name (and, if\n  specific HTTP methods are allowed, a list of those).\n\n- `options`: a key/value set of additional options to pass to the underlying\n  router implementation for the given route. (Typical use cases include\n  passing constraints or default values.)\n\n\n\n\nErrorHandlerFactory\n\n\nSince version 2.0\n\n\n\n\nProvides\n: \nZend\\Stratigility\\Middleware\\ErrorHandler\n\n\nSuggested Name\n: \nZend\\Stratigility\\Middleware\\ErrorHandler\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n. If not provided, the error\n  handler will not compose an error response generator, making it largely\n  useless other than to provide an empty response.\n\n\n\n\n\n\n\n\nErrorResponseGeneratorFactory\n\n\nSince version 2.0\n\n\n\n\nProvides\n: \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n\n\nSuggested Name\n: \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the\n  error response generator will provide a plain text response instead of a\n  templated one.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nErrorResponseGenerator\n instance with a template name to use for errors (see\n  more below), and/or a \"debug\" flag value.\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize two values:\n\n\n\n\ndebug\n, a flag indicating whether or not to provide debug information when\n  creating an error response.\n\n\nzend-expressive.error_handler.template_error\n, a name of an alternate\n  template to use (instead of the default represented in the\n  \nZend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT\n\n  constant).\n\n\n\n\nAs an example:\n\n\n'debug' => true,\n'zend-expressive' => [\n    'error_handler' => [\n        'template_error' => 'name of error template',\n    ],\n],\n\n\n\nNotFoundDelegateFactory\n\n\nSince version 2.0\n\n\n\n\nProvides\n: \nZend\\Expressive\\Delegate\\NotFoundDelegate\n\n\nSuggested Name\n: \nZend\\Expressive\\Delegate\\NotFoundDelegate\n, and aliased\n  to \nZend\\Expressive\\Delegate\\DefaultDelegate\n.\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the\n  delegate will provide a plain text response instead of a templated one.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nNotFoundDelegate\n instance with a template name to use.\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize two values:\n\n\n\n\nzend-expressive.error_handler.template_404\n, a name of an alternate\n  template to use (instead of the default represented in the\n  \nZend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT\n constant).\n\n\n\n\nAs an example:\n\n\n'zend-expressive' => [\n    'error_handler' => [\n        'template_404' => 'name of 404 template',\n    ],\n],\n\n\n\nNotFoundHandlerFactory\n\n\nSince version 2.0\n\n\n\n\nProvides\n: \nZend\\Expressive\\Middleware\\NotFoundHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\Middleware\\NotFoundHandler\n\n\nRequires\n: \nZend\\Expressive\\Delegate\\DefaultDelegate\n\n\n\n\nTemplatedErrorHandlerFactory\n\n\nRemoved in version 2.0\n\n\n\n\nProvides\n: \nZend\\Expressive\\TemplatedErrorHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\FinalHandler\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the error\n  handler will not use templated responses.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nTemplatedErrorHandler\n instance with template names to use for errors (see\n  more below).\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize the\n\nzend-expressive\n top-level key, with the \nerror_handler\n second-level key, to\nseed the \nTemplated\n instance:\n\n\n'zend-expressive' => [\n    'error_handler' => [\n        'template_404'   => 'name of 404 template',\n        'template_error' => 'name of error template',\n    ],\n],\n\n\n\nWhoopsErrorHandlerFactory\n\n\nRemoved in version 2.0.\n\n\n\n\nProvides\n: \nZend\\Expressive\\TemplatedErrorHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\FinalHandler\n\n\nRequires\n:\n\n\nZend\\Expressive\\Whoops\n, which should provide a \nWhoops\\Run\n instance.\n\n\nZend\\Expressive\\WhoopsPageHandler\n, which should provide a\n  \nWhoops\\Handler\\PrettyPageHandler\n instance.\n\n\n\n\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the error\n  handler will not use templated responses.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  instance with template names to use for errors (see more below).\n\n\n\n\n\n\n\n\nThis factory uses \nconfig\n in the same way as the\n\nTemplatedErrorHandlerFactory\n.\n\n\nWhoopsErrorResponseGeneratorFactory\n\n\nSince version 2.0\n\n\n\n\nProvides\n: \nZend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator\n\n\nSuggested Name\n: \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n\n\nRequires\n: \nZend\\Expressive\\Whoops\n (see \nWhoopsFactory\n,\nbelow)\n\n\n\n\nWhoopsFactory\n\n\n\n\nProvides\n: \nWhoops\\Run\n\n\nSuggested Name\n: \nZend\\Expressive\\Whoops\n\n\nRequires\n:\n\n\nZend\\Expressive\\WhoopsPageHandler\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed\n  additional page handlers, specifically the \nJsonResponseHandler\n (see\n  more below).\n\n\n\n\n\n\n\n\nThis factory creates and configures a \nWhoops\\Run\n instance so that it will work\nproperly with \nZend\\Expressive\\Application\n; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The \nPrettyPageHandler\n returned\nfor the \nZend\\Expressive\\WhoopsPageHandler\n service will be injected.\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' => [\n    'json_exceptions' => [\n        'display'    => true,\n        'show_trace' => true,\n        'ajax_only'  => true,\n    ],\n],\n\n\n\nIf no \nwhoops\n top-level key is present in the configuration, a default instance\nwith no \nJsonResponseHandler\n composed will be created.\n\n\nWhoopsPageHandlerFactory\n\n\n\n\nProvides\n: \nWhoops\\Handler\\PrettyPageHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\WhoopsPageHandler\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPrettyPageHandler\n instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' => [\n    'editor' => 'editor name, editor service name, or callable',\n],\n\n\n\nThe \neditor\n value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.\n\n\nPlatesRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\PlatesRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Plates\\PlatesRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPlates\n instance, specifically with the filename extension\n  to use, and paths to inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' => [\n    'extension' => 'file extension used by templates; defaults to html',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nOne note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.\n\n\nTwigRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\TwigRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Twig\\TwigRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n; if found, it will be used to\n  seed a \nZend\\Expressive\\Twig\\TwigExtension\n instance for purposes\n  of rendering application URLs.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nTwig\n instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'debug' => boolean,\n'templates' => [\n    'cache_dir' => 'path to cached templates',\n    'assets_url' => 'base URL for assets',\n    'assets_version' => 'base version for assets',\n    'extension' => 'file extension used by templates; defaults to html.twig',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nWhen \ndebug\n is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The \nassets_*\n values are used to seed\nthe \nTwigExtension\n instance (assuming the router was found).\n\n\nZendViewRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\ZendViewRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\ZendView\\ZendViewRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nZend\\Expressive\\Router\\RouterInterface\n, in order to inject the custom\n  url helper implementation.\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nZendView\n instance, specifically with the layout template\n  name, entries for a \nTemplateMapResolver\n, and and template paths to\n  inject.\n\n\nZend\\View\\HelperPluginManager\n; if present, will be used to inject the\n  \nPhpRenderer\n instance.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' => [\n    'layout' => 'name of layout view to use, if any',\n    'map'    => [\n        // template => filename pairs\n    ],\n    'paths'  => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nWhen creating the \nPhpRenderer\n instance, it will inject it with a\n\nZend\\View\\HelperPluginManager\n instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers, \nZend\\Expressive\\ZendView\\UrlHelper\n and\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n, respetively.",
            "title": "Container Factories"
        },
        {
            "location": "/features/container/factories/#provided-factories",
            "text": "Expressive provides several factories compatible with PSR-11 Container  to facilitate \nsetting up common dependencies. The following is a list of provided\ncontainers, what they will create, the suggested service name, and any\nadditional dependencies they may require.  All factories, unless noted otherwise, are in the  Zend\\Expressive\\Container \nnamespace, and define an  __invoke()  method that accepts an Psr\\Container\\ContainerInterface  instance as the sole argument.",
            "title": "Provided Factories"
        },
        {
            "location": "/features/container/factories/#applicationfactory",
            "text": "Provides :  Zend\\Expressive\\Application  Suggested Name :  Zend\\Expressive\\Application  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface . When provided, the service will\n  be used to construct the  Application  instance; otherwise, an FastRoute router\n  implementation will be used.  Zend\\Expressive\\Delegate\\DefaultDelegate . This should return an\n   Interop\\Http\\ServerMiddleware\\DelegateInterface  instance to process\n  when the middleware pipeline is exhausted without returning a response;\n  by default, this will be a  Zend\\Expressive\\Delegate\\NotFoundDelegate \n  instance.  Zend\\Diactoros\\Response\\EmitterInterface . If none is provided, an instance\n  of  Zend\\Expressive\\Emitter\\EmitterStack  composing a\n   Zend\\Diactoros\\Response\\SapiEmitter  instance will be used.  config , an array or  ArrayAccess  instance. This  may  be used to seed the\n  application instance with pipeline middleware and/or routed\n  middleware (see more below).     Additionally, the container instance itself is injected into the  Application \ninstance.  When the  config  service is present, the factory can utilize several keys in\norder to seed the  Application  instance:    programmatic_pipeline  (bool) (Since 1.1.0): when enabled,\n   middleware_pipeline  and  routes  configuration are ignored, and the factory\n  will assume that these are injected programmatically elsewhere.    raise_throwables  (bool) (Since 1.1.0; obsolete as of 2.0.0): when enabled, \n  this flag will prevent the Stratigility middleware dispatcher from catching\n  exceptions, and instead allow them to bubble outwards.    middleware_pipeline  can be used to seed the middleware pipeline:    'middleware_pipeline' => [\n    // An array of middleware to register.\n    [ /* ... */ ],\n\n    // Expressive 1.0:\n    Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n\n    // Expressive 1.1 and above (above constants will still work, though):\n    Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n\n    [ /* ... */ ],\n],  Each item of the array, other than the entries for routing and dispatch\n  middleware, must be an array itself, with the following structure:  [\n    // required:\n    'middleware' => 'Name of middleware service, valid middleware, or an array of these',\n    // optional:\n    'path'  => '/path/to/match',\n    'priority' => 1, // Integer\n\n    // optional under Expressive 1.X; ignored under 2.X:\n    'error' => false, // boolean\n],  The  middleware  key itself is the middleware to execute, and must be a\n  service name resolving to valid middleware, middleware instances (either\n  http-interop middleware or callable double-pass middleware), or an array of\n  these values. If an array is provided, the specified middleware will be\n  composed into a  Zend\\Stratigility\\MiddlewarePipe  instance.   If the  path  key is present, that key will be used to segregate the\n  middleware to a specific matched path (in other words, it will not execute if\n  the path is not matched).  The  priority  defaults to 1, and follows the semantics of\n   SplPriorityQueue : higher integer values\n  indicate higher priority (will execute earlier), while lower/negative integer\n  values indicate lower priority (will execute last). Default priority is 1; use\n  granular priority values to specify the order in which middleware should be\n  piped to the application.  You  can  specify keys for each middleware specification. These will be\n  ignored by the factory, but can be useful when merging several configurations\n  into one for the application.  Under Expressive 1.X, if the  error  key is present and boolean  true , then\n  the middleware will be registered as error middleware. (This is necessary due\n  to the fact that the factory defines a callable wrapper around middleware to\n  enable lazy-loading of middleware.) We recommend  not  using this feature;\n  see the chapter on  error handling  for details.   routes  is used to define routed middleware. The value must be an array,\n  consisting of arrays defining each middleware:   'routes' => [\n    [\n        'path' => '/path/to/match',\n        'middleware' => 'Middleware service name, valid middleware, or array of these values',\n        'allowed_methods' => ['GET', 'POST', 'PATCH'],\n        'options' => [\n            'stuff' => 'to',\n            'pass'  => 'to',\n            'the'   => 'underlying router',\n        ],\n    ],\n    // etc.\n],  Each route  requires :  - `path`: the path to match. Format will be based on the router you choose for\n  your project.\n\n- `middleware`: a service name resolving to valid middleware, valid\n  middleware (either http-interop middleware or callable double-pass\n  middleware), or an array of such values (which will be composed into\n  a `Zend\\Stratigility\\MiddlewarePipe` instance); this middleware will be\n  dispatched when the route matches.  Optionally, the route definition may provide:  - `allowed_methods`: an array of allowed HTTP methods. If not provided, the\n  application assumes any method is allowed.\n\n- `name`: if not provided, the path will be used as the route name (and, if\n  specific HTTP methods are allowed, a list of those).\n\n- `options`: a key/value set of additional options to pass to the underlying\n  router implementation for the given route. (Typical use cases include\n  passing constraints or default values.)",
            "title": "ApplicationFactory"
        },
        {
            "location": "/features/container/factories/#errorhandlerfactory",
            "text": "Since version 2.0   Provides :  Zend\\Stratigility\\Middleware\\ErrorHandler  Suggested Name :  Zend\\Stratigility\\Middleware\\ErrorHandler  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator . If not provided, the error\n  handler will not compose an error response generator, making it largely\n  useless other than to provide an empty response.",
            "title": "ErrorHandlerFactory"
        },
        {
            "location": "/features/container/factories/#errorresponsegeneratorfactory",
            "text": "Since version 2.0   Provides :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  Suggested Name :  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the\n  error response generator will provide a plain text response instead of a\n  templated one.  config , an array or  ArrayAccess  instance. This will be used to seed the\n   ErrorResponseGenerator  instance with a template name to use for errors (see\n  more below), and/or a \"debug\" flag value.     When the  config  service is present, the factory can utilize two values:   debug , a flag indicating whether or not to provide debug information when\n  creating an error response.  zend-expressive.error_handler.template_error , a name of an alternate\n  template to use (instead of the default represented in the\n   Zend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT \n  constant).   As an example:  'debug' => true,\n'zend-expressive' => [\n    'error_handler' => [\n        'template_error' => 'name of error template',\n    ],\n],",
            "title": "ErrorResponseGeneratorFactory"
        },
        {
            "location": "/features/container/factories/#notfounddelegatefactory",
            "text": "Since version 2.0   Provides :  Zend\\Expressive\\Delegate\\NotFoundDelegate  Suggested Name :  Zend\\Expressive\\Delegate\\NotFoundDelegate , and aliased\n  to  Zend\\Expressive\\Delegate\\DefaultDelegate .  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the\n  delegate will provide a plain text response instead of a templated one.  config , an array or  ArrayAccess  instance. This will be used to seed the\n   NotFoundDelegate  instance with a template name to use.     When the  config  service is present, the factory can utilize two values:   zend-expressive.error_handler.template_404 , a name of an alternate\n  template to use (instead of the default represented in the\n   Zend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT  constant).   As an example:  'zend-expressive' => [\n    'error_handler' => [\n        'template_404' => 'name of 404 template',\n    ],\n],",
            "title": "NotFoundDelegateFactory"
        },
        {
            "location": "/features/container/factories/#notfoundhandlerfactory",
            "text": "Since version 2.0   Provides :  Zend\\Expressive\\Middleware\\NotFoundHandler  Suggested Name :  Zend\\Expressive\\Middleware\\NotFoundHandler  Requires :  Zend\\Expressive\\Delegate\\DefaultDelegate",
            "title": "NotFoundHandlerFactory"
        },
        {
            "location": "/features/container/factories/#templatederrorhandlerfactory",
            "text": "Removed in version 2.0   Provides :  Zend\\Expressive\\TemplatedErrorHandler  Suggested Name :  Zend\\Expressive\\FinalHandler  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error\n  handler will not use templated responses.  config , an array or  ArrayAccess  instance. This will be used to seed the\n   TemplatedErrorHandler  instance with template names to use for errors (see\n  more below).     When the  config  service is present, the factory can utilize the zend-expressive  top-level key, with the  error_handler  second-level key, to\nseed the  Templated  instance:  'zend-expressive' => [\n    'error_handler' => [\n        'template_404'   => 'name of 404 template',\n        'template_error' => 'name of error template',\n    ],\n],",
            "title": "TemplatedErrorHandlerFactory"
        },
        {
            "location": "/features/container/factories/#whoopserrorhandlerfactory",
            "text": "Removed in version 2.0.   Provides :  Zend\\Expressive\\TemplatedErrorHandler  Suggested Name :  Zend\\Expressive\\FinalHandler  Requires :  Zend\\Expressive\\Whoops , which should provide a  Whoops\\Run  instance.  Zend\\Expressive\\WhoopsPageHandler , which should provide a\n   Whoops\\Handler\\PrettyPageHandler  instance.    Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error\n  handler will not use templated responses.  config , an array or  ArrayAccess  instance. This will be used to seed the\n  instance with template names to use for errors (see more below).     This factory uses  config  in the same way as the TemplatedErrorHandlerFactory .",
            "title": "WhoopsErrorHandlerFactory"
        },
        {
            "location": "/features/container/factories/#whoopserrorresponsegeneratorfactory",
            "text": "Since version 2.0   Provides :  Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator  Suggested Name :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  Requires :  Zend\\Expressive\\Whoops  (see  WhoopsFactory ,\nbelow)",
            "title": "WhoopsErrorResponseGeneratorFactory"
        },
        {
            "location": "/features/container/factories/#whoopsfactory",
            "text": "Provides :  Whoops\\Run  Suggested Name :  Zend\\Expressive\\Whoops  Requires :  Zend\\Expressive\\WhoopsPageHandler    Optional :  config , an array or  ArrayAccess  instance. This will be used to seed\n  additional page handlers, specifically the  JsonResponseHandler  (see\n  more below).     This factory creates and configures a  Whoops\\Run  instance so that it will work\nproperly with  Zend\\Expressive\\Application ; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The  PrettyPageHandler  returned\nfor the  Zend\\Expressive\\WhoopsPageHandler  service will be injected.  It consumes the following  config  structure:  'whoops' => [\n    'json_exceptions' => [\n        'display'    => true,\n        'show_trace' => true,\n        'ajax_only'  => true,\n    ],\n],  If no  whoops  top-level key is present in the configuration, a default instance\nwith no  JsonResponseHandler  composed will be created.",
            "title": "WhoopsFactory"
        },
        {
            "location": "/features/container/factories/#whoopspagehandlerfactory",
            "text": "Provides :  Whoops\\Handler\\PrettyPageHandler  Suggested Name :  Zend\\Expressive\\WhoopsPageHandler  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  PrettyPageHandler  instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).     It consumes the following  config  structure:  'whoops' => [\n    'editor' => 'editor name, editor service name, or callable',\n],  The  editor  value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.",
            "title": "WhoopsPageHandlerFactory"
        },
        {
            "location": "/features/container/factories/#platesrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\PlatesRenderer  FactoryName :  Zend\\Expressive\\Plates\\PlatesRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Plates  instance, specifically with the filename extension\n  to use, and paths to inject.     It consumes the following  config  structure:  'templates' => [\n    'extension' => 'file extension used by templates; defaults to html',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  One note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.",
            "title": "PlatesRendererFactory"
        },
        {
            "location": "/features/container/factories/#twigrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\TwigRenderer  FactoryName :  Zend\\Expressive\\Twig\\TwigRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to\n  seed a  Zend\\Expressive\\Twig\\TwigExtension  instance for purposes\n  of rendering application URLs.  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Twig  instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.     It consumes the following  config  structure:  'debug' => boolean,\n'templates' => [\n    'cache_dir' => 'path to cached templates',\n    'assets_url' => 'base URL for assets',\n    'assets_version' => 'base version for assets',\n    'extension' => 'file extension used by templates; defaults to html.twig',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When  debug  is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The  assets_*  values are used to seed\nthe  TwigExtension  instance (assuming the router was found).",
            "title": "TwigRendererFactory"
        },
        {
            "location": "/features/container/factories/#zendviewrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\ZendViewRenderer  FactoryName :  Zend\\Expressive\\ZendView\\ZendViewRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Zend\\Expressive\\Router\\RouterInterface , in order to inject the custom\n  url helper implementation.    Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  ZendView  instance, specifically with the layout template\n  name, entries for a  TemplateMapResolver , and and template paths to\n  inject.  Zend\\View\\HelperPluginManager ; if present, will be used to inject the\n   PhpRenderer  instance.     It consumes the following  config  structure:  'templates' => [\n    'layout' => 'name of layout view to use, if any',\n    'map'    => [\n        // template => filename pairs\n    ],\n    'paths'  => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When creating the  PhpRenderer  instance, it will inject it with a Zend\\View\\HelperPluginManager  instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers,  Zend\\Expressive\\ZendView\\UrlHelper  and Zend\\Expressive\\ZendView\\ServerUrlHelper , respetively.",
            "title": "ZendViewRendererFactory"
        },
        {
            "location": "/features/container/delegator-factories/",
            "text": "Delegator Factories\n\n\n\n\nSince 2.0.\n\n\n\n\nStarting with the 2.0 version of the Expressive skeleton, we now support the\nconcept of \ndelegator factories\n, which allow decoration of services created by\nyour dependency injection container, across all dependency injection containers\nsupported by Expressive.\n\n\nDelegator factories\n accept the following arguments:\n\n\n\n\nThe container itself;\n\n\nThe name of the service whose creation is being decorated;\n\n\nA callback that will produce the service being decorated.\n\n\n\n\nAs an example, let's say we have a \nUserRepository\n class that composes some sort of\nevent manager. We might want to attach listeners to that event manager, but not\nwish to alter the basic creation logic for the repository itself. As such, we\nmight write a \ndelegator factory\n as follows:\n\n\nnamespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass UserRepositoryListenerDelegatorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $name\n     * @param callable $callback\n     * @return UserRepository\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback)\n    {\n        $listener = new LoggerListener($container->get(LoggerInterface::class));\n        $repository = $callback();\n        $repository->getEventManager()->attach($listener);\n        return $repository;\n    }\n}\n\n\n\nTo notify the container about this delegator factory, we would add the following\nconfiguration to our application:\n\n\n'dependencies' => [\n    'delegators' => [\n        Acme\\UserRepository::class => [\n            Acme\\UserRepositoryListenerDelegatorFactory::class,\n        ],\n    ],\n],\n\n\n\nNote that you specify delegator factories using the service name being decorated\nas the key, with an \narray\n of delegator factories as a value. \nYou may attach\nmultiple delegator factories to any given service\n, which can be a very\npowerful feature.\n\n\nAt the time of writing, this feature works for each of the Aura.Di, Pimple, and\nzend-servicemanager container implementations. Delegator factories have been\nsupported with Pimple and zend-servicemanager since the 1.X series.",
            "title": "Delegator Factories"
        },
        {
            "location": "/features/container/delegator-factories/#delegator-factories",
            "text": "Since 2.0.   Starting with the 2.0 version of the Expressive skeleton, we now support the\nconcept of  delegator factories , which allow decoration of services created by\nyour dependency injection container, across all dependency injection containers\nsupported by Expressive.  Delegator factories  accept the following arguments:   The container itself;  The name of the service whose creation is being decorated;  A callback that will produce the service being decorated.   As an example, let's say we have a  UserRepository  class that composes some sort of\nevent manager. We might want to attach listeners to that event manager, but not\nwish to alter the basic creation logic for the repository itself. As such, we\nmight write a  delegator factory  as follows:  namespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass UserRepositoryListenerDelegatorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $name\n     * @param callable $callback\n     * @return UserRepository\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback)\n    {\n        $listener = new LoggerListener($container->get(LoggerInterface::class));\n        $repository = $callback();\n        $repository->getEventManager()->attach($listener);\n        return $repository;\n    }\n}  To notify the container about this delegator factory, we would add the following\nconfiguration to our application:  'dependencies' => [\n    'delegators' => [\n        Acme\\UserRepository::class => [\n            Acme\\UserRepositoryListenerDelegatorFactory::class,\n        ],\n    ],\n],  Note that you specify delegator factories using the service name being decorated\nas the key, with an  array  of delegator factories as a value.  You may attach\nmultiple delegator factories to any given service , which can be a very\npowerful feature.  At the time of writing, this feature works for each of the Aura.Di, Pimple, and\nzend-servicemanager container implementations. Delegator factories have been\nsupported with Pimple and zend-servicemanager since the 1.X series.",
            "title": "Delegator Factories"
        },
        {
            "location": "/features/container/zend-servicemanager/",
            "text": "Using zend-servicemanager\n\n\nzend-servicemanager\n is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:\n\n\n\n\nlazy-loading of invokable (constructor-less) classes.\n\n\nability to define factories for specific classes.\n\n\nability to define generalized factories for classes with identical\n  construction patterns (aka \nabstract factories\n).\n\n\nability to create lazy-loading proxies.\n\n\nability to intercept before or after instantiation to alter the construction\n  workflow (aka \ndelegator factories\n).\n\n\ninterface injection (via \ninitializers\n).\n\n\n\n\nzend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:\n\n\n[\n    'services' => [\n        'service name' => $serviceInstance,\n    ],\n    'invokables' => [\n        'service name' => 'class to instantiate',\n    ],\n    'factories' => [\n        'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' => [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' => [\n        'service name' => [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' => [\n        'class_map' => [\n            'service name' => 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' => [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]\n\n\n\nRead more about zend-servicemanager in \nits documentation\n.\n\n\nInstalling zend-servicemanager\n\n\nTo use zend-servicemanager with zend-expressive, you can install it via\ncomposer:\n\n\n$ composer require zendframework/zend-servicemanager\n\n\n\nConfiguring zend-servicemanager\n\n\nYou can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.\n\n\nProgrammatically\n\n\nTo use zend-servicemanager programatically, you'll need to create a\n\nZend\\ServiceManager\\ServiceManager\n instance, and then start populating it.\n\n\nFor this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in \nconfig/config.php\n, and that that file\nreturns an array.\n\n\nWe'll create a \nconfig/container.php\n file that creates and returns a\n\nZend\\ServiceManager\\ServiceManager\n instance as follows:\n\n\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container->setService('config', include 'config/config.php');\n$container->setFactory(\n    Zend\\Expressive\\Application::class,\n    Zend\\Expressive\\Container\\ApplicationFactory::class\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Template\\TemplateRendererInterface::class,\n    Zend\\Expressive\\Plates\\PlatesRenderer::class\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation\n// (Expressive 1.X) or the WhoopsErrorResponseGenerator as the\n// ErrorResponseGenerator implementation (Expressive 2.X):\n$container->setFactory(\n    'Zend\\Expressive\\Whoops',\n    Zend\\Expressive\\Container\\WhoopsFactory::class\n);\n$container->setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class\n);\n\n// Error Handling\n\n// - Expressive 2.X, all environments:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorHandler::class,\n    Zend\\Expressive\\Container\\ErrorHandlerFactory::class\n);\n\n// If in development:\n// - Expressive 1.X:\n$container->setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory::class\n);\n// - Expressive 2.X:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n);\n\n// If in production:\n// - Expressive 1.X:\n$container->setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory::class\n);\n// - Expressive 2.X:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n);\n\nreturn $container;\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(\\Zend\\Expressive\\Application::class);\n\n// Expressive 2.X:\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();\n\n\n\nConfiguration-Driven Container\n\n\nAlternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in \nconfig/config.php\n, and our\n\nconfig/container.php\n file will still return our service manager instance; we'll\ndefine the service configuration in \nconfig/dependencies.php\n:\n\n\nreturn [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        // Expressive 2.0:\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => 'Zend\\Expressive\\Delegate\\NotFoundDelegate',\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        // Expressive 2.0:\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        Zend\\Expressive\\Delegate\\NotFoundDelegate::class  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];\n\n\n\nconfig/container.php\n becomes:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));\n\n\n\nThere is one problem, however: in both Expressive 1.X and 2.X, you may want to\nvary error handling strategies based on whether or not you're in production:\nYou have two choices on how to approach this:\n\n\n\n\nSelectively inject the factory in the bootstrap.\n\n\nDefine the final handler service in an environment specific file and use file\n  globbing to merge files.\n\n\n\n\nIn the first case, you would change the \nconfig/container.php\n example to look\nlike this:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/container.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        // Expressive 1.X:\n        $container->setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory::class\n        );\n\n        // Expressive 2.X:\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n        );\n        break;\n    case 'production':\n    default:\n        // Expressive 1.X:\n        $container->setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory::class\n        );\n\n        // Expressive 2.X:\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n        );\n}\nreturn $container;\n\n\n\nIn the second case, you will need to install zend-config:\n\n\n$ composer require zendframework/zend-config\n\n\n\nThen, create the directory \nconfig/autoload/\n, and create two files,\n\ndependencies.global.php\n and \ndependencies.local.php\n. In your \n.gitignore\n,\nadd an entry for \nconfig/autoload/*local.php\n to ensure \"local\"\n(environment-specific) files are excluded from the repository.\n\n\nconfig/dependencies.php\n will look like this:\n\n\nuse Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);\n\n\n\nconfig/autoload/dependencies.global.php\n will look like this:\n\n\nreturn [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        // Expressive 2.0:\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => Zend\\Expressive\\Delegate\\NotFoundDelegate::class,\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        // Expressive 1.X:\n        'Zend\\Expressive\\FinalHandler'      => Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory::class,\n\n        // Expressive 2.X:\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class,\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        'Zend\\Expressive\\Delegate\\NotFoundDelegate'  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];\n\n\n\nconfig/autoload/dependencies.local.php\n on your development machine can look\nlike this:\n\n\nreturn [\n    'factories' => [\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        // Expressive 1.X:\n        'Zend\\Expressive\\FinalHandler'      => Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory::class,\n\n        // Expressive 2.X:\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => 'Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class,\n    ],\n];\n\n\n\nUsing the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)",
            "title": "Using zend-servicemanager"
        },
        {
            "location": "/features/container/zend-servicemanager/#using-zend-servicemanager",
            "text": "zend-servicemanager  is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:   lazy-loading of invokable (constructor-less) classes.  ability to define factories for specific classes.  ability to define generalized factories for classes with identical\n  construction patterns (aka  abstract factories ).  ability to create lazy-loading proxies.  ability to intercept before or after instantiation to alter the construction\n  workflow (aka  delegator factories ).  interface injection (via  initializers ).   zend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:  [\n    'services' => [\n        'service name' => $serviceInstance,\n    ],\n    'invokables' => [\n        'service name' => 'class to instantiate',\n    ],\n    'factories' => [\n        'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' => [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' => [\n        'service name' => [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' => [\n        'class_map' => [\n            'service name' => 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' => [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]  Read more about zend-servicemanager in  its documentation .",
            "title": "Using zend-servicemanager"
        },
        {
            "location": "/features/container/zend-servicemanager/#installing-zend-servicemanager",
            "text": "To use zend-servicemanager with zend-expressive, you can install it via\ncomposer:  $ composer require zendframework/zend-servicemanager",
            "title": "Installing zend-servicemanager"
        },
        {
            "location": "/features/container/zend-servicemanager/#configuring-zend-servicemanager",
            "text": "You can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.",
            "title": "Configuring zend-servicemanager"
        },
        {
            "location": "/features/container/zend-servicemanager/#programmatically",
            "text": "To use zend-servicemanager programatically, you'll need to create a Zend\\ServiceManager\\ServiceManager  instance, and then start populating it.  For this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in  config/config.php , and that that file\nreturns an array.  We'll create a  config/container.php  file that creates and returns a Zend\\ServiceManager\\ServiceManager  instance as follows:  use Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container->setService('config', include 'config/config.php');\n$container->setFactory(\n    Zend\\Expressive\\Application::class,\n    Zend\\Expressive\\Container\\ApplicationFactory::class\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Template\\TemplateRendererInterface::class,\n    Zend\\Expressive\\Plates\\PlatesRenderer::class\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation\n// (Expressive 1.X) or the WhoopsErrorResponseGenerator as the\n// ErrorResponseGenerator implementation (Expressive 2.X):\n$container->setFactory(\n    'Zend\\Expressive\\Whoops',\n    Zend\\Expressive\\Container\\WhoopsFactory::class\n);\n$container->setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class\n);\n\n// Error Handling\n\n// - Expressive 2.X, all environments:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorHandler::class,\n    Zend\\Expressive\\Container\\ErrorHandlerFactory::class\n);\n\n// If in development:\n// - Expressive 1.X:\n$container->setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory::class\n);\n// - Expressive 2.X:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n);\n\n// If in production:\n// - Expressive 1.X:\n$container->setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory::class\n);\n// - Expressive 2.X:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n);\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(\\Zend\\Expressive\\Application::class);\n\n// Expressive 2.X:\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();",
            "title": "Programmatically"
        },
        {
            "location": "/features/container/zend-servicemanager/#configuration-driven-container",
            "text": "Alternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in  config/config.php , and our config/container.php  file will still return our service manager instance; we'll\ndefine the service configuration in  config/dependencies.php :  return [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        // Expressive 2.0:\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => 'Zend\\Expressive\\Delegate\\NotFoundDelegate',\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        // Expressive 2.0:\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        Zend\\Expressive\\Delegate\\NotFoundDelegate::class  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];  config/container.php  becomes:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));  There is one problem, however: in both Expressive 1.X and 2.X, you may want to\nvary error handling strategies based on whether or not you're in production:\nYou have two choices on how to approach this:   Selectively inject the factory in the bootstrap.  Define the final handler service in an environment specific file and use file\n  globbing to merge files.   In the first case, you would change the  config/container.php  example to look\nlike this:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/container.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        // Expressive 1.X:\n        $container->setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory::class\n        );\n\n        // Expressive 2.X:\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n        );\n        break;\n    case 'production':\n    default:\n        // Expressive 1.X:\n        $container->setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory::class\n        );\n\n        // Expressive 2.X:\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n        );\n}\nreturn $container;  In the second case, you will need to install zend-config:  $ composer require zendframework/zend-config  Then, create the directory  config/autoload/ , and create two files, dependencies.global.php  and  dependencies.local.php . In your  .gitignore ,\nadd an entry for  config/autoload/*local.php  to ensure \"local\"\n(environment-specific) files are excluded from the repository.  config/dependencies.php  will look like this:  use Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);  config/autoload/dependencies.global.php  will look like this:  return [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        // Expressive 2.0:\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => Zend\\Expressive\\Delegate\\NotFoundDelegate::class,\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        // Expressive 1.X:\n        'Zend\\Expressive\\FinalHandler'      => Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory::class,\n\n        // Expressive 2.X:\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class,\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        'Zend\\Expressive\\Delegate\\NotFoundDelegate'  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];  config/autoload/dependencies.local.php  on your development machine can look\nlike this:  return [\n    'factories' => [\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        // Expressive 1.X:\n        'Zend\\Expressive\\FinalHandler'      => Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory::class,\n\n        // Expressive 2.X:\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => 'Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class,\n    ],\n];  Using the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)",
            "title": "Configuration-Driven Container"
        },
        {
            "location": "/features/container/pimple/",
            "text": "Using Pimple\n\n\nPimple\n is a widely used code-driven dependency\ninjection container provided as a standalone component by SensioLabs. It\nfeatures:\n\n\n\n\ncombined parameter and service storage.\n\n\nability to define factories for specific classes.\n\n\nlazy-loading via factories.\n\n\n\n\nPimple only supports programmatic creation at this time.\n\n\nInstalling Pimple\n\n\nPimple does not currently (as of v3) implement\n\nPSR-11 Container\n; as\nsuch, you need to install the \nxtreamwayz/pimple-container-interop\n project,\nwhich provides a \nPSR-11 Container\n\nwrapper around Pimple v3:\n\n\n$ composer require xtreamwayz/pimple-container-interop\n\n\n\nConfiguring Pimple\n\n\nTo configure Pimple, instantiate it, and then add the factories desired. We\nrecommend doing this in a dedicated script that returns the Pimple instance; in\nthis example, we'll have that in \nconfig/container.php\n.\n\n\nuse Xtreamwayz\\Pimple\\Container as Pimple;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\n$container = new Pimple();\n\n// Application and configuration\n$container['config'] = include 'config/config.php';\n$container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory;\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) {\n    return new Router\\Aura();\n};\n\n// Expressive 2.X: We'll provide a default delegate:\n$delegateFactory = new Container\\NotFoundDelegateFactory();\n$container['Zend\\Expressive\\Delegate\\DefaultDelegate'] = $delegateFactory;\n$container[Zend\\Expressive\\Delegate\\NotFoundDelegate::class] = $delegateFactory;\n\n// Expressive 2.X: We'll provide a not found handler:\n$container[Zend\\Expressive\\Middleware\\NotFoundHandler::class] = new Container\\NotFoundHandlerFactory();\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container[TemplateRendererInterface::class] = function ($container) {\n    return new PlatesRenderer();\n};\n\n// These next two can be added in any environment; they won't be used unless:\n// - (Expressive 1.X): you add the WhoopsErrorHandler as the FinalHandler\n//   implementation:\n// - (Expressive 2.X): you add the WhoopsErrorResponseGenerator as the\n//   ErrorResponseGenerator implementation\n$container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory();\n$container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory();\n\n// Error Handling\n\n// - In Expressive 2.X, all environments:\n$container['Zend\\Expressive\\Middleware\\ErrorHandler'] = new Container\\ErrorHandlerFactory();\n\n// If in development:\n// - Expressive 1.X:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\WhoopsErrorHandlerFactory();\n// - Expressive 2.X:\n$container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\WhoopsErrorResponseGeneratorFactory();\n\n// If in production:\n// - Expressive 1.X:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\TemplatedErrorHandlerFactory();\n// - Expressive 2.X:\n$container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\ErrorResponseGeneratorFactory();\n\nreturn $container;\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\n\n// In Expressive 2.X:\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();\n\n\n\n\n\nEnvironments\n\n\nIn the example above, we provide two alternate definitions for\neither the service \nZend\\Expressive\\FinalHandler\n (Expressive 1.X) or the\nservice \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n (Expressive 2.X),\none for development and one for production. You will need to add logic to\nyour file to determine which definition to provide; this could be accomplished\nvia an environment variable.",
            "title": "Using Pimple"
        },
        {
            "location": "/features/container/pimple/#using-pimple",
            "text": "Pimple  is a widely used code-driven dependency\ninjection container provided as a standalone component by SensioLabs. It\nfeatures:   combined parameter and service storage.  ability to define factories for specific classes.  lazy-loading via factories.   Pimple only supports programmatic creation at this time.",
            "title": "Using Pimple"
        },
        {
            "location": "/features/container/pimple/#installing-pimple",
            "text": "Pimple does not currently (as of v3) implement PSR-11 Container ; as\nsuch, you need to install the  xtreamwayz/pimple-container-interop  project,\nwhich provides a  PSR-11 Container \nwrapper around Pimple v3:  $ composer require xtreamwayz/pimple-container-interop",
            "title": "Installing Pimple"
        },
        {
            "location": "/features/container/pimple/#configuring-pimple",
            "text": "To configure Pimple, instantiate it, and then add the factories desired. We\nrecommend doing this in a dedicated script that returns the Pimple instance; in\nthis example, we'll have that in  config/container.php .  use Xtreamwayz\\Pimple\\Container as Pimple;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\n$container = new Pimple();\n\n// Application and configuration\n$container['config'] = include 'config/config.php';\n$container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory;\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) {\n    return new Router\\Aura();\n};\n\n// Expressive 2.X: We'll provide a default delegate:\n$delegateFactory = new Container\\NotFoundDelegateFactory();\n$container['Zend\\Expressive\\Delegate\\DefaultDelegate'] = $delegateFactory;\n$container[Zend\\Expressive\\Delegate\\NotFoundDelegate::class] = $delegateFactory;\n\n// Expressive 2.X: We'll provide a not found handler:\n$container[Zend\\Expressive\\Middleware\\NotFoundHandler::class] = new Container\\NotFoundHandlerFactory();\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container[TemplateRendererInterface::class] = function ($container) {\n    return new PlatesRenderer();\n};\n\n// These next two can be added in any environment; they won't be used unless:\n// - (Expressive 1.X): you add the WhoopsErrorHandler as the FinalHandler\n//   implementation:\n// - (Expressive 2.X): you add the WhoopsErrorResponseGenerator as the\n//   ErrorResponseGenerator implementation\n$container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory();\n$container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory();\n\n// Error Handling\n\n// - In Expressive 2.X, all environments:\n$container['Zend\\Expressive\\Middleware\\ErrorHandler'] = new Container\\ErrorHandlerFactory();\n\n// If in development:\n// - Expressive 1.X:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\WhoopsErrorHandlerFactory();\n// - Expressive 2.X:\n$container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\WhoopsErrorResponseGeneratorFactory();\n\n// If in production:\n// - Expressive 1.X:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\TemplatedErrorHandlerFactory();\n// - Expressive 2.X:\n$container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\ErrorResponseGeneratorFactory();\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\n\n// In Expressive 2.X:\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();",
            "title": "Configuring Pimple"
        },
        {
            "location": "/features/container/pimple/#environments",
            "text": "In the example above, we provide two alternate definitions for\neither the service  Zend\\Expressive\\FinalHandler  (Expressive 1.X) or the\nservice  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  (Expressive 2.X),\none for development and one for production. You will need to add logic to\nyour file to determine which definition to provide; this could be accomplished\nvia an environment variable.",
            "title": "Environments"
        },
        {
            "location": "/features/container/aura-di/",
            "text": "Using Aura.Di\n\n\nAura.Di\n provides a serializable dependency\ninjection container with the following features:\n\n\n\n\nconstructor and setter injection.\n\n\ninheritance of constructor parameter and setter method values from parent\n  classes.\n\n\ninheritance of setter method values from interfaces and traits.\n\n\nlazy-loaded instances, services, includes/requires, and values.\n\n\ninstance factories.\n\n\noptional auto-resolution of typehinted constructor parameter values.\n\n\n\n\nInstalling Aura.Di\n\n\nAura.Di implements \ncontainer-interop\n\nas of version 3.\n\n\n$ composer require aura/di\n\n\n\nConfiguration\n\n\nAura.Di can help you to organize your code better with\n\nContainerConfig classes\n and\n\ntwo step configuration\n.\nIn this example, we'll put that in \nconfig/container.php\n:\n\n\n<?php\nuse Aura\\Di\\ContainerBuilder;\n\n$containerBuilder = new ContainerBuilder();\n\n// Use the builder to create and configure a container using an array of\n// ContainerConfig classes. Make sure the classes can be autoloaded!\nreturn $containerBuilder->newConfiguredInstance([\n    'Application\\Config\\Common',\n]);\n\n\n\nThe bare minimum \nContainerConfig\n code needed to make zend-expressive work is:\n\n\n<?php\n// In src/Config/Common.php:\nnamespace Application\\Config;\n\nuse Aura\\Di\\Container;\nuse Aura\\Di\\ContainerConfig;\nuse Aura\\Router\\Generator;\nuse Aura\\Router\\RouteCollection;\nuse Aura\\Router\\RouteFactory;\nuse Aura\\Router\\Router;\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container as ExpressiveContainer;\nuse Zend\\Expressive\\Delegate;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router\\AuraRouter;\nuse Zend\\Expressive\\Router\\Route;\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass Common extends ContainerConfig\n{\n    public function define(Container $di)\n    {\n        $di->params[RouteCollection::class] = array(\n            'route_factory' => $di->lazyNew(RouteFactory::class),\n        );\n        $di->params[Router::class] = array(\n            'routes' => $di->lazyNew(RouteCollection::class),\n            'generator' => $di->lazyNew(Generator::class),\n        );\n        $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class);\n        $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class));\n        $di->set(Container\\NotFoundDelegateFactory::class, $di->lazyNew(ExpressiveContainer\\NotFoundDelegateFactory::class));\n        $di->set(Delegate\\NotFoundDelegate::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di));\n        $di->set('Zend\\Expressive\\Delegate\\DefaultDelegate', $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di));\n        $di->set(Container\\ApplicationFactory::class, $di->lazyNew(ExpressiveContainer\\ApplicationFactory::class));\n        $di->set(Application::class, $di->lazyGetCall(ExpressiveContainer\\ApplicationFactory::class, '__invoke', $di));\n\n        // Not Found handler\n        $di->set(Middleware\\NotFoundHandler::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundHandlerFactory::class, '__invoke', $di));\n\n        // Templating\n        // In most cases, you can instantiate the template renderer you want to use\n        // without using a factory:\n        $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class));\n\n        // These next two can be added in any environment; they won't be used unless\n        // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator implementation:\n        $di->set(ExpressiveContainer\\WhoopsFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsFactory::class));\n        $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(ExpressiveContainer\\WhoopsFactory::class, '__invoke', $di));\n        $di->set(ExpressiveContainer\\WhoopsPageHandlerFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsPageHandlerFactory::class));\n        $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(ExpressiveContainer\\WhoopsPageHandlerFactory::class, '__invoke', $di));\n\n        // Error Handling\n        $di->set('Zend\\Stratigility\\Middleware\\ErrorHandler', $di->lazyGetCall(ExpressiveContainer\\ErrorHandlerFactory::class, '__invoke', $di));\n\n        // If in development:\n        $di->set(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class));\n        $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, '__invoke', $di));\n\n        // If in production:\n        // $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(Container\\ErrorResponseGeneratorFactory::class, '__invoke', $di));\n    }\n\n    public function modify(Container $di)\n    {\n        /*\n        $router = $di->get(RouterInterface::class);\n        $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) {\n            $escaper = new Escaper();\n            $name = $request->getAttribute('name', 'World');\n            $response->getBody()->write('Hello ' . $escaper->escapeHtml($name));\n            return $response;\n        }, Route::HTTP_METHOD_ANY, 'hello'));\n        */\n    }\n}\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();",
            "title": "Using Aura.Di"
        },
        {
            "location": "/features/container/aura-di/#using-auradi",
            "text": "Aura.Di  provides a serializable dependency\ninjection container with the following features:   constructor and setter injection.  inheritance of constructor parameter and setter method values from parent\n  classes.  inheritance of setter method values from interfaces and traits.  lazy-loaded instances, services, includes/requires, and values.  instance factories.  optional auto-resolution of typehinted constructor parameter values.",
            "title": "Using Aura.Di"
        },
        {
            "location": "/features/container/aura-di/#installing-auradi",
            "text": "Aura.Di implements  container-interop \nas of version 3.  $ composer require aura/di",
            "title": "Installing Aura.Di"
        },
        {
            "location": "/features/container/aura-di/#configuration",
            "text": "Aura.Di can help you to organize your code better with ContainerConfig classes  and two step configuration .\nIn this example, we'll put that in  config/container.php :  <?php\nuse Aura\\Di\\ContainerBuilder;\n\n$containerBuilder = new ContainerBuilder();\n\n// Use the builder to create and configure a container using an array of\n// ContainerConfig classes. Make sure the classes can be autoloaded!\nreturn $containerBuilder->newConfiguredInstance([\n    'Application\\Config\\Common',\n]);  The bare minimum  ContainerConfig  code needed to make zend-expressive work is:  <?php\n// In src/Config/Common.php:\nnamespace Application\\Config;\n\nuse Aura\\Di\\Container;\nuse Aura\\Di\\ContainerConfig;\nuse Aura\\Router\\Generator;\nuse Aura\\Router\\RouteCollection;\nuse Aura\\Router\\RouteFactory;\nuse Aura\\Router\\Router;\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container as ExpressiveContainer;\nuse Zend\\Expressive\\Delegate;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router\\AuraRouter;\nuse Zend\\Expressive\\Router\\Route;\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass Common extends ContainerConfig\n{\n    public function define(Container $di)\n    {\n        $di->params[RouteCollection::class] = array(\n            'route_factory' => $di->lazyNew(RouteFactory::class),\n        );\n        $di->params[Router::class] = array(\n            'routes' => $di->lazyNew(RouteCollection::class),\n            'generator' => $di->lazyNew(Generator::class),\n        );\n        $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class);\n        $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class));\n        $di->set(Container\\NotFoundDelegateFactory::class, $di->lazyNew(ExpressiveContainer\\NotFoundDelegateFactory::class));\n        $di->set(Delegate\\NotFoundDelegate::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di));\n        $di->set('Zend\\Expressive\\Delegate\\DefaultDelegate', $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di));\n        $di->set(Container\\ApplicationFactory::class, $di->lazyNew(ExpressiveContainer\\ApplicationFactory::class));\n        $di->set(Application::class, $di->lazyGetCall(ExpressiveContainer\\ApplicationFactory::class, '__invoke', $di));\n\n        // Not Found handler\n        $di->set(Middleware\\NotFoundHandler::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundHandlerFactory::class, '__invoke', $di));\n\n        // Templating\n        // In most cases, you can instantiate the template renderer you want to use\n        // without using a factory:\n        $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class));\n\n        // These next two can be added in any environment; they won't be used unless\n        // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator implementation:\n        $di->set(ExpressiveContainer\\WhoopsFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsFactory::class));\n        $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(ExpressiveContainer\\WhoopsFactory::class, '__invoke', $di));\n        $di->set(ExpressiveContainer\\WhoopsPageHandlerFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsPageHandlerFactory::class));\n        $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(ExpressiveContainer\\WhoopsPageHandlerFactory::class, '__invoke', $di));\n\n        // Error Handling\n        $di->set('Zend\\Stratigility\\Middleware\\ErrorHandler', $di->lazyGetCall(ExpressiveContainer\\ErrorHandlerFactory::class, '__invoke', $di));\n\n        // If in development:\n        $di->set(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class));\n        $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, '__invoke', $di));\n\n        // If in production:\n        // $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(Container\\ErrorResponseGeneratorFactory::class, '__invoke', $di));\n    }\n\n    public function modify(Container $di)\n    {\n        /*\n        $router = $di->get(RouterInterface::class);\n        $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) {\n            $escaper = new Escaper();\n            $name = $request->getAttribute('name', 'World');\n            $response->getBody()->write('Hello ' . $escaper->escapeHtml($name));\n            return $response;\n        }, Route::HTTP_METHOD_ANY, 'hello'));\n        */\n    }\n}  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();",
            "title": "Configuration"
        },
        {
            "location": "/features/router/intro/",
            "text": "Routing\n\n\nOne fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:\n\n\n\n\n/books\n might return a collection of books\n\n\n/books/zend-expressive\n might return the individual book identified by\n  \"zend-expressive\".\n\n\n\n\nExpressive does not provide routing on its own; you must choose a routing\nadapter that implements \nZend\\Expressive\\Router\\RouterInterface\n and provide it\nto the \nApplication\n instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.\n\n\nRetrieving matched parameters\n\n\nRouting enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as \nattributes\n.\n\n\nIn the example above, let's assume the route was defined as \n/books/:id\n, where\n\nid\n is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the \nid\n attribute to discover what was\nmatched:\n\n\n$id = $request->getAttribute('id');\n\n\n\nRetrieving the matched route\n\n\nWhen routing is successful, the routing middleware injects a\n\nZend\\Expressive\\Router\\RouteResult\n instance as a request attribute, using that\nclass name as the attribute name. The \nRouteResult\n instance provides you access\nto the following:\n\n\n\n\nThe matched \nZend\\Expressive\\Router\\Route\n instance, via \n$result->getMatchedRoute()\n.\n\n\nThe matched route name, via \n$result->getMatchedRouteName()\n (or via\n  \n$result->getMatchedRoute()->getName()\n).\n\n\nThe matched middleware, via \n$result->getMatchedMiddleware()\n (or via\n  \n$result->getMatchedRoute()->getMiddleware()\n).\n\n\nMatched parameters, via \n$result->getMatchedParams()\n (as noted above, these\n  are also each injected as discrete request attributes).\n\n\nAllowed HTTP methods, via \n$result->getAllowedMethods()\n.\n\n\n\n\nAs an example, you could use middleware similar to the following to return a 403\nresponse if routing was successful, but no \nAuthorization\n header is present:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nfunction ($request, DelegateInterface $delegate) use ($routesRequiringAuthorization, $validator) {\n    if (! ($result = $request->getAttribute(RouteResult::class, false))) {\n        // No route matched; delegate to next middleware\n        return $delegate->process($request);\n    }\n\n    if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) {\n        // Not a route requiring authorization\n        return $delegate->process($request);\n    }\n\n    $header = $request->getHeaderLine('Authorization');\n    if (! $validator($header)) {\n        return new EmptyResponse(403);\n    }\n\n    return $delegate->process($request);\n}\n\n\n\nNote that the first step is to determine if we have a \nRouteResult\n; if we do\nnot have one, we should either delegate to the next middleware, or return some\nsort of response (generally a 404). In the case of Expressive, a later\nmiddleware will generate the 404 response for us, so we can safely delegate.\n\n\nURI generation\n\n\nBecause routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the \nRouterInterface\n,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.\n\n\nAt it's most basic level, you call the \ngenerateUri()\n method with a route name\nand any substitutions you want to make:\n\n\n$uri = $router->generateUri('book', ['id' => 'zend-expressive']);\n\n\n\nSome routers may support providing \noptions\n during URI generation. Starting in\nzend-expressive-router 2.0, which ships with Expressive starting with version\n2.0, you may also pass a third argument to \ngenerateUri()\n, an array of router\noptions:\n\n\n$uri = $router->generateUri('book', ['id' => 'zend-expressive'], [\n    'translator'  => $translator,\n    'text_domain' => $currentLocale,\n]);\n\n\n\nSupported implementations\n\n\nExpressive currently ships with adapters for the following routers:\n\n\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-mvc Router",
            "title": "Introduction"
        },
        {
            "location": "/features/router/intro/#routing",
            "text": "One fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:   /books  might return a collection of books  /books/zend-expressive  might return the individual book identified by\n  \"zend-expressive\".   Expressive does not provide routing on its own; you must choose a routing\nadapter that implements  Zend\\Expressive\\Router\\RouterInterface  and provide it\nto the  Application  instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.",
            "title": "Routing"
        },
        {
            "location": "/features/router/intro/#retrieving-matched-parameters",
            "text": "Routing enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as  attributes .  In the example above, let's assume the route was defined as  /books/:id , where id  is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the  id  attribute to discover what was\nmatched:  $id = $request->getAttribute('id');",
            "title": "Retrieving matched parameters"
        },
        {
            "location": "/features/router/intro/#retrieving-the-matched-route",
            "text": "When routing is successful, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult  instance as a request attribute, using that\nclass name as the attribute name. The  RouteResult  instance provides you access\nto the following:   The matched  Zend\\Expressive\\Router\\Route  instance, via  $result->getMatchedRoute() .  The matched route name, via  $result->getMatchedRouteName()  (or via\n   $result->getMatchedRoute()->getName() ).  The matched middleware, via  $result->getMatchedMiddleware()  (or via\n   $result->getMatchedRoute()->getMiddleware() ).  Matched parameters, via  $result->getMatchedParams()  (as noted above, these\n  are also each injected as discrete request attributes).  Allowed HTTP methods, via  $result->getAllowedMethods() .   As an example, you could use middleware similar to the following to return a 403\nresponse if routing was successful, but no  Authorization  header is present:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nfunction ($request, DelegateInterface $delegate) use ($routesRequiringAuthorization, $validator) {\n    if (! ($result = $request->getAttribute(RouteResult::class, false))) {\n        // No route matched; delegate to next middleware\n        return $delegate->process($request);\n    }\n\n    if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) {\n        // Not a route requiring authorization\n        return $delegate->process($request);\n    }\n\n    $header = $request->getHeaderLine('Authorization');\n    if (! $validator($header)) {\n        return new EmptyResponse(403);\n    }\n\n    return $delegate->process($request);\n}  Note that the first step is to determine if we have a  RouteResult ; if we do\nnot have one, we should either delegate to the next middleware, or return some\nsort of response (generally a 404). In the case of Expressive, a later\nmiddleware will generate the 404 response for us, so we can safely delegate.",
            "title": "Retrieving the matched route"
        },
        {
            "location": "/features/router/intro/#uri-generation",
            "text": "Because routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the  RouterInterface ,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.  At it's most basic level, you call the  generateUri()  method with a route name\nand any substitutions you want to make:  $uri = $router->generateUri('book', ['id' => 'zend-expressive']);  Some routers may support providing  options  during URI generation. Starting in\nzend-expressive-router 2.0, which ships with Expressive starting with version\n2.0, you may also pass a third argument to  generateUri() , an array of router\noptions:  $uri = $router->generateUri('book', ['id' => 'zend-expressive'], [\n    'translator'  => $translator,\n    'text_domain' => $currentLocale,\n]);",
            "title": "URI generation"
        },
        {
            "location": "/features/router/intro/#supported-implementations",
            "text": "Expressive currently ships with adapters for the following routers:   Aura.Router  FastRoute  zend-mvc Router",
            "title": "Supported implementations"
        },
        {
            "location": "/features/router/interface/",
            "text": "Routing Interface\n\n\nExpressive defines \nZend\\Expressive\\Router\\RouterInterface\n, which can be\ninjected into and consumed by \nZend\\Expressive\\Application\n in order to provide\ndynamic routing capabilities to middleware. The interface serves as an\nabstraction to allow routers with varying capabilities to be used with an\napplication.\n\n\nThe interface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @param Route $route\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route);\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     *\n     * @param  Request $request\n     * @return RouteResult\n     */\n    public function match(Request $request);\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it.\n     *\n     * @see https://github.com/auraphp/Aura.Router#generating-a-route-path\n     * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html\n     * @param string $name\n     * @param array $substitutions\n     * @param array $options Since zend-expressive-router 2.0/zend-expressive 2.0;\n     *     not defined in earlier versions.\n     * @return string\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri($name, array $substitutions = [], array $options = []);\n}\n\n\n\nDevelopers may create and use their own implementations. We recommend\nregistering your implementation as the service\n\nZend\\Expressive\\Router\\RouterInterface\n in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.\n\n\nImplementors should also read the following sections detailing the \nRoute\n and\n\nRouteResult\n classes, to ensure that their implementations interoperate\ncorrectly.\n\n\n\n\ngenerateUri() signature change in 2.0\n\n\nPrior to zendframework/zend-expressive-router 2.0.0, the signature of\n\ngenerateUri()\n was:\n\n\npublic function generateUri(\n    string $name,\n    array $substitutions = []\n) : string\n\n\n\nIf you are targeting that version, you may still provide the \n$options\n\nargument, but it will not be invoked.\n\n\n\n\nRoutes\n\n\nRoutes are defined via \nZend\\Expressive\\Router\\Route\n, and aggregate the\nfollowing information:\n\n\n\n\nPath to match.\n\n\nMiddleware to use when the route is matched. This may be a callable or a\n  service name resolving to middleware.\n\n\nHTTP methods allowed for the route; if none are provided, all are assumed.\n\n\nOptionally, a name by which to reference the route.\n\n\n\n\nThe \nRoute\n class has the following signature:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\n\nclass Route\n{\n    const HTTP_METHOD_ANY = 0xff;\n    const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param string|callable|MiddlewareInterface $middleware Middleware to use\n     *     when this route is matched. MiddlewareInterface is supported starting\n     *     in zend-expressive-router 2.1.0.\n     * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param string|null $name the route name\n     * @throws Exception\\InvalidArgumentException for invalid path type.\n     * @throws Exception\\InvalidArgumentException for invalid middleware type.\n     * @throws Exception\\InvalidArgumentException for any invalid HTTP method names.\n     */\n    public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null);\n\n    /**\n     * @return string\n     */\n    public function getPath();\n\n    /**\n     * Set the route name.\n     *\n     * @param string $name\n     */\n    public function setName($name);\n\n    /**\n     * @return string\n     */\n    public function getName();\n\n    /**\n     * @return string|callable|MiddlewareInterface MiddlewareInterface is supported\n     *     starting in zend-expressive-router 2.1.0.\n     */\n    public function getMiddleware();\n\n    /**\n     * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods();\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     * @return bool\n     */\n    public function allowsMethod($method);\n\n    /**\n     * @param array $options\n     */\n    public function setOptions(array $options);\n\n    /**\n     * @return array\n     */\n    public function getOptions();\n}\n\n\n\nTypically, developers will use \nZend\\Expressive\\Application::route()\n (or one of\nthe HTTP-specific routing methods) to create routes, and will not need to\ninteract with \nRoute\n instances. However, that method can \nalso\n accept \nRoute\n\ninstances, allowing more flexibility in defining and configuring them;\nadditionally, when working with \nRouteResult\n instances, you may pull the\n\nRoute\n instance from that in order to obtain data about the matched route.\n\n\nMatching and RouteResults\n\n\nInternally, \nZend\\Expressive\\Application\n calls on \nRouterInterface::match()\n,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the\n\nHTTPS\n server variable, etc.\n\n\nImplementations are expected to return a \nZend\\Expressive\\Router\\RouteResult\n\ninstance, which the routing middleware then uses to determine if routing\nsucceeded. In the event of success, it will pull any matched parameters from the\nresult and inject them as request attributes, and then pull the matched\nmiddleware and execute it. In the case of failure, it will determine if the\nfailure was due to inability to match, or usage of a disallowed HTTP method; in\nthe former case, it proceeds to the next middleware in the stack, and in the\nlatter, returns a 405 response.\n\n\nThe \nRouteResult\n signature is as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nclass RouteResult\n{\n    /**\n     * Create an instance representing a route success.\n     *\n     * This method is removed starting in zend-expressive-router 2.0; use\n     * fromRoute() instead.\n     *\n     * @param string $name Name of matched route.\n     * @param callable|string $middleware Middleware associated with the\n     *     matched route.\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRouteMatch($name, $middleware, array $params);\n\n    /**\n     * Create an instance representing a route success from a Route instance.\n     *\n     * This method was introduced in zend-expressive-router 1.3, and should\n     * be used for generating an instance indicating a route success from\n     * that version forward.\n     *\n     * @param Route $route\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRoute(Route $route, array $params = []);\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|int|array $methods HTTP methods allowed for the current URI, if any\n     * @return static\n     */\n    public static function fromRouteFailure($methods = null);\n\n    /**\n     * Does the result represent successful routing?\n     *\n     * @return bool\n     */\n    public function isSuccess();\n\n    /**\n     * Retrieve the matched route, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route instance.\n     *\n     * Available starting in zend-expressive-router 1.3.0.\n     *\n     * @return Route\n     */\n    public function getMatchedRoute();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Retrieve the matched middleware, if possible.\n     *\n     * @return false|callable|string Returns false if the result represents a\n     *     failure; otherwise, a callable or a string service name.\n     */\n    public function getMatchedMiddleware();\n\n    /**\n     * Returns the matched params.\n     *\n     * Guaranteed to return an array, even if it is simply empty.\n     *\n     * @return array\n     */\n    public function getMatchedParams();\n\n    /**\n     * Is this a routing failure result?\n     *\n     * @return bool\n     */\n    public function isFailure();\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     *\n     * @return bool\n     */\n    public function isMethodFailure();\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods();\n}\n\n\n\nTypically, only those implementing routers will interact with this class.",
            "title": "Routing Interface"
        },
        {
            "location": "/features/router/interface/#routing-interface",
            "text": "Expressive defines  Zend\\Expressive\\Router\\RouterInterface , which can be\ninjected into and consumed by  Zend\\Expressive\\Application  in order to provide\ndynamic routing capabilities to middleware. The interface serves as an\nabstraction to allow routers with varying capabilities to be used with an\napplication.  The interface is defined as follows:  namespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @param Route $route\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route);\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     *\n     * @param  Request $request\n     * @return RouteResult\n     */\n    public function match(Request $request);\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it.\n     *\n     * @see https://github.com/auraphp/Aura.Router#generating-a-route-path\n     * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html\n     * @param string $name\n     * @param array $substitutions\n     * @param array $options Since zend-expressive-router 2.0/zend-expressive 2.0;\n     *     not defined in earlier versions.\n     * @return string\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri($name, array $substitutions = [], array $options = []);\n}  Developers may create and use their own implementations. We recommend\nregistering your implementation as the service Zend\\Expressive\\Router\\RouterInterface  in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.  Implementors should also read the following sections detailing the  Route  and RouteResult  classes, to ensure that their implementations interoperate\ncorrectly.",
            "title": "Routing Interface"
        },
        {
            "location": "/features/router/interface/#generateuri-signature-change-in-20",
            "text": "Prior to zendframework/zend-expressive-router 2.0.0, the signature of generateUri()  was:  public function generateUri(\n    string $name,\n    array $substitutions = []\n) : string  If you are targeting that version, you may still provide the  $options \nargument, but it will not be invoked.",
            "title": "generateUri() signature change in 2.0"
        },
        {
            "location": "/features/router/interface/#routes",
            "text": "Routes are defined via  Zend\\Expressive\\Router\\Route , and aggregate the\nfollowing information:   Path to match.  Middleware to use when the route is matched. This may be a callable or a\n  service name resolving to middleware.  HTTP methods allowed for the route; if none are provided, all are assumed.  Optionally, a name by which to reference the route.   The  Route  class has the following signature:  namespace Zend\\Expressive\\Router;\n\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\n\nclass Route\n{\n    const HTTP_METHOD_ANY = 0xff;\n    const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param string|callable|MiddlewareInterface $middleware Middleware to use\n     *     when this route is matched. MiddlewareInterface is supported starting\n     *     in zend-expressive-router 2.1.0.\n     * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param string|null $name the route name\n     * @throws Exception\\InvalidArgumentException for invalid path type.\n     * @throws Exception\\InvalidArgumentException for invalid middleware type.\n     * @throws Exception\\InvalidArgumentException for any invalid HTTP method names.\n     */\n    public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null);\n\n    /**\n     * @return string\n     */\n    public function getPath();\n\n    /**\n     * Set the route name.\n     *\n     * @param string $name\n     */\n    public function setName($name);\n\n    /**\n     * @return string\n     */\n    public function getName();\n\n    /**\n     * @return string|callable|MiddlewareInterface MiddlewareInterface is supported\n     *     starting in zend-expressive-router 2.1.0.\n     */\n    public function getMiddleware();\n\n    /**\n     * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods();\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     * @return bool\n     */\n    public function allowsMethod($method);\n\n    /**\n     * @param array $options\n     */\n    public function setOptions(array $options);\n\n    /**\n     * @return array\n     */\n    public function getOptions();\n}  Typically, developers will use  Zend\\Expressive\\Application::route()  (or one of\nthe HTTP-specific routing methods) to create routes, and will not need to\ninteract with  Route  instances. However, that method can  also  accept  Route \ninstances, allowing more flexibility in defining and configuring them;\nadditionally, when working with  RouteResult  instances, you may pull the Route  instance from that in order to obtain data about the matched route.",
            "title": "Routes"
        },
        {
            "location": "/features/router/interface/#matching-and-routeresults",
            "text": "Internally,  Zend\\Expressive\\Application  calls on  RouterInterface::match() ,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the HTTPS  server variable, etc.  Implementations are expected to return a  Zend\\Expressive\\Router\\RouteResult \ninstance, which the routing middleware then uses to determine if routing\nsucceeded. In the event of success, it will pull any matched parameters from the\nresult and inject them as request attributes, and then pull the matched\nmiddleware and execute it. In the case of failure, it will determine if the\nfailure was due to inability to match, or usage of a disallowed HTTP method; in\nthe former case, it proceeds to the next middleware in the stack, and in the\nlatter, returns a 405 response.  The  RouteResult  signature is as follows:  namespace Zend\\Expressive\\Router;\n\nclass RouteResult\n{\n    /**\n     * Create an instance representing a route success.\n     *\n     * This method is removed starting in zend-expressive-router 2.0; use\n     * fromRoute() instead.\n     *\n     * @param string $name Name of matched route.\n     * @param callable|string $middleware Middleware associated with the\n     *     matched route.\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRouteMatch($name, $middleware, array $params);\n\n    /**\n     * Create an instance representing a route success from a Route instance.\n     *\n     * This method was introduced in zend-expressive-router 1.3, and should\n     * be used for generating an instance indicating a route success from\n     * that version forward.\n     *\n     * @param Route $route\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRoute(Route $route, array $params = []);\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|int|array $methods HTTP methods allowed for the current URI, if any\n     * @return static\n     */\n    public static function fromRouteFailure($methods = null);\n\n    /**\n     * Does the result represent successful routing?\n     *\n     * @return bool\n     */\n    public function isSuccess();\n\n    /**\n     * Retrieve the matched route, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route instance.\n     *\n     * Available starting in zend-expressive-router 1.3.0.\n     *\n     * @return Route\n     */\n    public function getMatchedRoute();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Retrieve the matched middleware, if possible.\n     *\n     * @return false|callable|string Returns false if the result represents a\n     *     failure; otherwise, a callable or a string service name.\n     */\n    public function getMatchedMiddleware();\n\n    /**\n     * Returns the matched params.\n     *\n     * Guaranteed to return an array, even if it is simply empty.\n     *\n     * @return array\n     */\n    public function getMatchedParams();\n\n    /**\n     * Is this a routing failure result?\n     *\n     * @return bool\n     */\n    public function isFailure();\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     *\n     * @return bool\n     */\n    public function isMethodFailure();\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods();\n}  Typically, only those implementing routers will interact with this class.",
            "title": "Matching and RouteResults"
        },
        {
            "location": "/features/router/uri-generation/",
            "text": "URI Generation\n\n\nOne aspect of the \nZend\\Expressive\\Router\\RouterInterface\n is that it provides a\n\ngenerateUri()\n method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders). Starting in zend-expressive-router 2.0, shipped\nwith Expressive 2.0, you may also pass router-specific options to use during\nURI generation as a third argument.\n\n\nNaming routes\n\n\nBy default, routes use a combination of the path and HTTP methods supported as\nthe name:\n\n\n\n\nIf you call \nroute()\n with no HTTP methods, the name is the literal path with\n  no changes.\n\n\n\n\n$app->route('/foo', $middleware); // \"foo\"\n\n\n\n\n\nIf you call \nget()\n, \npost()\n, \nput()\n, \npatch()\n, or \ndelete()\n, the name\n  will be the literal path, followed by a caret (\n^\n), followed by the\n  uppercase HTTP method name:\n\n\n\n\n$app->get('/foo', $middleware); // \"foo^GET\"\n\n\n\nAlternately, these methods return a \nRoute\n instance, and you can set the\n  name on it:\n\n\n$app->get('/foo', $middleware)->setName('foo'); // \"foo\"\n\n\n\n\n\nIf you call \nroute()\n and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret (\n^\n), followed by a colon\n  (\n:\n)-separated list of the uppercase HTTP method names, in the order in which\n  they were added.\n\n\n\n\n$app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n\n\n\nLike the HTTP-specific methods, \nroute()\n also returns a \nRoute\n instance,\n  and you can set the name on it:\n\n\n$route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n$route->setName('foo'); // \"foo\"\n\n\n\nClearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:\n\n\n$app->route('/foo', $middleware, 'foo'); // 'foo'\n$app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'\n\n\n\nAs noted above, these methods also return \nRoute\n instances, allowing you to\nset the name after-the-fact; this is particularly useful with the \nroute()\n\nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:\n\n\n$app->route('/foo', $middleware)->setName('foo'); // 'foo'\n\n\n\nWe recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.\n\n\nGenerating URIs\n\n\nOnce you know the name of a URI you wish to generate, you can do so from the\nrouter instance:\n\n\n$uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\"\n\n\n\nYou can omit the second argument if no substitutions are necessary.\n\n\n\n\nCompose the router\n\n\nFor this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the\n\nZend\\Expressive\\Router\\RouterInterface\n service in these situations.",
            "title": "URI Generation"
        },
        {
            "location": "/features/router/uri-generation/#uri-generation",
            "text": "One aspect of the  Zend\\Expressive\\Router\\RouterInterface  is that it provides a generateUri()  method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders). Starting in zend-expressive-router 2.0, shipped\nwith Expressive 2.0, you may also pass router-specific options to use during\nURI generation as a third argument.",
            "title": "URI Generation"
        },
        {
            "location": "/features/router/uri-generation/#naming-routes",
            "text": "By default, routes use a combination of the path and HTTP methods supported as\nthe name:   If you call  route()  with no HTTP methods, the name is the literal path with\n  no changes.   $app->route('/foo', $middleware); // \"foo\"   If you call  get() ,  post() ,  put() ,  patch() , or  delete() , the name\n  will be the literal path, followed by a caret ( ^ ), followed by the\n  uppercase HTTP method name:   $app->get('/foo', $middleware); // \"foo^GET\"  Alternately, these methods return a  Route  instance, and you can set the\n  name on it:  $app->get('/foo', $middleware)->setName('foo'); // \"foo\"   If you call  route()  and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret ( ^ ), followed by a colon\n  ( : )-separated list of the uppercase HTTP method names, in the order in which\n  they were added.   $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"  Like the HTTP-specific methods,  route()  also returns a  Route  instance,\n  and you can set the name on it:  $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n$route->setName('foo'); // \"foo\"  Clearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:  $app->route('/foo', $middleware, 'foo'); // 'foo'\n$app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'  As noted above, these methods also return  Route  instances, allowing you to\nset the name after-the-fact; this is particularly useful with the  route() \nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:  $app->route('/foo', $middleware)->setName('foo'); // 'foo'  We recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.",
            "title": "Naming routes"
        },
        {
            "location": "/features/router/uri-generation/#generating-uris",
            "text": "Once you know the name of a URI you wish to generate, you can do so from the\nrouter instance:  $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\"  You can omit the second argument if no substitutions are necessary.",
            "title": "Generating URIs"
        },
        {
            "location": "/features/router/uri-generation/#compose-the-router",
            "text": "For this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the Zend\\Expressive\\Router\\RouterInterface  service in these situations.",
            "title": "Compose the router"
        },
        {
            "location": "/features/router/piping/",
            "text": "Routing vs Piping\n\n\nExpressive provides two mechanisms for adding middleware to your\napplication:\n\n\n\n\npiping, which is a foundation feature of the underlying\n  \nzend-stratigility\n\n  implementation.\n\n\nrouting, which is an additional feature provided by zend-expressive.\n\n\n\n\nPiping\n\n\nzend-stratigility provides a mechanism termed \npiping\n for composing middleware\nin an application. When you \npipe\n middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\nIf none ever returns a response instance, execution is delegated to a \"final\nhandler\", which determines whether or not to return an error, and, if so, what\nkind of error to return.\n\n\nStratigility also allows you to segregate piped middleware to specific paths. As\nan example:\n\n\n$app->pipe('/api', $apiMiddleware);\n\n\n\nwill execute \n$apiMiddleware\n only if the path matches \n/api\n; otherwise, it\nwill skip over that middleware.\n\n\nThis path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.\n\n\nExpressive uses and exposes piping to users, with one addition: \nmiddleware\nmay be specified by service name, and zend-expressive will lazy-load the service\nonly when the middleware is invoked\n.\n\n\nIn order to accomplish the lazy-loading, zend-expressive wraps the calls to\nfetch and dispatch the middleware inside a\n\nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n instance; as such, there is\nno overhead to utilizing service-based middleware \nuntil it is dispatched\n.\n\n\n\n\nService-based middleware in version 1\n\n\nIn Expressive 1.X versions, lazy-loading middleware was handled by wrapping\nthe middleware inside a closure which composed the container.\n\n\nThis posed a problem for Stratigility 1.X-style error handling middleware, as\nzend-stratigility identified error handling middleware by its arity (number of\nfunction arguments); as such, zend-expressive defined an additional method for\npiping service-driven error handling middleware, \npipeErrorHandler()\n. That\nmethod had the same signature as \npipe()\n:\n\n\n// Without a path:\n$app->pipeErrorHandler('error handler service name');\n\n// Specific to a path:\n$app->pipeErrorHandler('/api', 'error handler service name');\n\n\n\nThat method returned a closure using the error middleware signature.\n\n\nAs noted in the \nerror handling chapter\n, you should\nnot use Stratigility 1.X-style error handling middleware at this time, even\nif you are still using Expressive 1.X. If you have calls to\n\npipeErrorHandler()\n, these should be removed, and you should replace them\nwith standard middleware that performs error handling.\n\n\n\n\nRouting\n\n\nRouting is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:\n\n\n\n\n/book/:id\n (ZF2)\n\n\n/book/{id}\n (Aura.Router)\n\n\n/book/{id:\\d+}\n (FastRoute)\n\n\n\n\nIn each of the above, if the router determines that the request matches the\ncriteria, it will indicate:\n\n\n\n\nthe route that matched\n\n\nthe \nid\n parameter was matched, and the value matched\n\n\n\n\nMost routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:\n\n\n\n\ndefault values for unmatched parameters\n\n\ncriteria for evaluating a match (such as a regular expression)\n\n\nadditional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)\n\n\n\n\nAs such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).\n\n\nWhen to Pipe\n\n\nIn Expressive, we recommend that you pipe middleware in the following\ncircumstances:\n\n\n\n\nIt should (potentially) run on every execution. Examples for such usage\n  include:\n\n\nLogging requests\n\n\nPerforming content negotiation\n\n\nHandling cookies\n\n\n\n\n\n\nError handling.\n\n\nApplication segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.\n\n\n\n\nWhen to Route\n\n\nUse routing when:\n\n\n\n\nYour middleware is reacting to a given path.\n\n\nYou want to use dynamic routing.\n\n\nYou want to restrict usage of middleware to specific HTTP methods.\n\n\nYou want to be able to generate URIs to your middleware.\n\n\n\n\nThe above cover most use cases; \nin other words, most middleware should be added\nto the application as routed middleware\n.\n\n\nControlling middleware execution order\n\n\nAs noted in the earlier section on piping, piped middleware is \nqueued\n, meaning\nit has a FIFO (\"first in, first out\") execution order.\n\n\nAdditionally, zend-expressive's routing and dispatch capabilities are themselves\nimplemented as piped middleware.\n\n\nTo ensure your middleware is piped correctly, keep in mind the following:\n\n\n\n\nIf middleware should execute on \nevery request\n, pipe it early.\n\n\nPipe routing and dispatch middleware using their dedicated application methods\n  (more on this below), optionally with middleware between them to further shape\n  application flow.\n\n\nPipe middleware guaranteed to return a response (such as a \"not found\" handler\n  or similar) \nlast\n.\n\n\n\n\nTo use the shipped routing and dispatch middleware (likely a good idea!), use\nthe dedicated application methods \npipeRoutingMiddleware()\n and\n\npipeDispatchMiddleware()\n; \nApplication\n contains logic to ensure neither of\nthese are called more than once.\n\n\nAs an example:\n\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipe(XClacksOverhead::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipe(AuthorizationCheck::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);",
            "title": "Routing vs Piping"
        },
        {
            "location": "/features/router/piping/#routing-vs-piping",
            "text": "Expressive provides two mechanisms for adding middleware to your\napplication:   piping, which is a foundation feature of the underlying\n   zend-stratigility \n  implementation.  routing, which is an additional feature provided by zend-expressive.",
            "title": "Routing vs Piping"
        },
        {
            "location": "/features/router/piping/#piping",
            "text": "zend-stratigility provides a mechanism termed  piping  for composing middleware\nin an application. When you  pipe  middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\nIf none ever returns a response instance, execution is delegated to a \"final\nhandler\", which determines whether or not to return an error, and, if so, what\nkind of error to return.  Stratigility also allows you to segregate piped middleware to specific paths. As\nan example:  $app->pipe('/api', $apiMiddleware);  will execute  $apiMiddleware  only if the path matches  /api ; otherwise, it\nwill skip over that middleware.  This path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.  Expressive uses and exposes piping to users, with one addition:  middleware\nmay be specified by service name, and zend-expressive will lazy-load the service\nonly when the middleware is invoked .  In order to accomplish the lazy-loading, zend-expressive wraps the calls to\nfetch and dispatch the middleware inside a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware  instance; as such, there is\nno overhead to utilizing service-based middleware  until it is dispatched .",
            "title": "Piping"
        },
        {
            "location": "/features/router/piping/#service-based-middleware-in-version-1",
            "text": "In Expressive 1.X versions, lazy-loading middleware was handled by wrapping\nthe middleware inside a closure which composed the container.  This posed a problem for Stratigility 1.X-style error handling middleware, as\nzend-stratigility identified error handling middleware by its arity (number of\nfunction arguments); as such, zend-expressive defined an additional method for\npiping service-driven error handling middleware,  pipeErrorHandler() . That\nmethod had the same signature as  pipe() :  // Without a path:\n$app->pipeErrorHandler('error handler service name');\n\n// Specific to a path:\n$app->pipeErrorHandler('/api', 'error handler service name');  That method returned a closure using the error middleware signature.  As noted in the  error handling chapter , you should\nnot use Stratigility 1.X-style error handling middleware at this time, even\nif you are still using Expressive 1.X. If you have calls to pipeErrorHandler() , these should be removed, and you should replace them\nwith standard middleware that performs error handling.",
            "title": "Service-based middleware in version 1"
        },
        {
            "location": "/features/router/piping/#routing",
            "text": "Routing is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:   /book/:id  (ZF2)  /book/{id}  (Aura.Router)  /book/{id:\\d+}  (FastRoute)   In each of the above, if the router determines that the request matches the\ncriteria, it will indicate:   the route that matched  the  id  parameter was matched, and the value matched   Most routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:   default values for unmatched parameters  criteria for evaluating a match (such as a regular expression)  additional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)   As such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).",
            "title": "Routing"
        },
        {
            "location": "/features/router/piping/#when-to-pipe",
            "text": "In Expressive, we recommend that you pipe middleware in the following\ncircumstances:   It should (potentially) run on every execution. Examples for such usage\n  include:  Logging requests  Performing content negotiation  Handling cookies    Error handling.  Application segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.",
            "title": "When to Pipe"
        },
        {
            "location": "/features/router/piping/#when-to-route",
            "text": "Use routing when:   Your middleware is reacting to a given path.  You want to use dynamic routing.  You want to restrict usage of middleware to specific HTTP methods.  You want to be able to generate URIs to your middleware.   The above cover most use cases;  in other words, most middleware should be added\nto the application as routed middleware .",
            "title": "When to Route"
        },
        {
            "location": "/features/router/piping/#controlling-middleware-execution-order",
            "text": "As noted in the earlier section on piping, piped middleware is  queued , meaning\nit has a FIFO (\"first in, first out\") execution order.  Additionally, zend-expressive's routing and dispatch capabilities are themselves\nimplemented as piped middleware.  To ensure your middleware is piped correctly, keep in mind the following:   If middleware should execute on  every request , pipe it early.  Pipe routing and dispatch middleware using their dedicated application methods\n  (more on this below), optionally with middleware between them to further shape\n  application flow.  Pipe middleware guaranteed to return a response (such as a \"not found\" handler\n  or similar)  last .   To use the shipped routing and dispatch middleware (likely a good idea!), use\nthe dedicated application methods  pipeRoutingMiddleware()  and pipeDispatchMiddleware() ;  Application  contains logic to ensure neither of\nthese are called more than once.  As an example:  $app->pipe(OriginalMessages::class);\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipe(XClacksOverhead::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipe(AuthorizationCheck::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);",
            "title": "Controlling middleware execution order"
        },
        {
            "location": "/features/router/aura/",
            "text": "Using Aura.Router\n\n\nAura.Router\n provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:\n\n\n\n\nA regular expression that applies the same for a given routing match:\n\n\n\n\n// Parameters named \"id\" will only match digits by default:\n$router->addTokens([\n  'id' => '\\d+',\n]);\n\n\n\n\n\nA default parameter and/or its default value to always provide:\n\n\n\n\n// mediatype defaults to \"application/xhtml+xml\" and will be available in all\n// requests:\n$router->addValues([\n  'mediatype' => 'application/xhtml+xml',\n]);\n\n\n\n\n\nOnly match if secure (i.e., under HTTPS):\n\n\n\n\n$router->setSecure(true);\n\n\n\nIn order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling Aura.Router\n\n\nTo use Aura.Router, you will first need to install the Aura.Router integration:\n\n\n$ composer require zendframework/zend-expressive-aurarouter\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\AuraRouter\n instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\AuraRouter\n during instantiation.\n\n\n<?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())->newInstance();\n$auraRouter->setSecure(true);\n$auraRouter->addValues([\n    'mediatype' => 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your Aura.Router implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\AuraRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Application\\Container\\RouterFactory::class\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nAura\\Router\\Router\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\AuraRouter\n instance composing the\n  \nAura\\Router\\Router\n instance.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n// in src/Application/Container/AuraRouterFactory.php:\nnamespace Application\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Psr\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())->newInstance();\n        $router->setSecure(true);\n        $router->addValues([\n            'mediatype' => 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container->get('Aura\\Router\\Router'));\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'Aura\\Router\\Router',\n    Application\\Container\\AuraRouterFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'Aura\\Router\\Router' => Application\\Container\\AuraRouterFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => 'Application\\Container\\RouterFactory::class,\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\AuraRouterFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['Aura\\Router\\Router'] = new AuraRouterFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Using Aura"
        },
        {
            "location": "/features/router/aura/#using-aurarouter",
            "text": "Aura.Router  provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:   A regular expression that applies the same for a given routing match:   // Parameters named \"id\" will only match digits by default:\n$router->addTokens([\n  'id' => '\\d+',\n]);   A default parameter and/or its default value to always provide:   // mediatype defaults to \"application/xhtml+xml\" and will be available in all\n// requests:\n$router->addValues([\n  'mediatype' => 'application/xhtml+xml',\n]);   Only match if secure (i.e., under HTTPS):   $router->setSecure(true);  In order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.",
            "title": "Using Aura.Router"
        },
        {
            "location": "/features/router/aura/#installing-aurarouter",
            "text": "To use Aura.Router, you will first need to install the Aura.Router integration:  $ composer require zendframework/zend-expressive-aurarouter",
            "title": "Installing Aura.Router"
        },
        {
            "location": "/features/router/aura/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\AuraRouter  instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:  use Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/features/router/aura/#programmatic-creation",
            "text": "If you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter  during instantiation.  <?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())->newInstance();\n$auraRouter->setSecure(true);\n$auraRouter->addValues([\n    'mediatype' => 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/features/router/aura/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/features/router/aura/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your Aura.Router implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/features/router/aura/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\AuraRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Application\\Container\\RouterFactory::class\n);  And in Pimple:  $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);",
            "title": "Basic Router"
        },
        {
            "location": "/features/router/aura/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Aura\\Router\\Router  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\AuraRouter  instance composing the\n   Aura\\Router\\Router  instance.   Sound difficult? It's not; we've essentially done it above already!  // in src/Application/Container/AuraRouterFactory.php:\nnamespace Application\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Psr\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())->newInstance();\n        $router->setSecure(true);\n        $router->addValues([\n            'mediatype' => 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container->get('Aura\\Router\\Router'));\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'Aura\\Router\\Router',\n    Application\\Container\\AuraRouterFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'Aura\\Router\\Router' => Application\\Container\\AuraRouterFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => 'Application\\Container\\RouterFactory::class,\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\AuraRouterFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['Aura\\Router\\Router'] = new AuraRouterFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/features/router/fast-route/",
            "text": "Using FastRoute\n\n\nFastRoute\n provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.\n\n\nInternally, we use the standard route parser (\nFastRoute\\RouterParser\\Std\n) to\nparse routes, a \nRouteCollector\n to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.\n\n\nIf you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the \nZend\\Expressive\\Router\\FastRouteRouter\n class, at instantiation.\n\n\nThe \nFastRouteRouter\n bridge class accepts two arguments at instantiation:\n\n\n\n\nA \nFastRoute\\RouteCollector\n instance\n\n\nA callable that will return a \nFastRoute\\Dispatcher\\RegexBasedAbstract\n\n  instance.\n\n\n\n\nInjection can be done either programmatically or via a factory to use in\nconjunction with your container instance.\n\n\nInstalling FastRoute\n\n\nTo use FastRoute, you will first need to install the FastRoute integration:\n\n\n$ composer require zendframework/zend-expressive-fastroute\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\FastRouteRouter\n instance\nwith no arguments; it will create the underlying FastRoute objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\n$router = new FastRouteRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the FastRoute setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\FastRouteRouter\n during instantiation.\n\n\nTo do so, you will need to setup your \nRouteCollector\n instance and/or\noptionally callable to return your \nRegexBasedAbstract\n instance manually,\ninject them in your \nZend\\Expressive\\Router\\FastRouteRouter\n instance, and inject use\nthat when creating your \nApplication\n instance.\n\n\n<?php\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\n$fastRoute = new RouteCollector(\n    new RouteParser(),\n    new RouteGenerator()\n);\n$getDispatcher = function ($data) {\n    return new FastRouteDispatcher($data);\n};\n\n\n$router = new FastRouteBridge($fastRoute, $getDispatcher);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your FastRoute implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\FastRouteRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new App\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\FastRouteRouter::class\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:\n\n\n\n\nA factory to register as and generate a \nFastRoute\\RouteCollector\n instance.\n\n\nA factory to register as \nFastRoute\\DispatcherFactory\n and return a callable\n  factory that returns a \nRegexBasedAbstract\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\FastRouteRouter\n instance composing the\n  two services.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n<?php\n// in src/App/Container/FastRouteCollectorFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/App/Container/FastRouteDispatcherFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container->get(FastRoute\\RouteCollector::class),\n            $container->get(FastRoute\\DispatcherFactory::class)\n        );\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    FastRoute\\RouteCollector::class,\n    App\\Container\\FastRouteCollectorFactory::class\n);\n$container->addFactory(\n    FastRoute\\DispatcherFactory::class,\n    App\\Container\\FastRouteDispatcherFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'FastRoute\\RouteCollector' => App\\Container\\FastRouteCollectorFactory::class,\n        'FastRoute\\DispatcherFactory' => App\\Container\\FastRouteDispatcherFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse App\\Container\\FastRouteCollectorFactory;\nuse App\\Container\\FastRouteDispatcherFactory;\nuse App\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container[FastRoute\\RouteCollector::class] = new FastRouteCollectorFactory();\n$container[FastRoute\\RouteDispatcher::class] = new FastRouteDispatcherFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();\n\n\n\nFastRoute caching support\n\n\n\n\nSince zend-expressive-fastroute 1.3.0.\n\n\n\n\nStarting from version 1.3.0, zend-expressive-fastroute comes with support \nfor FastRoute native dispatch data caching.\n\n\nEnabling this feature requires changes to your configuration. Typically, router\nconfiguration occurs in \nconfig/autoload/routes.global.php\n; as such, we will\nreference that file when indicating configuration changes.\n\n\nThe changes required are:\n\n\n\n\n\n\nYou will need to delegate creation of the router instance to a new factory.\n\n\n\n\n\n\nYou will need to add a new configuration entry, \n$config['router']['fastroute']\n. \n  The options in this entry will be used by the factory to build the router\n  instance in order to toggle caching support and to specify a custom cache\n  file.\n\n\n\n\n\n\nAs an example:\n\n\n// File config/autoload/routes.global.php\n\nreturn [\n    'dependencies' => [\n        //..\n        'invokables' => [\n            /* ... */\n            // Comment out or remove the following line:\n            // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n            // Add this line; the specified factory now creates the router instance:\n            Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class,\n            /* ... */\n        ],\n    ],\n\n    // Add the following to enable caching support:\n    'router' => [\n        'fastroute' => [\n             // Enable caching support:\n            'cache_enabled' => true,\n             // Optional (but recommended) cache file path:\n            'cache_file'    => 'data/cache/fastroute.php.cache',\n        ],\n    ],\n\n    'routes' => [ /* ... */ ],\n]\n\n\n\nThe FastRoute-specific caching options are as follows:\n\n\n\n\n\n\ncache_enabled\n (bool) is used to toggle caching support. It's advisable to enable \n  caching in a production environment and leave it disabled for the development\n  environment. Commenting or omitting this option is equivalent to having it set\n  to \nfalse\n. We recommend enabling it in \nconfig/autoload/routes.global.php\n,\n  and, in development, disabling it within \nconfig/autoload/routes.local.php\n or\n  \nconfig/autoload/local.php\n.\n\n\n\n\n\n\ncache_file\n (string) is an optional parameter that represents the path of \n  the dispatch data cache file. It can be provided as an absolute file path or\n  as a path relative to the zend-expressive working directory. \n\n\n\n\n\n\nIt defaults to \ndata/cache/fastroute.php.cache\n, where \ndata/cache/\n is the\n  cache directory defined within the zend-expressive skeleton application.  An\n  explicit absolute file path is recommended since the php \ninclude\n construct\n  will skip searching the \ninclude_path\n and the current directory.\n\n\nIf you choose a custom path, make sure that the directory exists and is\n  writable by the owner of the PHP process. As with any other zend-expressive\n  cached configuration, you will need to purge this file in order to enable any\n  newly added route when FastRoute caching is enabled.",
            "title": "Using FastRoute"
        },
        {
            "location": "/features/router/fast-route/#using-fastroute",
            "text": "FastRoute  provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.  Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to\nparse routes, a  RouteCollector  to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.  If you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the  Zend\\Expressive\\Router\\FastRouteRouter  class, at instantiation.  The  FastRouteRouter  bridge class accepts two arguments at instantiation:   A  FastRoute\\RouteCollector  instance  A callable that will return a  FastRoute\\Dispatcher\\RegexBasedAbstract \n  instance.   Injection can be done either programmatically or via a factory to use in\nconjunction with your container instance.",
            "title": "Using FastRoute"
        },
        {
            "location": "/features/router/fast-route/#installing-fastroute",
            "text": "To use FastRoute, you will first need to install the FastRoute integration:  $ composer require zendframework/zend-expressive-fastroute",
            "title": "Installing FastRoute"
        },
        {
            "location": "/features/router/fast-route/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\FastRouteRouter  instance\nwith no arguments; it will create the underlying FastRoute objects required\nand compose them for you:  use Zend\\Expressive\\Router\\FastRouteRouter;\n\n$router = new FastRouteRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/features/router/fast-route/#programmatic-creation",
            "text": "If you need greater control over the FastRoute setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\FastRouteRouter  during instantiation.  To do so, you will need to setup your  RouteCollector  instance and/or\noptionally callable to return your  RegexBasedAbstract  instance manually,\ninject them in your  Zend\\Expressive\\Router\\FastRouteRouter  instance, and inject use\nthat when creating your  Application  instance.  <?php\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\n$fastRoute = new RouteCollector(\n    new RouteParser(),\n    new RouteGenerator()\n);\n$getDispatcher = function ($data) {\n    return new FastRouteDispatcher($data);\n};\n\n\n$router = new FastRouteBridge($fastRoute, $getDispatcher);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/features/router/fast-route/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/features/router/fast-route/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your FastRoute implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/features/router/fast-route/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\FastRouteRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);  And in Pimple:  $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new App\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\FastRouteRouter::class\n);",
            "title": "Basic Router"
        },
        {
            "location": "/features/router/fast-route/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:   A factory to register as and generate a  FastRoute\\RouteCollector  instance.  A factory to register as  FastRoute\\DispatcherFactory  and return a callable\n  factory that returns a  RegexBasedAbstract  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\FastRouteRouter  instance composing the\n  two services.   Sound difficult? It's not; we've essentially done it above already!  <?php\n// in src/App/Container/FastRouteCollectorFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/App/Container/FastRouteDispatcherFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container->get(FastRoute\\RouteCollector::class),\n            $container->get(FastRoute\\DispatcherFactory::class)\n        );\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    FastRoute\\RouteCollector::class,\n    App\\Container\\FastRouteCollectorFactory::class\n);\n$container->addFactory(\n    FastRoute\\DispatcherFactory::class,\n    App\\Container\\FastRouteDispatcherFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'FastRoute\\RouteCollector' => App\\Container\\FastRouteCollectorFactory::class,\n        'FastRoute\\DispatcherFactory' => App\\Container\\FastRouteDispatcherFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];  For Pimple, configuration looks like:  use App\\Container\\FastRouteCollectorFactory;\nuse App\\Container\\FastRouteDispatcherFactory;\nuse App\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container[FastRoute\\RouteCollector::class] = new FastRouteCollectorFactory();\n$container[FastRoute\\RouteDispatcher::class] = new FastRouteDispatcherFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/features/router/fast-route/#fastroute-caching-support",
            "text": "Since zend-expressive-fastroute 1.3.0.   Starting from version 1.3.0, zend-expressive-fastroute comes with support \nfor FastRoute native dispatch data caching.  Enabling this feature requires changes to your configuration. Typically, router\nconfiguration occurs in  config/autoload/routes.global.php ; as such, we will\nreference that file when indicating configuration changes.  The changes required are:    You will need to delegate creation of the router instance to a new factory.    You will need to add a new configuration entry,  $config['router']['fastroute'] . \n  The options in this entry will be used by the factory to build the router\n  instance in order to toggle caching support and to specify a custom cache\n  file.    As an example:  // File config/autoload/routes.global.php\n\nreturn [\n    'dependencies' => [\n        //..\n        'invokables' => [\n            /* ... */\n            // Comment out or remove the following line:\n            // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n            // Add this line; the specified factory now creates the router instance:\n            Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class,\n            /* ... */\n        ],\n    ],\n\n    // Add the following to enable caching support:\n    'router' => [\n        'fastroute' => [\n             // Enable caching support:\n            'cache_enabled' => true,\n             // Optional (but recommended) cache file path:\n            'cache_file'    => 'data/cache/fastroute.php.cache',\n        ],\n    ],\n\n    'routes' => [ /* ... */ ],\n]  The FastRoute-specific caching options are as follows:    cache_enabled  (bool) is used to toggle caching support. It's advisable to enable \n  caching in a production environment and leave it disabled for the development\n  environment. Commenting or omitting this option is equivalent to having it set\n  to  false . We recommend enabling it in  config/autoload/routes.global.php ,\n  and, in development, disabling it within  config/autoload/routes.local.php  or\n   config/autoload/local.php .    cache_file  (string) is an optional parameter that represents the path of \n  the dispatch data cache file. It can be provided as an absolute file path or\n  as a path relative to the zend-expressive working directory.     It defaults to  data/cache/fastroute.php.cache , where  data/cache/  is the\n  cache directory defined within the zend-expressive skeleton application.  An\n  explicit absolute file path is recommended since the php  include  construct\n  will skip searching the  include_path  and the current directory.  If you choose a custom path, make sure that the directory exists and is\n  writable by the owner of the PHP process. As with any other zend-expressive\n  cached configuration, you will need to purge this file in order to enable any\n  newly added route when FastRoute caching is enabled.",
            "title": "FastRoute caching support"
        },
        {
            "location": "/features/router/zf2/",
            "text": "Using the ZF2 Router\n\n\nzend-mvc\n provides a router\nimplementation; for HTTP applications, the default used in ZF2 applications is\n\nZend\\Mvc\\Router\\Http\\TreeRouteStack\n, which can compose a number of different\nroutes of differing types in order to perform routing.\n\n\nThe ZF2 bridge we provide, \nZend\\Expressive\\Router\\ZendRouter\n, uses the\n\nTreeRouteStack\n, and injects \nSegment\n routes to it; these are in turn injected\nwith \nMethod\n routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.\n\n\nIf you instantiate it with no arguments, it will create an empty\n\nTreeRouteStack\n. Thus, the simplest way to start with this router is:\n\n\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$app = AppFactory::create(null, new ZendRouter());\n\n\n\nThe \nTreeRouteStack\n offers some unique features:\n\n\n\n\nRoute \"prototypes\". These are essentially like child routes that must \nalso\n\n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.\n\n\nBase URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.\n\n\n\n\nTo specify these, you need access to the underlying \nTreeRouteStack\n\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling the ZF2 Router\n\n\nTo use the ZF2 router, you will need to install the zend-mvc router integration:\n\n\n$ composer require zendframework/zend-expressive-zendrouter\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\ZendRouter\n instance\nwith no arguments; it will create the underlying zend-mvc routing objects\nrequired and compose them for you:\n\n\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$router = new ZendRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the zend-mvc router setup and configuration,\nyou can create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\ZendRouter\n during instantiation.\n\n\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\nuse Zend\\Mvc\\Router\\Http\\TreeRouteStack;\n\n$zendRouter = new TreeRouteStack();\n$zendRouter->addPrototypes(/* ... */);\n$zendRouter->setBaseUrl(/* ... */);\n\n$router = new Zf2Bridge($zendRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your zend-mvc router implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\ZendRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return ZendRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new ZendRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\ZendRouter::class\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n\n  instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\ZendRouter\n instance composing the\n  \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n instance.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n// in src/App/Container/TreeRouteStackFactory.php:\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Http\\Mvc\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router->addPrototypes(/* ... */);\n        $router->setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class));\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    Zend\\Mvc\\Router\\Http\\TreeRouteStack::class,\n    App\\Container\\TreeRouteStackFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        Zend\\Mvc\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\TreeRouteStackFactory;\nuse Application\\Container\\ZfRouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop;\n\n$container = new PimpleInterop();\n$container[Zend\\Mvc\\Router\\Http\\TreeRouteStackFactory::class] = new TreeRouteStackFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Using the ZF2 Router"
        },
        {
            "location": "/features/router/zf2/#using-the-zf2-router",
            "text": "zend-mvc  provides a router\nimplementation; for HTTP applications, the default used in ZF2 applications is Zend\\Mvc\\Router\\Http\\TreeRouteStack , which can compose a number of different\nroutes of differing types in order to perform routing.  The ZF2 bridge we provide,  Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects  Segment  routes to it; these are in turn injected\nwith  Method  routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.  If you instantiate it with no arguments, it will create an empty TreeRouteStack . Thus, the simplest way to start with this router is:  use Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$app = AppFactory::create(null, new ZendRouter());  The  TreeRouteStack  offers some unique features:   Route \"prototypes\". These are essentially like child routes that must  also \n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.  Base URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.   To specify these, you need access to the underlying  TreeRouteStack \ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.",
            "title": "Using the ZF2 Router"
        },
        {
            "location": "/features/router/zf2/#installing-the-zf2-router",
            "text": "To use the ZF2 router, you will need to install the zend-mvc router integration:  $ composer require zendframework/zend-expressive-zendrouter",
            "title": "Installing the ZF2 Router"
        },
        {
            "location": "/features/router/zf2/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\ZendRouter  instance\nwith no arguments; it will create the underlying zend-mvc routing objects\nrequired and compose them for you:  use Zend\\Expressive\\Router\\ZendRouter;\n\n$router = new ZendRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/features/router/zf2/#programmatic-creation",
            "text": "If you need greater control over the zend-mvc router setup and configuration,\nyou can create the instances necessary and inject them into Zend\\Expressive\\Router\\ZendRouter  during instantiation.  use Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\nuse Zend\\Mvc\\Router\\Http\\TreeRouteStack;\n\n$zendRouter = new TreeRouteStack();\n$zendRouter->addPrototypes(/* ... */);\n$zendRouter->setBaseUrl(/* ... */);\n\n$router = new Zf2Bridge($zendRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/features/router/zf2/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/features/router/zf2/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your zend-mvc router implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/features/router/zf2/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\ZendRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return ZendRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new ZendRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);  And in Pimple:  $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\ZendRouter::class\n);",
            "title": "Basic Router"
        },
        {
            "location": "/features/router/zf2/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Zend\\Mvc\\Router\\Http\\TreeRouteStack \n  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\ZendRouter  instance composing the\n   Zend\\Mvc\\Router\\Http\\TreeRouteStack  instance.   Sound difficult? It's not; we've essentially done it above already!  // in src/App/Container/TreeRouteStackFactory.php:\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Http\\Mvc\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router->addPrototypes(/* ... */);\n        $router->setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class));\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    Zend\\Mvc\\Router\\Http\\TreeRouteStack::class,\n    App\\Container\\TreeRouteStackFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        Zend\\Mvc\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\TreeRouteStackFactory;\nuse Application\\Container\\ZfRouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop;\n\n$container = new PimpleInterop();\n$container[Zend\\Mvc\\Router\\Http\\TreeRouteStackFactory::class] = new TreeRouteStackFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/features/template/intro/",
            "text": "Templating\n\n\nBy default, no middleware in Expressive is templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.\n\n\nWe do, however, provide abstraction for templating via the interface\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n, which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:\n\n\n\n\nAll adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation \nnamespace::template\n when rendering.\n\n\nAdapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).\n\n\nAdapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.\n\n\nAdapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.\n\n\n\n\nIn this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.\n\n\nWe currently support:\n\n\n\n\nPlates\n\n\nTwig\n\n\nzend-view\n\n\n\n\nEach has an associated container factory; details are found in the\n\nfactories documentation\n.",
            "title": "Introduction"
        },
        {
            "location": "/features/template/intro/#templating",
            "text": "By default, no middleware in Expressive is templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.  We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:   All adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation  namespace::template  when rendering.  Adapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).  Adapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.  Adapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.   In this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.  We currently support:   Plates  Twig  zend-view   Each has an associated container factory; details are found in the factories documentation .",
            "title": "Templating"
        },
        {
            "location": "/features/template/interface/",
            "text": "The Template Renderer Interface\n\n\nExpressive defines \nZend\\Expressive\\Template\\TemplateRendererInterface\n, which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param string $name\n     * @param array|object $params\n     * @return string\n     */\n    public function render($name, $params = []);\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     *\n     * @param string $path\n     * @param string $namespace\n     */\n    public function addPath($path, $namespace = null);\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths();\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param string $param Param name.\n     * @param mixed $value\n     */\n    public function addDefaultParam($templateName, $param, $value);\n}\n\n\n\n\n\nNamespaces\n\n\nUnfortunately, namespace syntax varies between different template engine\nimplementations. As an example:\n\n\n\n\nPlates uses the syntax \nnamespace::template\n.\n\n\nTwig uses the syntax \n@namespace/template\n.\n\n\nzend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.\n\n\n\n\nTo make different engines compatible, we require implementations to support\nthe syntax \nnamespace::template\n (where \nnamespace::\n is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.\n\n\nWhen using a \nTemplateRendererInterface\n implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.\n\n\n\n\nPaths\n\n\nMost template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the \naddPath()\n method to do so:\n\n\n$renderer->addPath('templates');\n\n\n\nTemplate engines adapted for zend-expressive are also required to allow\n\nnamespacing\n templates; when adding a path, you specify the template\n\nnamespace\n that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.\n\n\n// Resolves to a path registered with the namespace \"error\";\n// this example is specific to the Plates engine.\n$content = $renderer->render('error::404');\n\n\n\nYou can provide a namespace when registering a path via an optional second\nargument:\n\n\n// Registers the \"error\" namespace to the path \"templates/error/\"\n$renderer->addPath('templates/error/', 'error');\n\n\n\nRendering\n\n\nTo render a template, call the \nrender()\n method. This method requires the name\nof a template as the first argument:\n\n\n$content = $renderer->render('foo');\n\n\n\nYou can specify a namespaced template using the syntax \nnamespace::template\n;\nthe \ntemplate\n segment of the template name may use additional directory\nseparators when necessary.\n\n\nOne key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to \nrender()\n:\n\n\n$content = $renderer->render('message', [\n    'greeting'  => 'Hello',\n    'recipient' => 'World',\n]);\n\n\n\nIt is up to the underlying template engine to determine how to perform the\ninjections.\n\n\nDefault params\n\n\nThe \nTemplateRendererInterface\n defines the method \naddDefaultParam()\n. This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:\n\n\npublic function addDefaultParam($templateName, $param, $value)\n\n\n\nIf you want a parameter to be used for \nevery\n template, you can specify the\nconstant \nTemplateRendererInterface::TEMPLATE_ALL\n for the \n$templateName\n\nparameter.\n\n\nWhen rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:\n\n\n\n\nDefault parameters specified for all templates.\n\n\nDefault parameters specified for the template specified at rendering.\n\n\nParameters specified when rendering.\n\n\n\n\nAs an example, if we did the following:\n\n\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer->addDefaultParam('example', 'foo', 'template default foo');\n$renderer->addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer->render('example', [\n    'foo' => 'override',\n]);\n\n\n\nThen we can expect the following substitutions will occur when rendering:\n\n\n\n\nReferences to the \"foo\" variable will contain \"override\".\n\n\nReferences to the \"bar\" variable will contain \"template default bar\".\n\n\nReferences to the \"baz\" variable will contain \"bat\".\n\n\n\n\n\n\nSupport for default params\n\n\nThe support for default params will often be renderer-specific. The reason is\nbecause the \nrender()\n signature does not specify a type for \n$params\n, in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given \n$params\n argument does not support it.\n\n\nAt the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.",
            "title": "Template Renderer Interface"
        },
        {
            "location": "/features/template/interface/#the-template-renderer-interface",
            "text": "Expressive defines  Zend\\Expressive\\Template\\TemplateRendererInterface , which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:  namespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param string $name\n     * @param array|object $params\n     * @return string\n     */\n    public function render($name, $params = []);\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     *\n     * @param string $path\n     * @param string $namespace\n     */\n    public function addPath($path, $namespace = null);\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths();\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param string $param Param name.\n     * @param mixed $value\n     */\n    public function addDefaultParam($templateName, $param, $value);\n}",
            "title": "The Template Renderer Interface"
        },
        {
            "location": "/features/template/interface/#namespaces",
            "text": "Unfortunately, namespace syntax varies between different template engine\nimplementations. As an example:   Plates uses the syntax  namespace::template .  Twig uses the syntax  @namespace/template .  zend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.   To make different engines compatible, we require implementations to support\nthe syntax  namespace::template  (where  namespace::  is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.  When using a  TemplateRendererInterface  implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.",
            "title": "Namespaces"
        },
        {
            "location": "/features/template/interface/#paths",
            "text": "Most template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the  addPath()  method to do so:  $renderer->addPath('templates');  Template engines adapted for zend-expressive are also required to allow namespacing  templates; when adding a path, you specify the template namespace  that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.  // Resolves to a path registered with the namespace \"error\";\n// this example is specific to the Plates engine.\n$content = $renderer->render('error::404');  You can provide a namespace when registering a path via an optional second\nargument:  // Registers the \"error\" namespace to the path \"templates/error/\"\n$renderer->addPath('templates/error/', 'error');",
            "title": "Paths"
        },
        {
            "location": "/features/template/interface/#rendering",
            "text": "To render a template, call the  render()  method. This method requires the name\nof a template as the first argument:  $content = $renderer->render('foo');  You can specify a namespaced template using the syntax  namespace::template ;\nthe  template  segment of the template name may use additional directory\nseparators when necessary.  One key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to  render() :  $content = $renderer->render('message', [\n    'greeting'  => 'Hello',\n    'recipient' => 'World',\n]);  It is up to the underlying template engine to determine how to perform the\ninjections.",
            "title": "Rendering"
        },
        {
            "location": "/features/template/interface/#default-params",
            "text": "The  TemplateRendererInterface  defines the method  addDefaultParam() . This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:  public function addDefaultParam($templateName, $param, $value)  If you want a parameter to be used for  every  template, you can specify the\nconstant  TemplateRendererInterface::TEMPLATE_ALL  for the  $templateName \nparameter.  When rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:   Default parameters specified for all templates.  Default parameters specified for the template specified at rendering.  Parameters specified when rendering.   As an example, if we did the following:  $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer->addDefaultParam('example', 'foo', 'template default foo');\n$renderer->addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer->render('example', [\n    'foo' => 'override',\n]);  Then we can expect the following substitutions will occur when rendering:   References to the \"foo\" variable will contain \"override\".  References to the \"bar\" variable will contain \"template default bar\".  References to the \"baz\" variable will contain \"bat\".",
            "title": "Default params"
        },
        {
            "location": "/features/template/interface/#support-for-default-params",
            "text": "The support for default params will often be renderer-specific. The reason is\nbecause the  render()  signature does not specify a type for  $params , in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given  $params  argument does not support it.  At the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.",
            "title": "Support for default params"
        },
        {
            "location": "/features/template/middleware/",
            "text": "Templated Middleware\n\n\nThe primary use case for templating is within middleware, to provide templated\nresponses. To do this, you will:\n\n\n\n\nInject an instance of \nZend\\Expressive\\Template\\TemplateRendererInterface\n into your\n  middleware.\n\n\nPotentially add paths to the templating instance.\n\n\nRender a template.\n\n\nAdd the results of rendering to your response.\n\n\n\n\nInjecting a TemplateRendererInterface\n\n\nWe encourage the use of dependency injection. As such, we recommend writing your\nmiddleware to accept the \nTemplateRendererInterface\n via either the constructor or a\nsetter. As an example:\n\n\nnamespace Acme\\Blog;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware implements MiddlewareInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // ...\n    }\n}\n\n\n\nThis will necessitate having a factory for your middleware:\n\n\nnamespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryMiddleware;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryMiddleware(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}\n\n\n\nAnd, of course, you'll need to tell your container to use the factory; see the\n\ncontainer documentation\n for more information on how you\nmight accomplish that.\n\n\nConsuming templates\n\n\nNow that we have the templating engine injected into our middleware, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:\n\n\nnamespace Acme\\Blog;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware implements MiddlewareInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'entry' => $entry,\n            ])\n        );\n    }\n}",
            "title": "Templated Middleware"
        },
        {
            "location": "/features/template/middleware/#templated-middleware",
            "text": "The primary use case for templating is within middleware, to provide templated\nresponses. To do this, you will:   Inject an instance of  Zend\\Expressive\\Template\\TemplateRendererInterface  into your\n  middleware.  Potentially add paths to the templating instance.  Render a template.  Add the results of rendering to your response.",
            "title": "Templated Middleware"
        },
        {
            "location": "/features/template/middleware/#injecting-a-templaterendererinterface",
            "text": "We encourage the use of dependency injection. As such, we recommend writing your\nmiddleware to accept the  TemplateRendererInterface  via either the constructor or a\nsetter. As an example:  namespace Acme\\Blog;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware implements MiddlewareInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // ...\n    }\n}  This will necessitate having a factory for your middleware:  namespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryMiddleware;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryMiddleware(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}  And, of course, you'll need to tell your container to use the factory; see the container documentation  for more information on how you\nmight accomplish that.",
            "title": "Injecting a TemplateRendererInterface"
        },
        {
            "location": "/features/template/middleware/#consuming-templates",
            "text": "Now that we have the templating engine injected into our middleware, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:  namespace Acme\\Blog;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware implements MiddlewareInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'entry' => $entry,\n            ])\n        );\n    }\n}",
            "title": "Consuming templates"
        },
        {
            "location": "/features/template/plates/",
            "text": "Using Plates\n\n\nPlates\n is a native PHP template system\nmaintained by \nThe League of Extraordinary Packages\n.\nit provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Plates via\n\nZend\\Expressive\\Plates\\PlatesRenderer\n.\n\n\nInstalling Plates\n\n\nTo use the Plates wrapper, you must install the Plates integration:\n\n\n$ composer require zendframework/zend-expressive-platesrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Plates\\PlatesRenderer\n will create\nan instance of the Plates engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Plates\\PlatesRenderer\n constructor:\n\n\nuse League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates->addFolder('error', 'templates/error/');\n$plates->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new PlatesRenderer($plates);",
            "title": "Using Plates"
        },
        {
            "location": "/features/template/plates/#using-plates",
            "text": "Plates  is a native PHP template system\nmaintained by  The League of Extraordinary Packages .\nit provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer .",
            "title": "Using Plates"
        },
        {
            "location": "/features/template/plates/#installing-plates",
            "text": "To use the Plates wrapper, you must install the Plates integration:  $ composer require zendframework/zend-expressive-platesrenderer",
            "title": "Installing Plates"
        },
        {
            "location": "/features/template/plates/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\Plates\\PlatesRenderer  will create\nan instance of the Plates engine, which it will then proxy to.  use Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Plates\\PlatesRenderer  constructor:  use League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates->addFolder('error', 'templates/error/');\n$plates->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new PlatesRenderer($plates);",
            "title": "Using the wrapper"
        },
        {
            "location": "/features/template/twig/",
            "text": "Using Twig\n\n\nTwig\n is a template language and engine provided\nas a standalone component by SensioLabs. It provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Twig via\n\nZend\\Expressive\\Twig\\TwigRenderer\n.\n\n\nInstalling Twig\n\n\nTo use the Twig wrapper, you must first install the Twig integration:\n\n\n$ composer require zendframework/zend-expressive-twigrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Twig\\TwigRenderer\n will create\nan instance of the Twig engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Twig\\TwigRenderer\n constructor:\n\n\nuse Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig->addExtension(new CustomExtension());\n$twig->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);\n\n\n\nIncluded extensions and functions\n\n\nThe included Twig extension adds support for url generation. The extension is\nautomatically activated if the \nUrlHelper\n and\n\nServerUrlHelper\n are registered with the\ncontainer.\n\n\nThe following template functions are exposed:\n\n\n\n\npath\n: Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.\n\n\n\n\n{{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3\n\n\n\n\n\nurl\n: Render the absolute url for a given route with its route parameters,\n  query string arguments, and fragment. If there is no route, it returns the\n  current url.\n\n\n\n\n{{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }}\nGenerates: http://example.com/article/3?foo=bar#fragment\n\n\n\n\n\nabsolute_url\n: Render the absolute url from a given path. If the path is\n  empty, it returns the current url.\n\n\n\n\n{{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something\n\n\n\n\n\nasset\n Render an (optionally versioned) asset url.\n\n\n\n\n{{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3\n\n\n\nTo get the absolute url for an asset:\n\n\n{{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3\n\n\n\nConfiguration\n\n\nThe following details configuration specific to Twig, as consumed by the\n\nTwigRendererFactory\n:\n\n\nreturn [\n    'templates' => [\n        'extension' => 'file extension used by templates; defaults to html.twig',\n        'paths' => [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' => [\n        'cache_dir' => 'path to cached templates',\n        'assets_url' => 'base URL for assets',\n        'assets_version' => 'base version for assets',\n        'extensions' => [\n            // extension service names or instances\n        ],\n        'globals' => [\n            // Global variables passed to twig templates\n            'ga_tracking' => 'UA-XXXXX-X'\n        ],\n    ],\n];\n\n\n\nWhen specifying the \ntwig.extensions\n values, always use fully qualified class\nnames or actual extension instances to ensure compatibility with any version of\nTwig used. Version 2 of Twig \nrequires\n that a fully qualified class name is\nused, and not a short-name alias.",
            "title": "Using Twig"
        },
        {
            "location": "/features/template/twig/#using-twig",
            "text": "Twig  is a template language and engine provided\nas a standalone component by SensioLabs. It provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer .",
            "title": "Using Twig"
        },
        {
            "location": "/features/template/twig/#installing-twig",
            "text": "To use the Twig wrapper, you must first install the Twig integration:  $ composer require zendframework/zend-expressive-twigrenderer",
            "title": "Installing Twig"
        },
        {
            "location": "/features/template/twig/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\Twig\\TwigRenderer  will create\nan instance of the Twig engine, which it will then proxy to.  use Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Twig\\TwigRenderer  constructor:  use Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig->addExtension(new CustomExtension());\n$twig->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);",
            "title": "Using the wrapper"
        },
        {
            "location": "/features/template/twig/#included-extensions-and-functions",
            "text": "The included Twig extension adds support for url generation. The extension is\nautomatically activated if the  UrlHelper  and ServerUrlHelper  are registered with the\ncontainer.  The following template functions are exposed:   path : Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.   {{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3   url : Render the absolute url for a given route with its route parameters,\n  query string arguments, and fragment. If there is no route, it returns the\n  current url.   {{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }}\nGenerates: http://example.com/article/3?foo=bar#fragment   absolute_url : Render the absolute url from a given path. If the path is\n  empty, it returns the current url.   {{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something   asset  Render an (optionally versioned) asset url.   {{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3  To get the absolute url for an asset:  {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3",
            "title": "Included extensions and functions"
        },
        {
            "location": "/features/template/twig/#configuration",
            "text": "The following details configuration specific to Twig, as consumed by the TwigRendererFactory :  return [\n    'templates' => [\n        'extension' => 'file extension used by templates; defaults to html.twig',\n        'paths' => [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' => [\n        'cache_dir' => 'path to cached templates',\n        'assets_url' => 'base URL for assets',\n        'assets_version' => 'base version for assets',\n        'extensions' => [\n            // extension service names or instances\n        ],\n        'globals' => [\n            // Global variables passed to twig templates\n            'ga_tracking' => 'UA-XXXXX-X'\n        ],\n    ],\n];  When specifying the  twig.extensions  values, always use fully qualified class\nnames or actual extension instances to ensure compatibility with any version of\nTwig used. Version 2 of Twig  requires  that a fully qualified class name is\nused, and not a short-name alias.",
            "title": "Configuration"
        },
        {
            "location": "/features/template/zend-view/",
            "text": "Using zend-view\n\n\nzend-view\n provides a native PHP\ntemplate system via its \nPhpRenderer\n, and is maintained by Zend Framework. It\nprovides:\n\n\n\n\nLayout facilities.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for zend-view's\n\nPhpRenderer\n via \nZend\\Expressive\\ZendView\\ZendViewRenderer\n.\n\n\nInstalling zend-view\n\n\nTo use the zend-view wrapper, you must first install the zend-view integration:\n\n\n$ composer require zendframework/zend-expressive-zendviewrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\ZendView\\ZendViewRenderer\n will create\nan instance of the \nPhpRenderer\n, which it will then proxy to.\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\ZendView\\ZendViewRenderer\n constructor:\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver->attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver->attach(\n    (new Resolver\\TemplatePathStack())\n    ->setPaths(include 'config/template_paths.php')\n);\n$renderer->setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);\n\n\n\n\n\nNamespaced path resolving\n\n\nExpressive defines a custom zend-view resolver,\n\nZend\\Expressive\\ZendView\\NamespacedPathStackResolver\n. This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the \nnamespace::template\n notation\nrequired of \nTemplateRendererInterface\n implementations.\n\n\nThe \nZendView\n adapter ensures that:\n\n\n\n\nAn \nAggregateResolver\n is registered with the renderer. If the registered\n  resolver is not an \nAggregateResolver\n, it creates one and adds the original\n  resolver to it.\n\n\nA \nNamespacedPathStackResolver\n is registered with the \nAggregateResolver\n, at\n  a low priority (0), ensuring attempts to resolve hit it later.\n\n\n\n\nWith resolvers such as the \nTemplateMapResolver\n, you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!\n\n\n\n\nLayouts\n\n\nUnlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:\n\n\n\n\nYou may pass a layout template name or \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout as the second argument to the constructor.\n\n\nYou may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.\n\n\n\n\nIn each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.\n\n\n\n\nSince 1.3: You may also pass a boolean \nfalse\n value to either\n  \naddDefaultParam()\n or via the template variables for the \nlayout\n key; doing\n  so will disable the layout.\n\n\n\n\nLayout name passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');\n\n\n\nLayout view model passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/prod/',\n]);\n$layout->setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);\n\n\n\nProvide a layout name when rendering\n\n\n$content = $renderer->render('blog/entry', [\n    'layout' => 'layout::blog',\n    'entry'  => $entry,\n]);\n\n\n\nProvide a layout view model when rendering\n\n\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/blog/',\n]);\n$layout->setTemplate('layout::layout');\n\n$content = $renderer->render('blog/entry', [\n    'layout' => $layout,\n    'entry'  => $entry,\n]);\n\n\n\nHelpers\n\n\nExpressive provides overrides of specific view helpers in order to better\nintegrate with PSR-7. These include:\n\n\n\n\nZend\\Expressive\\ZendView\\UrlHelper\n. This helper consumes the\n  application's \nZend\\Expressive\\Router\\RouterInterface\n instance in order\n  to generate URIs. Its signature is:\n  \nurl($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = [])\n\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n. This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  Its signature is: \nserverUrl($path = null)\n.\n\n\n\n\nTo use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:\n\n\n$serverUrlHelper->setUri($request->getUri());\n\n\n\nWe recommend doing this within a pre-pipeline middleware.\n\n\nRecommendations\n\n\nWe recommend the following practices when using the zend-view adapter:\n\n\n\n\nIf using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.\n\n\nWhile we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.",
            "title": "Using zend-view"
        },
        {
            "location": "/features/template/zend-view/#using-zend-view",
            "text": "zend-view  provides a native PHP\ntemplate system via its  PhpRenderer , and is maintained by Zend Framework. It\nprovides:   Layout facilities.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for zend-view's PhpRenderer  via  Zend\\Expressive\\ZendView\\ZendViewRenderer .",
            "title": "Using zend-view"
        },
        {
            "location": "/features/template/zend-view/#installing-zend-view",
            "text": "To use the zend-view wrapper, you must first install the zend-view integration:  $ composer require zendframework/zend-expressive-zendviewrenderer",
            "title": "Installing zend-view"
        },
        {
            "location": "/features/template/zend-view/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\ZendView\\ZendViewRenderer  will create\nan instance of the  PhpRenderer , which it will then proxy to.  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\ZendView\\ZendViewRenderer  constructor:  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver->attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver->attach(\n    (new Resolver\\TemplatePathStack())\n    ->setPaths(include 'config/template_paths.php')\n);\n$renderer->setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);",
            "title": "Using the wrapper"
        },
        {
            "location": "/features/template/zend-view/#namespaced-path-resolving",
            "text": "Expressive defines a custom zend-view resolver, Zend\\Expressive\\ZendView\\NamespacedPathStackResolver . This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the  namespace::template  notation\nrequired of  TemplateRendererInterface  implementations.  The  ZendView  adapter ensures that:   An  AggregateResolver  is registered with the renderer. If the registered\n  resolver is not an  AggregateResolver , it creates one and adds the original\n  resolver to it.  A  NamespacedPathStackResolver  is registered with the  AggregateResolver , at\n  a low priority (0), ensuring attempts to resolve hit it later.   With resolvers such as the  TemplateMapResolver , you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!",
            "title": "Namespaced path resolving"
        },
        {
            "location": "/features/template/zend-view/#layouts",
            "text": "Unlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:   You may pass a layout template name or  Zend\\View\\Model\\ModelInterface \n  instance representing the layout as the second argument to the constructor.  You may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a  Zend\\View\\Model\\ModelInterface \n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.   In each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.   Since 1.3: You may also pass a boolean  false  value to either\n   addDefaultParam()  or via the template variables for the  layout  key; doing\n  so will disable the layout.",
            "title": "Layouts"
        },
        {
            "location": "/features/template/zend-view/#layout-name-passed-to-constructor",
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');",
            "title": "Layout name passed to constructor"
        },
        {
            "location": "/features/template/zend-view/#layout-view-model-passed-to-constructor",
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/prod/',\n]);\n$layout->setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);",
            "title": "Layout view model passed to constructor"
        },
        {
            "location": "/features/template/zend-view/#provide-a-layout-name-when-rendering",
            "text": "$content = $renderer->render('blog/entry', [\n    'layout' => 'layout::blog',\n    'entry'  => $entry,\n]);",
            "title": "Provide a layout name when rendering"
        },
        {
            "location": "/features/template/zend-view/#provide-a-layout-view-model-when-rendering",
            "text": "use Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/blog/',\n]);\n$layout->setTemplate('layout::layout');\n\n$content = $renderer->render('blog/entry', [\n    'layout' => $layout,\n    'entry'  => $entry,\n]);",
            "title": "Provide a layout view model when rendering"
        },
        {
            "location": "/features/template/zend-view/#helpers",
            "text": "Expressive provides overrides of specific view helpers in order to better\nintegrate with PSR-7. These include:   Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the\n  application's  Zend\\Expressive\\Router\\RouterInterface  instance in order\n  to generate URIs. Its signature is:\n   url($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = [])  Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  Its signature is:  serverUrl($path = null) .   To use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:  $serverUrlHelper->setUri($request->getUri());  We recommend doing this within a pre-pipeline middleware.",
            "title": "Helpers"
        },
        {
            "location": "/features/template/zend-view/#recommendations",
            "text": "We recommend the following practices when using the zend-view adapter:   If using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.  While we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.",
            "title": "Recommendations"
        },
        {
            "location": "/features/error-handling/",
            "text": "Error Handling\n\n\nError handling has changed from version 1 to version 2. This document details\nboth the current (version 2) error handling, as well as version 1. The immediate\nsections following detail version 2; \njump to the version 1 section\n\nif you need that information.\n\n\nHandling exceptions and errors\n\n\nWe recommend that your code raise exceptions for conditions where it cannot\ngracefully recover. Additionally, we recommend that you have a reasonable PHP\n\nerror_reporting\n setting that includes warnings and fatal errors:\n\n\nerror_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE);\n\n\n\nIf you follow these guidelines, you can then write or use middleware that does\nthe following:\n\n\n\n\nsets an error handler that converts PHP errors to \nErrorException\n instances.\n\n\nwraps execution of the delegate (\n$delegate->process()\n) with a try/catch block.\n\n\n\n\nAs an example:\n\n\nfunction ($request, DelegateInterface $delegate)\n{\n    set_error_handler(function ($errno, $errstr, $errfile, $errline) {\n        if (! (error_reporting() & $errno)) {\n            // Error is not in mask\n            return;\n        }\n        throw new ErrorException($errstr, 0, $errno, $errfile, $errline);\n    });\n\n    try {\n        $response = $delegate->process($request);\n        return $response;\n    } catch (Throwable $e) {\n    } catch (Exception $e) {\n    }\n\n    restore_error_handler();\n\n    $response = new TextResponse(sprintf(\n        \"[%d] %s\\n\\n%s\",\n        $e->getCode(),\n        $e->getMessage(),\n        $e->getTraceAsString()\n    ), 500);\n}\n\n\n\nYou would then pipe this as the outermost (or close to outermost) layer of your\napplication:\n\n\n$app->pipe($errorMiddleware);\n\n\n\nSo that you do not need to do this, we provide an error handler for you, via\nzend-stratigility: \nZend\\Stratigility\\Middleware\\ErrorHandler\n.\n\n\nThis implementation allows you to both:\n\n\n\n\nprovide a response generator, invoked when an error is caught; and\n\n\nregister listeners to trigger when errors are caught.\n\n\n\n\nWe provide the factory \nZend\\Expressive\\Container\\ErrorHandlerFactory\n for\ngenerating the instance; it should be mapped to the service\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n.\n\n\nWe provide two error response generators for you:\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n, which optionally will\n  accept a \nZend\\Expressive\\Template\\TemplateRendererInterface\n instance, and a\n  template name. When present, these will be used to generate response content;\n  otherwise, a plain text response is generated that notes the request method\n  and URI.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator\n, which uses\n  \nwhoops\n to present detailed exception\n  and request information; this implementation is intended for development\n  purposes.\n\n\n\n\n\n\nEach also has an accompanying factory for generating the instance:\n\n\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory\n\n\nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory\n\n\n\n\nMap the service \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n to one of\nthese two factories in your configuration:\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];\n\n\n\n\n\nUse development mode configuration to enable whoops\n\n\nYou can specify the above in one of your \nconfig/autoload/*.global.php\n files,\nto ensure you have a production-capable error response generator.\n\n\nIf you are using \nzf-development-mode\n\nin your application (which is provided by default in the Expressive 2.0\nskeleton), you can toggle usage of whoops by adding configuration to the file\n\nconfig/autoload/development.local.php.dist\n:\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Middleware\\WhoopsErrorResponseGenerator::class => Container\\WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];\n\n\n\nWhen you enable development mode, whoops will then be enabled; when you\ndisable development mode, you'll be using your production generator.\n\n\nIf you are not using zf-development-mode, you can define a\n\nconfig/autoload/*.local.php\n file with the above configuration whenever you\nwant to enable whoops.\n\n\n\n\nListening for errors\n\n\nWhen errors occur, you may want to \nlisten\n for them in order to provide\nfeatures such as logging. \nZend\\Stratigility\\Middleware\\ErrorHandler\n provides\nthe ability to do so via its \nattachListener()\n method.\n\n\nThis method accepts a callable with the following signature:\n\n\nfunction (\n    Throwable|Exception $error,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\nThe response provided is the response returned by your error response generator,\nallowing the listener the ability to introspect the generated response as well.\n\n\nAs an example, you could create a logging listener as follows:\n\n\nnamespace Acme;\n\nuse Exception;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass LoggingErrorListener\n{\n    /**\n     * Log format for messages:\n     *\n     * STATUS [METHOD] path: message\n     */\n    const LOG_FORMAT = '%d [%s] %s: %s';\n\n    private $logger;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke($error, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $this->logger->error(sprintf(\n            self::LOG_FORMAT,\n            $response->getStatusCode(),\n            $request->getMethod(),\n            (string) $request->getUri(),\n            $error->getMessage()\n        ));\n    }\n}\n\n\n\nYou could then use a \ndelegator factory\n to\ncreate your logger listener and attach it to your error handler:\n\n\nnamespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass LoggingErrorListenerDelegatorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $name\n     * @param callable $callback\n     * @return ErrorHandler\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback)\n    {\n        $listener = new LoggingErrorListener($container->get(LoggerInterface::class));\n        $errorHandler = $callback();\n        $errorHandler->attachListener($listener);\n        return $errorHandler;\n    }\n}\n\n\n\nHandling more specific error types\n\n\nYou could also write more specific error handlers. As an example, you might want\nto catch \nUnauthorizedException\n instances specifically, and display a login\npage:\n\n\nfunction ($request, DelegateInterface $delegate) use ($renderer)\n{\n    try {\n        $response = $delegate->process($request);\n        return $response;\n    } catch (UnauthorizedException $e) {\n    }\n\n    return new HtmlResponse(\n        $renderer->render('error::unauthorized'),\n        401\n    );\n}\n\n\n\nYou could then push this into a middleware pipe only when it's needed:\n\n\n$app->get('/dashboard', [\n    $unauthorizedHandlerMiddleware,\n    $middlewareThatChecksForAuthorization,\n    $middlewareBehindAuthorizationWall,\n], 'dashboard');\n\n\n\nDefault delegates\n\n\nZend\\Expressive\\Application\n manages an internal middleware pipeline; when you\ncall \n$delegate->process()\n (v2) or \n$next()\n (v1 or legacy double-pass\nmiddleware), \nApplication\n is popping off the next middleware in the queue and\ndispatching it.\n\n\nWhat happens when that queue is exhausted?\n\n\nThat situation indicates an error condition: no middleware was capable of\nreturning a response. This could either mean a problem with the request (HTTP\n400 \"Bad Request\" status) or inability to route the request (HTTP 404 \"Not\nFound\" status).\n\n\nIn order to report that information, \nZend\\Expressive\\Application\n composes a\n\"default delegate\": a delegate it will invoke once the queue is exhausted and no\nresponse returned. By default, it uses a custom implementation,\n\nZend\\Expressive\\Delegate\\NotFoundDelegate\n, which will report a 404 response,\noptionally using a composed template renderer to do so.\n\n\nWe provide a factory, \nZend\\Expressive\\Container\\NotFoundDelegateFactory\n, for\ncreating an instance, and this should be mapped to the\n\nZend\\Expressive\\Delegate\\NotFoundDelegate\n service, and aliased to the\n\nZend\\Expressive\\Delegate\\DefaultDelegate\n service:\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Delegate;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            'Zend\\Expressive\\Delegate\\DefaultDelegate' => Delegate\\NotFoundDelegate::class,\n        ],\n        'factories' => [\n            Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class,\n        ],\n    ],\n];\n\n\n\nThe factory will consume the following services:\n\n\n\n\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n (optional): if present,\n  the renderer will be used to render a template for use as the response\n  content.\n\n\n\n\n\n\nconfig\n (optional): if present, it will use the\n  \n$config['zend-expressive']['error_handler']['template_404']\n value\n  as the template to use when rendering; if not provided, defaults to\n  \nerror::404\n.\n\n\n\n\n\n\nIf you wish to provide an alternate response status or use a canned response,\nyou should provide your own default delegate, and expose it via the\n\nZend\\Expressive\\Delegate\\DefaultDelegate\n service.\n\n\nPage not found\n\n\nError handlers work at the outermost layer, and are used to catch exceptions and\nerrors in your application. At the \ninnermost\n layer of your application, you\nshould ensure you have middleware that is \nguaranteed\n to return a response;\nthis will prevent the default delegate from needing to execute by ensuring that\nthe middleware queue never fully depletes. This in turn allows you to fully\ncraft what sort of response is returned.\n\n\nGenerally speaking, reaching the innermost middleware layer indicates that no\nmiddleware was capable of handling the request, and thus an HTTP 404 Not Found\ncondition.\n\n\nTo simplify such responses, we provide \nZend\\Expressive\\Middleware\\NotFoundHandler\n,\nwith an accompanying \nZend\\Expressive\\Container\\NotFoundHandlerFactory\n. This\nmiddleware composes and proxies to the \nNotFoundDelegate\n detailed in the\nprevious section, and, as such, requires that that service be present.\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Delegate;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'factories' => [\n        Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class,\n        Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class,\n    ],\n];\n\n\n\nWhen registered, you should then pipe it as the innermost layer of your\napplication:\n\n\n// A basic application:\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);\n\n\n\nVersion 1 error handling\n\n\n\n\nDeprecated!\n\n\nAs noted in the introduction to this page, this section details error handling\nunder version 1 of Expressive. We strongly recommend upgrading to version 2, in\nlarge part due to its more flexible approach to error handling.\n\n\nIn addition, be aware that both the final handlers and Stratigility 1.X error\nmiddleware are completely absent from Expressive 2.0; you \nwill\n need to\nmigrate your code at some point!\n\n\n\n\nExpressive 1 provides error handling out of the box, via zend-stratigility 1.X's \nFinalHandler\nimplementation\n.\nThis pseudo-middleware is executed in the following conditions:\n\n\n\n\nIf the middleware stack is exhausted, and no middleware has returned a response.\n\n\nIf an error has been passed via \n$next()\n, but not handled by any error middleware.\n\n\n\n\nThe \nFinalHandler\n essentially tries to recover gracefully. In the case that no error was passed, it\ndoes the following:\n\n\n\n\nIf the response passed to it differs from the response provided at initialization, it will return\n  the response directly; the assumption is that some middleware along the way called \n$next()\n\n  with a new response.\n\n\nIf the response instances are identical, it checks to see if the body size has changed; if it has,\n  the assumption is that a middleware at some point has written to the response body.\n\n\nAt this point, it assumes no middleware was able to handle the request, and creates a 404\n  response, indicating \"Not Found.\"\n\n\n\n\nIn the event that an error \nwas\n passed, it does the following:\n\n\n\n\nIf \n$error\n is not an exception, it will use the response status if it already indicates an error\n  (ie., >= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase.\n\n\nIf \n$error\n \nis\n an exception, it will use the exception status if it already indicates an error\n  (ie., >= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase. If the \nFinalHandler\n was initialized with an option indicating that it is in\n  development mode, it writes the exception stack trace to the response body.\n\n\n\n\nThis workflow stays the same throughout zend-expressive. But sometimes, it's just not enough.\n\n\nTemplated Errors\n\n\nYou'll typically want to provide error messages in your site template. To do so, we provide\n\nZend\\Expressive\\TemplatedErrorHandler\n. This class is similar to the \nFinalHandler\n, but accepts,\noptionally, a \nZend\\Expressive\\Template\\TemplateRendererInterface\n instance, and template names to use for\n404 and general error conditions. This makes it a good choice for use in production.\n\n\nFirst, of course, you'll need to select a templating system and ensure you have\nthe appropriate dependencies installed; see the \ntemplating documentation\n\nfor information on what we support and how to install supported systems.\n\n\nOnce you have selected your templating system, you can setup the templated error\nhandler.\n\n\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\TemplatedErrorHandler;\n\n$plates = new PlatesRenderer();\n$plates->addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new TemplatedErrorHandler($plates, 'error::404', 'error::500');\n\n$app = new Application($router, $container, $finalHandler);\n\n\n\nThe above will use the templates \nerror::404\n and \nerror::500\n for 404 and general errors,\nrespectively, rendering them using our Plates template adapter.\n\n\nYou can also use the \nTemplatedErrorHandler\n as a substitute for the \nFinalHandler\n, without using\ntemplated capabilities, by omitting the \nTemplateRendererInterface\n instance when instantiating it. In this\ncase, the response message bodies will be empty, though the response status will reflect the error.\n\n\nSee the section titled \"Container Factories and Configuration\", below, for techniques on configuring\nthe \nTemplatedErrorHandler\n as your final handler within a container-based application.\n\n\nWhoops\n\n\nwhoops\n is a library for providing a more usable UI around\nexceptions and PHP errors. We provide integration with this library through\n\nZend\\Express\\WhoopsErrorHandler\n. This error handler derives from the \nTemplatedErrorHandler\n, and\nuses its features for 404 status and non-exception errors. For exceptions, however, it will return\nthe whoops output. As such, it is a good choice for use in development.\n\n\nTo use it, you must first install whoops:\n\n\n$ composer require filp/whoops\n\n\n\nThen you will need to provide the error handler a whoops runtime instance, as well as a\n\nWhoops\\Handler\\PrettyPageHandler\n instance. You can also optionally provide a \nTemplateRendererInterface\n\ninstance and template names, just as you would for a \nTemplatedErrorHandler\n.\n\n\nuse Whoops\\Handler\\PrettyPageHandler;\nuse Whoops\\Run as Whoops;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\WhoopsErrorHandler;\n\n$handler = new PrettyPageHandler();\n\n$whoops = new Whoops;\n$whoops->writeToOutput(false);\n$whoops->allowQuit(false);\n$whoops->pushHandler($handler);\n\n$plates = new PlatesRenderer();\n$plates->addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new WhoopsErrorHandler(\n    $whoops,\n    $handler,\n    $plates,\n    'error::404',\n    'error::500'\n);\n\n$app = new Application($router, $container, $finalHandler);\n\n// Register Whoops just before running the application, as otherwise it can\n// swallow bootstrap errors. \n$whoops->register();\n$app->run();\n\n\n\nThe calls to \nwriteToOutput(false)\n, \nallowQuit(false)\n, and \nregister()\n must be made to guarantee\nwhoops will interoperate well with zend-expressive.\n\n\nYou can add more handlers if desired.\n\n\nInternally, when an exception is discovered, zend-expressive adds some data to the whoops output,\nprimarily around the request information (URI, HTTP request method, route match attributes, etc.).\n\n\nSee the next section for techniques on configuring the \nWhoopsErrorHandler\n as your final handler\nwithin a container-based application.\n\n\nContainer Factories and Configuration\n\n\nThe above may feel like a bit much when creating your application. As such, we provide several\nfactories that work with \nPSR-11 Container\n\nimplementations to simplify setup.\n\n\nIn each case, you should register the selected error handler's factory as the service\n\nZend\\Expressive\\FinalHandler\n.\n\n\n\n\nFor the \nTemplatedErrorHandler\n, use \nZend\\Expressive\\Container\\TemplatedErrorHandlerFactory\n.\n\n\nFor the \nWhoopsErrorHandler\n, use \nZend\\Expressive\\Container\\WhoopsErrorHandlerFactory\n.",
            "title": "Error Handling"
        },
        {
            "location": "/features/error-handling/#error-handling",
            "text": "Error handling has changed from version 1 to version 2. This document details\nboth the current (version 2) error handling, as well as version 1. The immediate\nsections following detail version 2;  jump to the version 1 section \nif you need that information.",
            "title": "Error Handling"
        },
        {
            "location": "/features/error-handling/#handling-exceptions-and-errors",
            "text": "We recommend that your code raise exceptions for conditions where it cannot\ngracefully recover. Additionally, we recommend that you have a reasonable PHP error_reporting  setting that includes warnings and fatal errors:  error_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE);  If you follow these guidelines, you can then write or use middleware that does\nthe following:   sets an error handler that converts PHP errors to  ErrorException  instances.  wraps execution of the delegate ( $delegate->process() ) with a try/catch block.   As an example:  function ($request, DelegateInterface $delegate)\n{\n    set_error_handler(function ($errno, $errstr, $errfile, $errline) {\n        if (! (error_reporting() & $errno)) {\n            // Error is not in mask\n            return;\n        }\n        throw new ErrorException($errstr, 0, $errno, $errfile, $errline);\n    });\n\n    try {\n        $response = $delegate->process($request);\n        return $response;\n    } catch (Throwable $e) {\n    } catch (Exception $e) {\n    }\n\n    restore_error_handler();\n\n    $response = new TextResponse(sprintf(\n        \"[%d] %s\\n\\n%s\",\n        $e->getCode(),\n        $e->getMessage(),\n        $e->getTraceAsString()\n    ), 500);\n}  You would then pipe this as the outermost (or close to outermost) layer of your\napplication:  $app->pipe($errorMiddleware);  So that you do not need to do this, we provide an error handler for you, via\nzend-stratigility:  Zend\\Stratigility\\Middleware\\ErrorHandler .  This implementation allows you to both:   provide a response generator, invoked when an error is caught; and  register listeners to trigger when errors are caught.   We provide the factory  Zend\\Expressive\\Container\\ErrorHandlerFactory  for\ngenerating the instance; it should be mapped to the service Zend\\Stratigility\\Middleware\\ErrorHandler .  We provide two error response generators for you:    Zend\\Expressive\\Middleware\\ErrorResponseGenerator , which optionally will\n  accept a  Zend\\Expressive\\Template\\TemplateRendererInterface  instance, and a\n  template name. When present, these will be used to generate response content;\n  otherwise, a plain text response is generated that notes the request method\n  and URI.    Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator , which uses\n   whoops  to present detailed exception\n  and request information; this implementation is intended for development\n  purposes.    Each also has an accompanying factory for generating the instance:   Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory  Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory   Map the service  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  to one of\nthese two factories in your configuration:  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];",
            "title": "Handling exceptions and errors"
        },
        {
            "location": "/features/error-handling/#use-development-mode-configuration-to-enable-whoops",
            "text": "You can specify the above in one of your  config/autoload/*.global.php  files,\nto ensure you have a production-capable error response generator.  If you are using  zf-development-mode \nin your application (which is provided by default in the Expressive 2.0\nskeleton), you can toggle usage of whoops by adding configuration to the file config/autoload/development.local.php.dist :  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Middleware\\WhoopsErrorResponseGenerator::class => Container\\WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];  When you enable development mode, whoops will then be enabled; when you\ndisable development mode, you'll be using your production generator.  If you are not using zf-development-mode, you can define a config/autoload/*.local.php  file with the above configuration whenever you\nwant to enable whoops.",
            "title": "Use development mode configuration to enable whoops"
        },
        {
            "location": "/features/error-handling/#listening-for-errors",
            "text": "When errors occur, you may want to  listen  for them in order to provide\nfeatures such as logging.  Zend\\Stratigility\\Middleware\\ErrorHandler  provides\nthe ability to do so via its  attachListener()  method.  This method accepts a callable with the following signature:  function (\n    Throwable|Exception $error,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  The response provided is the response returned by your error response generator,\nallowing the listener the ability to introspect the generated response as well.  As an example, you could create a logging listener as follows:  namespace Acme;\n\nuse Exception;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass LoggingErrorListener\n{\n    /**\n     * Log format for messages:\n     *\n     * STATUS [METHOD] path: message\n     */\n    const LOG_FORMAT = '%d [%s] %s: %s';\n\n    private $logger;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke($error, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $this->logger->error(sprintf(\n            self::LOG_FORMAT,\n            $response->getStatusCode(),\n            $request->getMethod(),\n            (string) $request->getUri(),\n            $error->getMessage()\n        ));\n    }\n}  You could then use a  delegator factory  to\ncreate your logger listener and attach it to your error handler:  namespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass LoggingErrorListenerDelegatorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $name\n     * @param callable $callback\n     * @return ErrorHandler\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback)\n    {\n        $listener = new LoggingErrorListener($container->get(LoggerInterface::class));\n        $errorHandler = $callback();\n        $errorHandler->attachListener($listener);\n        return $errorHandler;\n    }\n}",
            "title": "Listening for errors"
        },
        {
            "location": "/features/error-handling/#handling-more-specific-error-types",
            "text": "You could also write more specific error handlers. As an example, you might want\nto catch  UnauthorizedException  instances specifically, and display a login\npage:  function ($request, DelegateInterface $delegate) use ($renderer)\n{\n    try {\n        $response = $delegate->process($request);\n        return $response;\n    } catch (UnauthorizedException $e) {\n    }\n\n    return new HtmlResponse(\n        $renderer->render('error::unauthorized'),\n        401\n    );\n}  You could then push this into a middleware pipe only when it's needed:  $app->get('/dashboard', [\n    $unauthorizedHandlerMiddleware,\n    $middlewareThatChecksForAuthorization,\n    $middlewareBehindAuthorizationWall,\n], 'dashboard');",
            "title": "Handling more specific error types"
        },
        {
            "location": "/features/error-handling/#default-delegates",
            "text": "Zend\\Expressive\\Application  manages an internal middleware pipeline; when you\ncall  $delegate->process()  (v2) or  $next()  (v1 or legacy double-pass\nmiddleware),  Application  is popping off the next middleware in the queue and\ndispatching it.  What happens when that queue is exhausted?  That situation indicates an error condition: no middleware was capable of\nreturning a response. This could either mean a problem with the request (HTTP\n400 \"Bad Request\" status) or inability to route the request (HTTP 404 \"Not\nFound\" status).  In order to report that information,  Zend\\Expressive\\Application  composes a\n\"default delegate\": a delegate it will invoke once the queue is exhausted and no\nresponse returned. By default, it uses a custom implementation, Zend\\Expressive\\Delegate\\NotFoundDelegate , which will report a 404 response,\noptionally using a composed template renderer to do so.  We provide a factory,  Zend\\Expressive\\Container\\NotFoundDelegateFactory , for\ncreating an instance, and this should be mapped to the Zend\\Expressive\\Delegate\\NotFoundDelegate  service, and aliased to the Zend\\Expressive\\Delegate\\DefaultDelegate  service:  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Delegate;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            'Zend\\Expressive\\Delegate\\DefaultDelegate' => Delegate\\NotFoundDelegate::class,\n        ],\n        'factories' => [\n            Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class,\n        ],\n    ],\n];  The factory will consume the following services:    Zend\\Expressive\\Template\\TemplateRendererInterface  (optional): if present,\n  the renderer will be used to render a template for use as the response\n  content.    config  (optional): if present, it will use the\n   $config['zend-expressive']['error_handler']['template_404']  value\n  as the template to use when rendering; if not provided, defaults to\n   error::404 .    If you wish to provide an alternate response status or use a canned response,\nyou should provide your own default delegate, and expose it via the Zend\\Expressive\\Delegate\\DefaultDelegate  service.",
            "title": "Default delegates"
        },
        {
            "location": "/features/error-handling/#page-not-found",
            "text": "Error handlers work at the outermost layer, and are used to catch exceptions and\nerrors in your application. At the  innermost  layer of your application, you\nshould ensure you have middleware that is  guaranteed  to return a response;\nthis will prevent the default delegate from needing to execute by ensuring that\nthe middleware queue never fully depletes. This in turn allows you to fully\ncraft what sort of response is returned.  Generally speaking, reaching the innermost middleware layer indicates that no\nmiddleware was capable of handling the request, and thus an HTTP 404 Not Found\ncondition.  To simplify such responses, we provide  Zend\\Expressive\\Middleware\\NotFoundHandler ,\nwith an accompanying  Zend\\Expressive\\Container\\NotFoundHandlerFactory . This\nmiddleware composes and proxies to the  NotFoundDelegate  detailed in the\nprevious section, and, as such, requires that that service be present.  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Delegate;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'factories' => [\n        Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class,\n        Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class,\n    ],\n];  When registered, you should then pipe it as the innermost layer of your\napplication:  // A basic application:\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);",
            "title": "Page not found"
        },
        {
            "location": "/features/error-handling/#version-1-error-handling",
            "text": "",
            "title": "Version 1 error handling"
        },
        {
            "location": "/features/error-handling/#deprecated",
            "text": "As noted in the introduction to this page, this section details error handling\nunder version 1 of Expressive. We strongly recommend upgrading to version 2, in\nlarge part due to its more flexible approach to error handling.  In addition, be aware that both the final handlers and Stratigility 1.X error\nmiddleware are completely absent from Expressive 2.0; you  will  need to\nmigrate your code at some point!   Expressive 1 provides error handling out of the box, via zend-stratigility 1.X's  FinalHandler\nimplementation .\nThis pseudo-middleware is executed in the following conditions:   If the middleware stack is exhausted, and no middleware has returned a response.  If an error has been passed via  $next() , but not handled by any error middleware.   The  FinalHandler  essentially tries to recover gracefully. In the case that no error was passed, it\ndoes the following:   If the response passed to it differs from the response provided at initialization, it will return\n  the response directly; the assumption is that some middleware along the way called  $next() \n  with a new response.  If the response instances are identical, it checks to see if the body size has changed; if it has,\n  the assumption is that a middleware at some point has written to the response body.  At this point, it assumes no middleware was able to handle the request, and creates a 404\n  response, indicating \"Not Found.\"   In the event that an error  was  passed, it does the following:   If  $error  is not an exception, it will use the response status if it already indicates an error\n  (ie., >= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase.  If  $error   is  an exception, it will use the exception status if it already indicates an error\n  (ie., >= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase. If the  FinalHandler  was initialized with an option indicating that it is in\n  development mode, it writes the exception stack trace to the response body.   This workflow stays the same throughout zend-expressive. But sometimes, it's just not enough.",
            "title": "Deprecated!"
        },
        {
            "location": "/features/error-handling/#templated-errors",
            "text": "You'll typically want to provide error messages in your site template. To do so, we provide Zend\\Expressive\\TemplatedErrorHandler . This class is similar to the  FinalHandler , but accepts,\noptionally, a  Zend\\Expressive\\Template\\TemplateRendererInterface  instance, and template names to use for\n404 and general error conditions. This makes it a good choice for use in production.  First, of course, you'll need to select a templating system and ensure you have\nthe appropriate dependencies installed; see the  templating documentation \nfor information on what we support and how to install supported systems.  Once you have selected your templating system, you can setup the templated error\nhandler.  use Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\TemplatedErrorHandler;\n\n$plates = new PlatesRenderer();\n$plates->addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new TemplatedErrorHandler($plates, 'error::404', 'error::500');\n\n$app = new Application($router, $container, $finalHandler);  The above will use the templates  error::404  and  error::500  for 404 and general errors,\nrespectively, rendering them using our Plates template adapter.  You can also use the  TemplatedErrorHandler  as a substitute for the  FinalHandler , without using\ntemplated capabilities, by omitting the  TemplateRendererInterface  instance when instantiating it. In this\ncase, the response message bodies will be empty, though the response status will reflect the error.  See the section titled \"Container Factories and Configuration\", below, for techniques on configuring\nthe  TemplatedErrorHandler  as your final handler within a container-based application.",
            "title": "Templated Errors"
        },
        {
            "location": "/features/error-handling/#whoops",
            "text": "whoops  is a library for providing a more usable UI around\nexceptions and PHP errors. We provide integration with this library through Zend\\Express\\WhoopsErrorHandler . This error handler derives from the  TemplatedErrorHandler , and\nuses its features for 404 status and non-exception errors. For exceptions, however, it will return\nthe whoops output. As such, it is a good choice for use in development.  To use it, you must first install whoops:  $ composer require filp/whoops  Then you will need to provide the error handler a whoops runtime instance, as well as a Whoops\\Handler\\PrettyPageHandler  instance. You can also optionally provide a  TemplateRendererInterface \ninstance and template names, just as you would for a  TemplatedErrorHandler .  use Whoops\\Handler\\PrettyPageHandler;\nuse Whoops\\Run as Whoops;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\WhoopsErrorHandler;\n\n$handler = new PrettyPageHandler();\n\n$whoops = new Whoops;\n$whoops->writeToOutput(false);\n$whoops->allowQuit(false);\n$whoops->pushHandler($handler);\n\n$plates = new PlatesRenderer();\n$plates->addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new WhoopsErrorHandler(\n    $whoops,\n    $handler,\n    $plates,\n    'error::404',\n    'error::500'\n);\n\n$app = new Application($router, $container, $finalHandler);\n\n// Register Whoops just before running the application, as otherwise it can\n// swallow bootstrap errors. \n$whoops->register();\n$app->run();  The calls to  writeToOutput(false) ,  allowQuit(false) , and  register()  must be made to guarantee\nwhoops will interoperate well with zend-expressive.  You can add more handlers if desired.  Internally, when an exception is discovered, zend-expressive adds some data to the whoops output,\nprimarily around the request information (URI, HTTP request method, route match attributes, etc.).  See the next section for techniques on configuring the  WhoopsErrorHandler  as your final handler\nwithin a container-based application.",
            "title": "Whoops"
        },
        {
            "location": "/features/error-handling/#container-factories-and-configuration",
            "text": "The above may feel like a bit much when creating your application. As such, we provide several\nfactories that work with  PSR-11 Container \nimplementations to simplify setup.  In each case, you should register the selected error handler's factory as the service Zend\\Expressive\\FinalHandler .   For the  TemplatedErrorHandler , use  Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory .  For the  WhoopsErrorHandler , use  Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory .",
            "title": "Container Factories and Configuration"
        },
        {
            "location": "/features/modular-applications/",
            "text": "Modular applications\n\n\nZend Framework 2 applications have a concept of \nmodules\n, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.\n\n\nStarting with Expressive 2.0, we provide similar functionality by incorporating\ntwo packages within the default skeleton application:\n\n\n\n\nzendframework/zend-config-aggregator\n,\n  which provides features for aggregating configuration from a variety of\n  sources, including:\n\n\nPHP files globbed from the filesystem that return an array of configuration.\n\n\nzend-config\n-compatible\n  configuration files globbed from the filesystem.\n\n\nConfiguration provider classes; these are invokable classes which return an\n  array of configuration.\n\n\n\n\n\n\nzendframework/zend-component-installer\n,\n  a Composer plugin that looks for an \nextra.zf.config-provider\n entry in a\n  package to install, and, if found, adds an entry for that provider to the\n  \nconfig/config.php\n file (if it uses zend-config-aggregator).\n\n\n\n\nThese features allow you to install packages via composer and expose their\nconfiguration \u2014 which may include dependency information \u2014 to your\napplication.\n\n\nMaking your application modular\n\n\nWhen using the Expressive 2.X installer, the first question asked is the\ninstallation type, which includes the options:\n\n\n\n\nMinimal (no default middleware, templates, or assets; configuration only)\n\n\nFlat (flat source code structure; default selection)\n\n\nModular (modular source code structure; recommended)\n\n\n\n\nWe recommend choosing the \"Modular\" option from the outset.\n\n\nIf you do not, you can still create and use modules in your application;\nhowever, the initial \"App\" module will not be modular.\n\n\nUpdating your Expressive 1.X application to accept modules\n\n\nIf you are upgrading from a previous Expressive version (1.X), and wish to use\nthese new features, you will need to install the following packages:\n\n\n\n\nzendframework/zend-config-aggregator\n\n\nzendframework/zend-component-installer\n\n\n\n\nAs an example:\n\n\n$ composer require zendframework/zend-config-aggregator \\\n> zendframework/zend-component-installer\n\n\n\nOnce installed, you should update your \nconfig/config.php\n file to read as\nfollows:\n\n\n<?php\n\nuse Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n// To enable or disable caching, set the `ConfigAggregator::ENABLE_CACHE` boolean in\n// `config/autoload/local.php`.\n$cacheConfig = [\n    'config_cache_path' => 'data/config-cache.php',\n];\n\n$aggregator = new ConfigAggregator([\n    // Include cache configuration\n    new ArrayProvider($cacheConfig),\n\n    // Default App module config\n    App\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], $cacheConfig['config_cache_path']);\n\nreturn $aggregator->getMergedConfig();\n\n\n\nThe above should mimic what you already had in place; if it does not, check to\nsee if there are additional paths you were globbing previously.\n\n\nModule structure\n\n\nExpressive does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nWe generally recommend that a module have a \nPSR-4\n\nstructure, and that the module contain a \nsrc/\n directory at the minimum, along\nwith directories for other module-specific content, such as templates, tests, and\nassets:\n\n\nsrc/\n  Acme/\n    src/\n      ConfigProvider.php\n      Container/\n        VerifyUserFactory.php\n      Helper/\n        AuthorizationHelper.php\n      Middleware/\n        VerifyUser.php\n    templates/\n      verify-user.php\n    test/\n      Helper/\n        AuthorizationHelperTest.php\n      Middleware/\n        VerifyUserTest.php\n\n\n\nIf you use the above structure, you would then add an entry in your\n\ncomposer.json\n file to provide autoloading:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Acme\\\\\": \"src/Acme/src/\"\n    }\n}\n\n\n\nDon't forget to execute \ncomposer dump-autoload\n after making the change!\n\n\nCreating and enabling a module\n\n\nThe only \nrequirement\n for creating a module is that you define a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nGenerally, a config provider will return dependency information, and\nmodule-specific configuration:\n\n\nnamespace Acme;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'acme' => [\n                'some-setting' => 'default value',\n            ],\n            'templates' => [\n                'paths' => [\n                    'acme' => [__DIR__ . '/../templates'],\n                ],\n            ]\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'invokables' => [\n                Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class,\n            ],\n            'factories' => [\n                Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class,\n            ],\n        ];\n    }\n}\n\n\n\nYou would then add the config provider to the top (or towards the top) of your\n\nconfig/config.php\n:\n\n\n$aggregator = new ConfigAggregator([\n    Acme\\ConfigProvider::class,\n    /* ... */\n\n\n\nThis approach allows your \nconfig/autoload/*\n files to take precedence over the\nmodule configuration, allowing you to override the values.\n\n\nCaching configuration\n\n\nIn order to provide configuration caching, two things must occur:\n\n\n\n\nFirst, you must define a \nconfig_cache_enabled\n key in your configuration\n  somewhere.\n\n\nSecond, you must pass a second argument to the \nConfigManager\n, the location\n  of the cache file to use.\n\n\n\n\nThe \nconfig_cache_enabled\n key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:\n\n\n\n\nconfig/autoload/global.php\n should define the value to \ntrue\n, as the\n  production setting.\n\n\nconfig/autoload/local.php\n should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be \nfalse\n.\n\n\n\n\n// config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];\n\n\n\nYou would then alter your \nconfig/config.php\n file to add the second argument.\nThe following example builds on the previous, and demonstrates having the\n\nAppConfig\n entry enabled. The configuration will be cached to\n\ndata/config-cache.php\n in the application root:\n\n\n$configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');\n\n\n\nWhen the configuration cache path is present, if the \nconfig_cache_enabled\n flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.\n\n\nFinal notes\n\n\nThis approach may look simple, but it is flexible and powerful:\n\n\n\n\nYou pass a list of config providers to the \nConfigAggregator\n constructor.\n\n\nConfiguration is merged in the same order as it is passed, with later entries\n  having precedence.\n\n\nYou can override module configuration using \n*.global.php\n and \n*.local.php\n files.\n\n\nIf cached config is found, \nConfigAggregator\n does not iterate over provider list.\n\n\n\n\nFor more details, please refer to the \nzend-config-aggregator\ndocumentation\n.",
            "title": "Modular Applications"
        },
        {
            "location": "/features/modular-applications/#modular-applications",
            "text": "Zend Framework 2 applications have a concept of  modules , independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.  Starting with Expressive 2.0, we provide similar functionality by incorporating\ntwo packages within the default skeleton application:   zendframework/zend-config-aggregator ,\n  which provides features for aggregating configuration from a variety of\n  sources, including:  PHP files globbed from the filesystem that return an array of configuration.  zend-config -compatible\n  configuration files globbed from the filesystem.  Configuration provider classes; these are invokable classes which return an\n  array of configuration.    zendframework/zend-component-installer ,\n  a Composer plugin that looks for an  extra.zf.config-provider  entry in a\n  package to install, and, if found, adds an entry for that provider to the\n   config/config.php  file (if it uses zend-config-aggregator).   These features allow you to install packages via composer and expose their\nconfiguration \u2014 which may include dependency information \u2014 to your\napplication.",
            "title": "Modular applications"
        },
        {
            "location": "/features/modular-applications/#making-your-application-modular",
            "text": "When using the Expressive 2.X installer, the first question asked is the\ninstallation type, which includes the options:   Minimal (no default middleware, templates, or assets; configuration only)  Flat (flat source code structure; default selection)  Modular (modular source code structure; recommended)   We recommend choosing the \"Modular\" option from the outset.  If you do not, you can still create and use modules in your application;\nhowever, the initial \"App\" module will not be modular.",
            "title": "Making your application modular"
        },
        {
            "location": "/features/modular-applications/#updating-your-expressive-1x-application-to-accept-modules",
            "text": "If you are upgrading from a previous Expressive version (1.X), and wish to use\nthese new features, you will need to install the following packages:   zendframework/zend-config-aggregator  zendframework/zend-component-installer   As an example:  $ composer require zendframework/zend-config-aggregator \\\n> zendframework/zend-component-installer  Once installed, you should update your  config/config.php  file to read as\nfollows:  <?php\n\nuse Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n// To enable or disable caching, set the `ConfigAggregator::ENABLE_CACHE` boolean in\n// `config/autoload/local.php`.\n$cacheConfig = [\n    'config_cache_path' => 'data/config-cache.php',\n];\n\n$aggregator = new ConfigAggregator([\n    // Include cache configuration\n    new ArrayProvider($cacheConfig),\n\n    // Default App module config\n    App\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], $cacheConfig['config_cache_path']);\n\nreturn $aggregator->getMergedConfig();  The above should mimic what you already had in place; if it does not, check to\nsee if there are additional paths you were globbing previously.",
            "title": "Updating your Expressive 1.X application to accept modules"
        },
        {
            "location": "/features/modular-applications/#module-structure",
            "text": "Expressive does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  We generally recommend that a module have a  PSR-4 \nstructure, and that the module contain a  src/  directory at the minimum, along\nwith directories for other module-specific content, such as templates, tests, and\nassets:  src/\n  Acme/\n    src/\n      ConfigProvider.php\n      Container/\n        VerifyUserFactory.php\n      Helper/\n        AuthorizationHelper.php\n      Middleware/\n        VerifyUser.php\n    templates/\n      verify-user.php\n    test/\n      Helper/\n        AuthorizationHelperTest.php\n      Middleware/\n        VerifyUserTest.php  If you use the above structure, you would then add an entry in your composer.json  file to provide autoloading:  \"autoload\": {\n    \"psr-4\": {\n        \"Acme\\\\\": \"src/Acme/src/\"\n    }\n}  Don't forget to execute  composer dump-autoload  after making the change!",
            "title": "Module structure"
        },
        {
            "location": "/features/modular-applications/#creating-and-enabling-a-module",
            "text": "The only  requirement  for creating a module is that you define a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  Generally, a config provider will return dependency information, and\nmodule-specific configuration:  namespace Acme;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'acme' => [\n                'some-setting' => 'default value',\n            ],\n            'templates' => [\n                'paths' => [\n                    'acme' => [__DIR__ . '/../templates'],\n                ],\n            ]\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'invokables' => [\n                Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class,\n            ],\n            'factories' => [\n                Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class,\n            ],\n        ];\n    }\n}  You would then add the config provider to the top (or towards the top) of your config/config.php :  $aggregator = new ConfigAggregator([\n    Acme\\ConfigProvider::class,\n    /* ... */  This approach allows your  config/autoload/*  files to take precedence over the\nmodule configuration, allowing you to override the values.",
            "title": "Creating and enabling a module"
        },
        {
            "location": "/features/modular-applications/#caching-configuration",
            "text": "In order to provide configuration caching, two things must occur:   First, you must define a  config_cache_enabled  key in your configuration\n  somewhere.  Second, you must pass a second argument to the  ConfigManager , the location\n  of the cache file to use.   The  config_cache_enabled  key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:   config/autoload/global.php  should define the value to  true , as the\n  production setting.  config/autoload/local.php  should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be  false .   // config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];  You would then alter your  config/config.php  file to add the second argument.\nThe following example builds on the previous, and demonstrates having the AppConfig  entry enabled. The configuration will be cached to data/config-cache.php  in the application root:  $configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');  When the configuration cache path is present, if the  config_cache_enabled  flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.",
            "title": "Caching configuration"
        },
        {
            "location": "/features/modular-applications/#final-notes",
            "text": "This approach may look simple, but it is flexible and powerful:   You pass a list of config providers to the  ConfigAggregator  constructor.  Configuration is merged in the same order as it is passed, with later entries\n  having precedence.  You can override module configuration using  *.global.php  and  *.local.php  files.  If cached config is found,  ConfigAggregator  does not iterate over provider list.   For more details, please refer to the  zend-config-aggregator\ndocumentation .",
            "title": "Final notes"
        },
        {
            "location": "/features/middleware/implicit-methods-middleware/",
            "text": "ImplicitHeadMiddleware and ImplicitOptionsMiddleware\n\n\nStarting with version 2.0, Expressive offers middleware for implicitly\nsupporting \nHEAD\n and \nOPTIONS\n requests. The HTTP/1.1 specifications indicate\nthat all server implementations \nmust\n support \nHEAD\n requests for any given\nURI, and that they \nshould\n support \nOPTIONS\n requests. To make this possible,\nwe have added features to our routing layer, and middleware that can detect\n\nimplicit\n  support for these methods (i.e., the route was not registered\n\nexplicitly\n with the method).\n\n\nImplicitHeadMiddleware\n\n\nZend\\Expressive\\Middleware\\ImplicitHeadMiddleware\n provides support for\nhandling \nHEAD\n requests to routed middleware when the route does not expliclity\nallow for the method. It should be registered \nbetween\n the routing and dispatch\nmiddleware.\n\n\nBy default, it can be instantiated with no extra arguments. However, you \nmay\n\nprovide a response instance to use by default to the constructor if you need to\ncraft special headers, status code, etc.\n\n\nRegister the dependency via \ndependencies\n configuration:\n\n\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            ImplicitHeadMiddleware::class => ImplicitHeadMiddleware::class,\n        ],\n\n        // or, if you have defined a factory to inject a response:\n        'factories' => [\n            ImplicitHeadMiddleware::class => \\Your\\ImplicitHeadMiddlewareFactory::class,\n        ],\n    ],\n];\n\n\n\nWithin your application pipeline, add the middleware between the routing and\ndispatch middleware:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipe(ImplicitHeadMiddleware::class);\n// ...\n$app->pipeDispatchMiddleware();\n\n\n\n(Note: if you used the \nexpressive-pipeline-from-config\n tool to create your\nprogrammatic pipeline, or if you used the Expressive 2.0 skeleton or later, this\nmiddleware is likely already in your pipeline, as is a dependency entry.)\n\n\nWhen in place, it will do the following:\n\n\n\n\nIf the request method is \nHEAD\n, AND\n\n\nthe request composes a \nRouteResult\n attribute, AND\n\n\nthe route result composes a \nRoute\n instance, AND\n\n\nthe route returns true for the \nimplicitHead()\n method, THEN\n\n\nthe middleware will return a response.\n\n\n\n\nIn all other cases, it returns the result of delegating to the next middleware\nlayer.\n\n\nWhen \nimplicitHead()\n is matched, one of two things may occur. First, if the\nroute does not support the \nGET\n method, then the middleware returns the\ncomposed response (either the one injected at instantiation, or an empty\ninstance). However, if \nGET\n is supported, it will dispatch the next layer, but\nwith a \nGET\n request instead of \nHEAD\n; additionally, it will inject the\nreturned response with an empty response body before returning it.\n\n\nImplicitOptionsMiddleware\n\n\nZend\\Expressive\\Middleware\\ImplicitOptionsMiddleware\n provides support for\nhandling \nOPTIONS\n requests to routed middleware when the route does not\nexpliclity allow for the method. Like the \nImplicitHeadMiddleware\n, it should be\nregistered \nbetween\n the routing and dispatch middleware.\n\n\nBy default, it can be instantiated with no extra arguments. However, you \nmay\n\nprovide a response prototype instance to use by default to the constructor if\nyou need to craft special headers, status code, etc.\n\n\nRegister the dependency via \ndependencies\n configuration:\n\n\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            ImplicitOptionsMiddleware::class => ImplicitOptionsMiddleware::class,\n        ],\n\n        // or, if you have defined a factory to inject a response:\n        'factories' => [\n            ImplicitOptionsMiddleware::class => \\Your\\ImplicitOptionsMiddlewareFactory::class,\n        ],\n    ],\n];\n\n\n\nWithin your application pipeline, add the middleware between the routing and\ndispatch middleware:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipe(ImplicitOptionsMiddleware::class);\n// ...\n$app->pipeDispatchMiddleware();\n\n\n\n(Note: if you used the \nexpressive-pipeline-from-config\n tool to create your\nprogrammatic pipeline, or if you used the Expressive 2.0 skeleton or later, this\nmiddleware is likely already in your pipeline, as is a dependency entry.)\n\n\nWhen in place, it will do the following:\n\n\n\n\nIf the request method is \nOPTIONS\n, AND\n\n\nthe request composes a \nRouteResult\n attribute, AND\n\n\nthe route result composes a \nRoute\n instance, AND\n\n\nthe route returns true for the \nimplicitOptions()\n method, THEN\n\n\nthe middleware will return a response with an \nAllow\n header indicating\n  methods the route allows.\n\n\n\n\nIn all other cases, it returns the result of delegating to the next middleware\nlayer.\n\n\nOne thing to note: the allowed methods reported by the route and/or route\nresult, and returned via the \nAllow\n header,  may vary based on router\nimplementation. In most cases, it should be an aggregate of all routes using the\nsame path specification; however, it \ncould\n be only the methods supported\nexplicitly by the matched route.",
            "title": "Implicit HEAD and OPTIONS Middleware"
        },
        {
            "location": "/features/middleware/implicit-methods-middleware/#implicitheadmiddleware-and-implicitoptionsmiddleware",
            "text": "Starting with version 2.0, Expressive offers middleware for implicitly\nsupporting  HEAD  and  OPTIONS  requests. The HTTP/1.1 specifications indicate\nthat all server implementations  must  support  HEAD  requests for any given\nURI, and that they  should  support  OPTIONS  requests. To make this possible,\nwe have added features to our routing layer, and middleware that can detect implicit   support for these methods (i.e., the route was not registered explicitly  with the method).",
            "title": "ImplicitHeadMiddleware and ImplicitOptionsMiddleware"
        },
        {
            "location": "/features/middleware/implicit-methods-middleware/#implicitheadmiddleware",
            "text": "Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware  provides support for\nhandling  HEAD  requests to routed middleware when the route does not expliclity\nallow for the method. It should be registered  between  the routing and dispatch\nmiddleware.  By default, it can be instantiated with no extra arguments. However, you  may \nprovide a response instance to use by default to the constructor if you need to\ncraft special headers, status code, etc.  Register the dependency via  dependencies  configuration:  use Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            ImplicitHeadMiddleware::class => ImplicitHeadMiddleware::class,\n        ],\n\n        // or, if you have defined a factory to inject a response:\n        'factories' => [\n            ImplicitHeadMiddleware::class => \\Your\\ImplicitHeadMiddlewareFactory::class,\n        ],\n    ],\n];  Within your application pipeline, add the middleware between the routing and\ndispatch middleware:  $app->pipeRoutingMiddleware();\n$app->pipe(ImplicitHeadMiddleware::class);\n// ...\n$app->pipeDispatchMiddleware();  (Note: if you used the  expressive-pipeline-from-config  tool to create your\nprogrammatic pipeline, or if you used the Expressive 2.0 skeleton or later, this\nmiddleware is likely already in your pipeline, as is a dependency entry.)  When in place, it will do the following:   If the request method is  HEAD , AND  the request composes a  RouteResult  attribute, AND  the route result composes a  Route  instance, AND  the route returns true for the  implicitHead()  method, THEN  the middleware will return a response.   In all other cases, it returns the result of delegating to the next middleware\nlayer.  When  implicitHead()  is matched, one of two things may occur. First, if the\nroute does not support the  GET  method, then the middleware returns the\ncomposed response (either the one injected at instantiation, or an empty\ninstance). However, if  GET  is supported, it will dispatch the next layer, but\nwith a  GET  request instead of  HEAD ; additionally, it will inject the\nreturned response with an empty response body before returning it.",
            "title": "ImplicitHeadMiddleware"
        },
        {
            "location": "/features/middleware/implicit-methods-middleware/#implicitoptionsmiddleware",
            "text": "Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware  provides support for\nhandling  OPTIONS  requests to routed middleware when the route does not\nexpliclity allow for the method. Like the  ImplicitHeadMiddleware , it should be\nregistered  between  the routing and dispatch middleware.  By default, it can be instantiated with no extra arguments. However, you  may \nprovide a response prototype instance to use by default to the constructor if\nyou need to craft special headers, status code, etc.  Register the dependency via  dependencies  configuration:  use Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            ImplicitOptionsMiddleware::class => ImplicitOptionsMiddleware::class,\n        ],\n\n        // or, if you have defined a factory to inject a response:\n        'factories' => [\n            ImplicitOptionsMiddleware::class => \\Your\\ImplicitOptionsMiddlewareFactory::class,\n        ],\n    ],\n];  Within your application pipeline, add the middleware between the routing and\ndispatch middleware:  $app->pipeRoutingMiddleware();\n$app->pipe(ImplicitOptionsMiddleware::class);\n// ...\n$app->pipeDispatchMiddleware();  (Note: if you used the  expressive-pipeline-from-config  tool to create your\nprogrammatic pipeline, or if you used the Expressive 2.0 skeleton or later, this\nmiddleware is likely already in your pipeline, as is a dependency entry.)  When in place, it will do the following:   If the request method is  OPTIONS , AND  the request composes a  RouteResult  attribute, AND  the route result composes a  Route  instance, AND  the route returns true for the  implicitOptions()  method, THEN  the middleware will return a response with an  Allow  header indicating\n  methods the route allows.   In all other cases, it returns the result of delegating to the next middleware\nlayer.  One thing to note: the allowed methods reported by the route and/or route\nresult, and returned via the  Allow  header,  may vary based on router\nimplementation. In most cases, it should be an aggregate of all routes using the\nsame path specification; however, it  could  be only the methods supported\nexplicitly by the matched route.",
            "title": "ImplicitOptionsMiddleware"
        },
        {
            "location": "/features/helpers/intro/",
            "text": "Helpers\n\n\nSome tasks and features will be common to many if not all applications. For\nthose, Expressive provides \nhelpers\n. These are typically utility classes that\nmay integrate features or simply provide standalone benefits.\n\n\nCurrently, these include:\n\n\n\n\nBody Parsing Middleware\n\n\nContent-Length Middleware\n (since 4.1.0)\n\n\nUrlHelper\n\n\nServerUrlHelper\n\n\n\n\nInstallation\n\n\nIf you started your project using the Expressive skeleton package, the helpers\nare already installed.\n\n\nIf not, you can install them as follows:\n\n\n$ composer require zendframework/zend-expressive-helpers",
            "title": "Introduction"
        },
        {
            "location": "/features/helpers/intro/#helpers",
            "text": "Some tasks and features will be common to many if not all applications. For\nthose, Expressive provides  helpers . These are typically utility classes that\nmay integrate features or simply provide standalone benefits.  Currently, these include:   Body Parsing Middleware  Content-Length Middleware  (since 4.1.0)  UrlHelper  ServerUrlHelper",
            "title": "Helpers"
        },
        {
            "location": "/features/helpers/intro/#installation",
            "text": "If you started your project using the Expressive skeleton package, the helpers\nare already installed.  If not, you can install them as follows:  $ composer require zendframework/zend-expressive-helpers",
            "title": "Installation"
        },
        {
            "location": "/features/helpers/url-helper/",
            "text": "UrlHelper\n\n\nZend\\Expressive\\Helper\\UrlHelper\n provides the ability to generate a URI path\nbased on a given route defined in the \nZend\\Expressive\\Router\\RouterInterface\n.\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper->generate('resource', ['id' => 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' => 'sha1']);\n\n\n\nThe signature for both is:\n\n\nfunction (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string\n\n\n\nWhere:\n\n\n\n\n$routeName\n is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.\n\n\n$routeParams\n is an array of substitutions to use for the provided route, with the\n  following behavior:\n\n\nIf a \nRouteResult\n is composed in the helper, and the \n$routeName\n matches\n  it, the provided \n$params\n will be merged with any matched parameters, with\n  those provided taking precedence.\n\n\nIf a \nRouteResult\n is not composed, or if the composed result does not match\n  the provided \n$routeName\n, then only the \n$params\n provided will be used\n  for substitutions.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n matches the currently\n  matched route, then any matched parameters found will be used.\n  parameters found will be used.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n does not match the\n  currently matched route, or if no route result is present, then no\n  substitutions will be made.\n\n\n\n\n\n\n$queryParams\n is an array of query string arguments to include in the\n  generated URI.\n\n\n$fragmentIdentifier\n is a string to use as the URI fragment.\n\n\n$options\n is an array of options to provide to the router for purposes of\n  controlling URI generation. As an example, zend-router can consume \"translator\"\n  and \"text_domain\" options in order to provide translated URIs.\n\n\n\n\nEach method will raise an exception if:\n\n\n\n\nNo \n$routeName\n is provided, and no \nRouteResult\n is composed.\n\n\nNo \n$routeName\n is provided, a \nRouteResult\n is composed, but that result\n  represents a matching failure.\n\n\nThe given \n$routeName\n is not defined in the router.\n\n\n\n\n\n\nSignature changes\n\n\nThe signature listed above is current as of version 3.0.0 of\nzendframework/zend-expressive-helpers. Prior to that version, the helper only\naccepted the route name and route parameters.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to instantiate it with the current\n\nRouterInterface\n. The factory \nZend\\Expressive\\Helper\\UrlHelperFactory\n has\nbeen provided for this purpose, and can be used trivially with most\ndependency injection containers implementing \n\nPSR-11 Container\n. Additionally,\nit is most useful when injected with the current results of routing, which\nrequires registering middleware with the application that can inject the route\nresult. The following steps should be followed to register and configure the helper:\n\n\n\n\nRegister the \nUrlHelper\n as a service in your container, using the provided\n  factory.\n\n\nRegister the \nUrlHelperMiddleware\n as a service in your container, using the\n  provided factory.\n\n\nRegister the \nUrlHelperMiddleware\n as pipeline middleware, immediately\n  following the routing middleware.\n\n\n\n\nRegistering the helper service\n\n\nThe following examples demonstrate programmatic registration of the \nUrlHelper\n\nservice in your selected dependency injection container.\n\n\nuse Zend\\Expressive\\Helper\\UrlHelper;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\n\n// zend-servicemanager:\n$services->setFactory(UrlHelper::class, UrlHelperFactory::class);\n\n// Pimple:\n$pimple[UrlHelper::class] = function ($container) {\n    $factory = new UrlHelperFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(UrlHelperFactory::class, $container->lazyNew(UrlHelperFactory::class));\n$container->set(\n    UrlHelper::class,\n    $container->lazyGetCall(UrlHelperFactory::class, '__invoke', $container)\n);\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn ['dependencies' => [\n    'factories' => [\n        UrlHelper::class => UrlHelperFactory::class,\n    ],\n]]\n\n\n\n\n\nUrlHelperFactory requires RouterInterface\n\n\nThe factory requires that a service named \nZend\\Expressive\\Router\\RouterInterface\n is present,\nand will raise an exception if the service is not found.\n\n\n\n\nRegistering the pipeline middleware\n\n\nTo register the \nUrlHelperMiddleware\n as pipeline middleware following the\nrouting middleware:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n//         ['middleware' => UrlHelperMiddleware::class],\n//         Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n//         /* ... */\n//     ],\n// ]\n//\n// Alternately, create a nested middleware pipeline for the routing, UrlHelper,\n// and dispatch middleware:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         'routing' => [\n//             'middleware' => [\n//                 Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n//                 UrlHelperMiddleware::class\n//                 Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n//             ],\n//             'priority' => 1,\n//         ],\n//         /* ... */\n//     ],\n// ]\n\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n        ['middleware' => UrlHelperMiddleware::class],\n        Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n    ],\n];\n\n// OR:\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n                UrlHelperMiddleware::class,\n                Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n    ],\n];\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nUrlHelper\n and \nUrlHelperMiddleware\n factories are already registered for\nyou, as is the \nUrlHelperMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response->withHeader(\n            'Link',\n            $this->helper->generate('resource', ['id' => 'sha1'])\n        );\n        return $next($request, $response);\n    }\n}\n\n\n\nBase Path support\n\n\nIf your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the \nbase path\n, and thus be invalid. To\naccommodate this, the \nUrlHelper\n supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.\n\n\nAs an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the \nUrlHelper\n with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $uri = $request->getUri();\n        $path = $uri->getPath();\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $delegate->process($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $delegate->process($request->withUri(\n            $uri->withPath(substr($path, (strlen($locale) + 1)))\n        ));\n    }\n}\n\n\n\n(Note: if the base path injected is not prefixed with \n/\n, the helper will add\nthe slash.)\n\n\nPaths generated by the \nUriHelper\n from this point forward will have the\ndetected language prefix.",
            "title": "UrlHelper"
        },
        {
            "location": "/features/helpers/url-helper/#urlhelper",
            "text": "Zend\\Expressive\\Helper\\UrlHelper  provides the ability to generate a URI path\nbased on a given route defined in the  Zend\\Expressive\\Router\\RouterInterface .\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.",
            "title": "UrlHelper"
        },
        {
            "location": "/features/helpers/url-helper/#usage",
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper->generate('resource', ['id' => 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' => 'sha1']);  The signature for both is:  function (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string  Where:   $routeName  is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.  $routeParams  is an array of substitutions to use for the provided route, with the\n  following behavior:  If a  RouteResult  is composed in the helper, and the  $routeName  matches\n  it, the provided  $params  will be merged with any matched parameters, with\n  those provided taking precedence.  If a  RouteResult  is not composed, or if the composed result does not match\n  the provided  $routeName , then only the  $params  provided will be used\n  for substitutions.  If no  $params  are provided, and the  $routeName  matches the currently\n  matched route, then any matched parameters found will be used.\n  parameters found will be used.  If no  $params  are provided, and the  $routeName  does not match the\n  currently matched route, or if no route result is present, then no\n  substitutions will be made.    $queryParams  is an array of query string arguments to include in the\n  generated URI.  $fragmentIdentifier  is a string to use as the URI fragment.  $options  is an array of options to provide to the router for purposes of\n  controlling URI generation. As an example, zend-router can consume \"translator\"\n  and \"text_domain\" options in order to provide translated URIs.   Each method will raise an exception if:   No  $routeName  is provided, and no  RouteResult  is composed.  No  $routeName  is provided, a  RouteResult  is composed, but that result\n  represents a matching failure.  The given  $routeName  is not defined in the router.",
            "title": "Usage"
        },
        {
            "location": "/features/helpers/url-helper/#signature-changes",
            "text": "The signature listed above is current as of version 3.0.0 of\nzendframework/zend-expressive-helpers. Prior to that version, the helper only\naccepted the route name and route parameters.",
            "title": "Signature changes"
        },
        {
            "location": "/features/helpers/url-helper/#creating-an-instance",
            "text": "In order to use the helper, you will need to instantiate it with the current RouterInterface . The factory  Zend\\Expressive\\Helper\\UrlHelperFactory  has\nbeen provided for this purpose, and can be used trivially with most\ndependency injection containers implementing  PSR-11 Container . Additionally,\nit is most useful when injected with the current results of routing, which\nrequires registering middleware with the application that can inject the route\nresult. The following steps should be followed to register and configure the helper:   Register the  UrlHelper  as a service in your container, using the provided\n  factory.  Register the  UrlHelperMiddleware  as a service in your container, using the\n  provided factory.  Register the  UrlHelperMiddleware  as pipeline middleware, immediately\n  following the routing middleware.",
            "title": "Creating an instance"
        },
        {
            "location": "/features/helpers/url-helper/#registering-the-helper-service",
            "text": "The following examples demonstrate programmatic registration of the  UrlHelper \nservice in your selected dependency injection container.  use Zend\\Expressive\\Helper\\UrlHelper;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\n\n// zend-servicemanager:\n$services->setFactory(UrlHelper::class, UrlHelperFactory::class);\n\n// Pimple:\n$pimple[UrlHelper::class] = function ($container) {\n    $factory = new UrlHelperFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(UrlHelperFactory::class, $container->lazyNew(UrlHelperFactory::class));\n$container->set(\n    UrlHelper::class,\n    $container->lazyGetCall(UrlHelperFactory::class, '__invoke', $container)\n);  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return ['dependencies' => [\n    'factories' => [\n        UrlHelper::class => UrlHelperFactory::class,\n    ],\n]]",
            "title": "Registering the helper service"
        },
        {
            "location": "/features/helpers/url-helper/#urlhelperfactory-requires-routerinterface",
            "text": "The factory requires that a service named  Zend\\Expressive\\Router\\RouterInterface  is present,\nand will raise an exception if the service is not found.",
            "title": "UrlHelperFactory requires RouterInterface"
        },
        {
            "location": "/features/helpers/url-helper/#registering-the-pipeline-middleware",
            "text": "To register the  UrlHelperMiddleware  as pipeline middleware following the\nrouting middleware:  use Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n//         ['middleware' => UrlHelperMiddleware::class],\n//         Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n//         /* ... */\n//     ],\n// ]\n//\n// Alternately, create a nested middleware pipeline for the routing, UrlHelper,\n// and dispatch middleware:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         'routing' => [\n//             'middleware' => [\n//                 Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n//                 UrlHelperMiddleware::class\n//                 Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n//             ],\n//             'priority' => 1,\n//         ],\n//         /* ... */\n//     ],\n// ]  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n        ['middleware' => UrlHelperMiddleware::class],\n        Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n    ],\n];\n\n// OR:\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n                UrlHelperMiddleware::class,\n                Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n    ],\n];",
            "title": "Registering the pipeline middleware"
        },
        {
            "location": "/features/helpers/url-helper/#skeleton-configures-helpers",
            "text": "If you started your project using the Expressive skeleton package, the UrlHelper  and  UrlHelperMiddleware  factories are already registered for\nyou, as is the  UrlHelperMiddleware  pipeline middleware.",
            "title": "Skeleton configures helpers"
        },
        {
            "location": "/features/helpers/url-helper/#using-the-helper-in-middleware",
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response->withHeader(\n            'Link',\n            $this->helper->generate('resource', ['id' => 'sha1'])\n        );\n        return $next($request, $response);\n    }\n}",
            "title": "Using the helper in middleware"
        },
        {
            "location": "/features/helpers/url-helper/#base-path-support",
            "text": "If your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the  base path , and thus be invalid. To\naccommodate this, the  UrlHelper  supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.  As an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the  UrlHelper  with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $uri = $request->getUri();\n        $path = $uri->getPath();\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $delegate->process($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $delegate->process($request->withUri(\n            $uri->withPath(substr($path, (strlen($locale) + 1)))\n        ));\n    }\n}  (Note: if the base path injected is not prefixed with  / , the helper will add\nthe slash.)  Paths generated by the  UriHelper  from this point forward will have the\ndetected language prefix.",
            "title": "Base Path support"
        },
        {
            "location": "/features/helpers/server-url-helper/",
            "text": "ServerUrlHelper\n\n\nZend\\Expressive\\Helper\\ServerUrlHelper\n provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent \nPsr\\Http\\Message\\UriInterface\n instance provided to it in order to\ngenerate a fully qualified URI.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper->generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');\n\n\n\nThe helper is particularly useful when used in conjunction with the\n\nUrlHelper\n, as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:\n\n\n$url = $serverUrl($url('resource', ['id' => 'sha1']));\n\n\n\nThe signature for the ServerUrlHelper \ngenerate()\n and \n__invoke()\n methods is:\n\n\nfunction ($path = null) : string\n\n\n\nWhere:\n\n\n\n\n$path\n, when provided, can be a string path to use to generate a URI.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to inject it with the current\n\nUriInterface\n from the request instance. To automate this, we provide\n\nZend\\Expressive\\Helper\\ServerUrlMiddleware\n, which composes a \nServerUrl\n\ninstance, and, when invoked, injects it with the URI instance.\n\n\nAs such, you will need to:\n\n\n\n\nRegister the \nServerUrlHelper\n as a service in your container.\n\n\nRegister the \nServerUrlMiddleware\n as a service in your container.\n\n\nRegister the \nServerUrlMiddleware\n as pipeline middleware, anytime\n  before the routing middleware.\n\n\n\n\nThe following examples demonstrate registering the services.\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory;\n\n// zend-servicemanager:\n$services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class);\n$services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class);\n\n// Pimple:\n$pimple[ServerUrlHelper::class] = function ($container) {\n    return new ServerUrlHelper();\n};\n$pimple[ServerUrlMiddleware::class] = function ($container) {\n    $factory = new ServerUrlMiddlewareFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class));\n$container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class));\n$container->set(\n    ServerUrlMiddleware::class,\n    $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container)\n);\n\n\n\nTo register the \nServerUrlMiddleware\n as pipeline middleware anytime before the\nrouting middleware:\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n//         /* ... */\n//     ],\n// ]\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            ServerUrlHelper::class => ServerUrlHelper::class,\n        ],\n        'factories' => [\n            ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n        /* ... */\n    ],\n];\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nServerUrlHelper\n and \nServerUrlMiddleware\n factories are already registered\nfor you, as is the \nServerUrlMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader(\n            'Link',\n            $this->helper->generate() . '; rel=\"self\"'\n        );\n    }\n}",
            "title": "ServerUrlHelper"
        },
        {
            "location": "/features/helpers/server-url-helper/#serverurlhelper",
            "text": "Zend\\Expressive\\Helper\\ServerUrlHelper  provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent  Psr\\Http\\Message\\UriInterface  instance provided to it in order to\ngenerate a fully qualified URI.",
            "title": "ServerUrlHelper"
        },
        {
            "location": "/features/helpers/server-url-helper/#usage",
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper->generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');  The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:  $url = $serverUrl($url('resource', ['id' => 'sha1']));  The signature for the ServerUrlHelper  generate()  and  __invoke()  methods is:  function ($path = null) : string  Where:   $path , when provided, can be a string path to use to generate a URI.",
            "title": "Usage"
        },
        {
            "location": "/features/helpers/server-url-helper/#creating-an-instance",
            "text": "In order to use the helper, you will need to inject it with the current UriInterface  from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a  ServerUrl \ninstance, and, when invoked, injects it with the URI instance.  As such, you will need to:   Register the  ServerUrlHelper  as a service in your container.  Register the  ServerUrlMiddleware  as a service in your container.  Register the  ServerUrlMiddleware  as pipeline middleware, anytime\n  before the routing middleware.   The following examples demonstrate registering the services.  use Zend\\Expressive\\Helper\\ServerUrlHelper;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory;\n\n// zend-servicemanager:\n$services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class);\n$services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class);\n\n// Pimple:\n$pimple[ServerUrlHelper::class] = function ($container) {\n    return new ServerUrlHelper();\n};\n$pimple[ServerUrlMiddleware::class] = function ($container) {\n    $factory = new ServerUrlMiddlewareFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class));\n$container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class));\n$container->set(\n    ServerUrlMiddleware::class,\n    $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container)\n);  To register the  ServerUrlMiddleware  as pipeline middleware anytime before the\nrouting middleware:  use Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n//         /* ... */\n//     ],\n// ]  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return [\n    'dependencies' => [\n        'invokables' => [\n            ServerUrlHelper::class => ServerUrlHelper::class,\n        ],\n        'factories' => [\n            ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n        /* ... */\n    ],\n];",
            "title": "Creating an instance"
        },
        {
            "location": "/features/helpers/server-url-helper/#skeleton-configures-helpers",
            "text": "If you started your project using the Expressive skeleton package, the ServerUrlHelper  and  ServerUrlMiddleware  factories are already registered\nfor you, as is the  ServerUrlMiddleware  pipeline middleware.",
            "title": "Skeleton configures helpers"
        },
        {
            "location": "/features/helpers/server-url-helper/#using-the-helper-in-middleware",
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader(\n            'Link',\n            $this->helper->generate() . '; rel=\"self\"'\n        );\n    }\n}",
            "title": "Using the helper in middleware"
        },
        {
            "location": "/features/helpers/body-parse/",
            "text": "Body Parsing Middleware\n\n\nZend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware\n provides generic PSR-7\nmiddleware for parsing the request body into parameters, and returning a new\nrequest instance that composes them. The subcomponent provides a strategy\npattern around matching the request \nContent-Type\n, and then parsing it, giving\nyou a flexible approach that can grow with your accepted content types.\n\n\nBy default, this middleware will detect the following content types:\n\n\n\n\napplication/x-www-form-urlencoded\n (standard web-based forms, without file\n  uploads)\n\n\napplication/json\n, \napplication/*+json\n (JSON payloads)\n\n\n\n\nRegistering the middleware\n\n\nYou can register it programmatically:\n\n\n$app->pipe(BodyParamsMiddleware::class);\n\n\n\nAlternately, register it via configuration, if using configuration-based applications:\n\n\n// config/autoload/middleware-pipeline.global.php\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nSince body parsing does not necessarily need to happen for every request, you\ncan also choose to incorporate it in route-specific middleware pipelines:\n\n\n$app->post('/login', [\n    BodyParamsMiddleware::class,\n    LoginMiddleware::class,\n]);\n\n\n\nIf using a configuration-based application:\n\n\n// config/autoload/routes.global.php\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'routes' => [\n        [\n            'name' => 'contact:process',\n            'path' => '/contact/process',\n            'middleware' => [\n                BodyParamsMiddleware::class,\n                Contact\\Process::class,\n            ],\n            'allowed_methods' => ['POST'],\n        ]\n    ],\n];\n\n\n\nUsing route-based middleware pipelines has the advantage of ensuring that the\nbody parsing middleware only executes for routes that require the processing.\nWhile the middleware has some checks to ensure it only triggers for HTTP\nmethods that accept bodies, those checks are still overhead that you might want\nto avoid; the above strategy of using the middleware only with specific routes\ncan accomplish that.\n\n\nStrategies\n\n\nIf you want to intercept and parse other payload types, you can add \nstrategies\n\nto the middleware. Strategies implement \nZend\\Expressive\\Helper\\BodyParams\\StrategyInterface\n:\n\n\nnamespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     *\n     * @param string $contentType\n     * @return bool Whether or not the strategy matches.\n     */\n    public function match($contentType);\n\n    /**\n     * Parse the body content and return a new response.\n     *\n     * @param ServerRequestInterface $request\n     * @return ServerRequestInterface\n     */\n    public function parse(ServerRequestInterface $request);\n}\n\n\n\nYou then register them with the middleware using the \naddStrategy()\n method:\n\n\n$bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n\n\n\nTo automate the registration, we recommend writing a factory for the\n\nBodyParamsMiddleware\n, and replacing the \ninvokables\n registration with a\nregistration in the \nfactories\n section of the \nmiddleware-pipeline.config.php\n\nfile:\n\n\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nRemoving the default strategies\n\n\nBy default, \nBodyParamsMiddleware\n composes the following strategies:\n\n\n\n\nZend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy\n\n\nZend\\Expressive\\Helper\\BodyParams\\JsonStrategy\n\n\n\n\nThese provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \u2014\n\napplication/x-www-form-urlencoded\n \u2014 matches first, as the middleware\ndelegates parsing to the first match.\n\n\nIf you do not want to use these default strategies, you can clear them from the\nmiddleware using \nclearStrategies()\n:\n\n\n$bodyParamsMiddleware->clearStrategies();\n\n\n\nNote: if you do this, \nall\n strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.",
            "title": "Body Parsing Middleware"
        },
        {
            "location": "/features/helpers/body-parse/#body-parsing-middleware",
            "text": "Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware  provides generic PSR-7\nmiddleware for parsing the request body into parameters, and returning a new\nrequest instance that composes them. The subcomponent provides a strategy\npattern around matching the request  Content-Type , and then parsing it, giving\nyou a flexible approach that can grow with your accepted content types.  By default, this middleware will detect the following content types:   application/x-www-form-urlencoded  (standard web-based forms, without file\n  uploads)  application/json ,  application/*+json  (JSON payloads)",
            "title": "Body Parsing Middleware"
        },
        {
            "location": "/features/helpers/body-parse/#registering-the-middleware",
            "text": "You can register it programmatically:  $app->pipe(BodyParamsMiddleware::class);  Alternately, register it via configuration, if using configuration-based applications:  // config/autoload/middleware-pipeline.global.php\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];  Since body parsing does not necessarily need to happen for every request, you\ncan also choose to incorporate it in route-specific middleware pipelines:  $app->post('/login', [\n    BodyParamsMiddleware::class,\n    LoginMiddleware::class,\n]);  If using a configuration-based application:  // config/autoload/routes.global.php\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'routes' => [\n        [\n            'name' => 'contact:process',\n            'path' => '/contact/process',\n            'middleware' => [\n                BodyParamsMiddleware::class,\n                Contact\\Process::class,\n            ],\n            'allowed_methods' => ['POST'],\n        ]\n    ],\n];  Using route-based middleware pipelines has the advantage of ensuring that the\nbody parsing middleware only executes for routes that require the processing.\nWhile the middleware has some checks to ensure it only triggers for HTTP\nmethods that accept bodies, those checks are still overhead that you might want\nto avoid; the above strategy of using the middleware only with specific routes\ncan accomplish that.",
            "title": "Registering the middleware"
        },
        {
            "location": "/features/helpers/body-parse/#strategies",
            "text": "If you want to intercept and parse other payload types, you can add  strategies \nto the middleware. Strategies implement  Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface :  namespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     *\n     * @param string $contentType\n     * @return bool Whether or not the strategy matches.\n     */\n    public function match($contentType);\n\n    /**\n     * Parse the body content and return a new response.\n     *\n     * @param ServerRequestInterface $request\n     * @return ServerRequestInterface\n     */\n    public function parse(ServerRequestInterface $request);\n}  You then register them with the middleware using the  addStrategy()  method:  $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());  To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the  invokables  registration with a\nregistration in the  factories  section of the  middleware-pipeline.config.php \nfile:  use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];",
            "title": "Strategies"
        },
        {
            "location": "/features/helpers/body-parse/#removing-the-default-strategies",
            "text": "By default,  BodyParamsMiddleware  composes the following strategies:   Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy  Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy   These provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded  \u2014 matches first, as the middleware\ndelegates parsing to the first match.  If you do not want to use these default strategies, you can clear them from the\nmiddleware using  clearStrategies() :  $bodyParamsMiddleware->clearStrategies();  Note: if you do this,  all  strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.",
            "title": "Removing the default strategies"
        },
        {
            "location": "/features/helpers/content-length/",
            "text": "Content-Length Middleware\n\n\n\n\nAvailable since zend-expressive-helpers version 4.1.0.\n\n\n\n\nIn some cases, you may want to include an explicit \nContent-Length\n response\nheader, without having to inject it manually. To facilitate this, we provide\n\nZend\\Expressive\\Helper\\ContentLengthMiddleware\n.\n\n\n\n\nWhen to use this middleware\n\n\nIn most cases, you do not need to provide an explicit Content-Length value\nin your responses. While the HTTP/1.1 specification indicates the header\nSHOULD be provided, most clients will not degrade to HTTP/1.0 if the header\nis omitted.\n\n\nThe one exception that has been reported is when working with\n\nNew Relic\n, which requires valid \nContent-Length\n\nheaders for some of its analytics; in such cases, enabling this middleware\nwill fix those situations.\n\n\n\n\nThis middleware delegates the request, and operates on the returned response. It\nwill return a new response with the \nContent-Length\n header injected under the\nfollowing conditions:\n\n\n\n\nNo \nContent-Length\n header is already present AND\n\n\nthe body size is non-null.\n\n\n\n\nTo register it in your application, you will need to do two things: register the\nmiddleware with the container, and register the middleware in either your\napplication pipeline, or within routed middleware.\n\n\nTo add it to your container, add the following configuration:\n\n\n// In a `config/autoload/*.global.php` file, or a `ConfigProvider` class:\n\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\ContentLengthMiddleware::class => Helper\\ContentLengthMiddleware::class,\n        ],\n    ],\n];\n\n\n\nTo register it as pipeline middleware to execute on any request:\n\n\n// In `config/pipeline.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->pipe(Helper\\ContentLengthMiddleware::class);\n\n\n\nTo register it within a routed middleware pipeline:\n\n\n// In `config/routes.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->get('/download/tarball', [\n    Helper\\ContentLengthMiddleware::class,\n    Download\\Tarball::class,\n], 'download-tar');\n\n\n\nCaveats\n\n\nOne caveat to note is that if you use this middleware, but also write directly\nto the output buffer (e.g., via a \nvar_dump\n, or if \ndisplay_errors\n is on and\nan uncaught error or exception occurs), the output will not appear as you\nexpect. Generally in such situations, the contents of the output buffer will\nappear, up to the specified \nContent-Length\n value. This can lead to truncated\nerror content and/or truncated application content.\n\n\nWe recommend that if you use this feature, you also use a PHP error and/or\nexception handler that logs errors in order to prevent truncated output.",
            "title": "Content-Length Middleware"
        },
        {
            "location": "/features/helpers/content-length/#content-length-middleware",
            "text": "Available since zend-expressive-helpers version 4.1.0.   In some cases, you may want to include an explicit  Content-Length  response\nheader, without having to inject it manually. To facilitate this, we provide Zend\\Expressive\\Helper\\ContentLengthMiddleware .",
            "title": "Content-Length Middleware"
        },
        {
            "location": "/features/helpers/content-length/#when-to-use-this-middleware",
            "text": "In most cases, you do not need to provide an explicit Content-Length value\nin your responses. While the HTTP/1.1 specification indicates the header\nSHOULD be provided, most clients will not degrade to HTTP/1.0 if the header\nis omitted.  The one exception that has been reported is when working with New Relic , which requires valid  Content-Length \nheaders for some of its analytics; in such cases, enabling this middleware\nwill fix those situations.   This middleware delegates the request, and operates on the returned response. It\nwill return a new response with the  Content-Length  header injected under the\nfollowing conditions:   No  Content-Length  header is already present AND  the body size is non-null.   To register it in your application, you will need to do two things: register the\nmiddleware with the container, and register the middleware in either your\napplication pipeline, or within routed middleware.  To add it to your container, add the following configuration:  // In a `config/autoload/*.global.php` file, or a `ConfigProvider` class:\n\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\ContentLengthMiddleware::class => Helper\\ContentLengthMiddleware::class,\n        ],\n    ],\n];  To register it as pipeline middleware to execute on any request:  // In `config/pipeline.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->pipe(Helper\\ContentLengthMiddleware::class);  To register it within a routed middleware pipeline:  // In `config/routes.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->get('/download/tarball', [\n    Helper\\ContentLengthMiddleware::class,\n    Download\\Tarball::class,\n], 'download-tar');",
            "title": "When to use this middleware"
        },
        {
            "location": "/features/helpers/content-length/#caveats",
            "text": "One caveat to note is that if you use this middleware, but also write directly\nto the output buffer (e.g., via a  var_dump , or if  display_errors  is on and\nan uncaught error or exception occurs), the output will not appear as you\nexpect. Generally in such situations, the contents of the output buffer will\nappear, up to the specified  Content-Length  value. This can lead to truncated\nerror content and/or truncated application content.  We recommend that if you use this feature, you also use a PHP error and/or\nexception handler that logs errors in order to prevent truncated output.",
            "title": "Caveats"
        },
        {
            "location": "/features/emitters/",
            "text": "Emitters\n\n\nTo simplify the usage of Expressive, we added the \nrun()\n method, which handles\nthe incoming request, and emits a response.\n\n\nThe latter aspect, emitting the response, is the responsibility of an\n\nemitter\n.\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.\n\n\nDiactoros defines an \nEmitterInterface\n, and \u2014 as of the time we write this \u2014 a\nsingle emitter implementation, \nZend\\Diactoros\\Response\\SapiEmitter\n, which\nsends headers and output using PHP's standard SAPI mechanisms (the \nheader()\n\nmethod and the output buffer).\n\n\nWe recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use \nReact\n, the SAPI\nemitter will likely not work for you.\n\n\nTo facilitate alternate emitters, we offer two facilities:\n\n\n\n\nFirst, \nApplication\n composes an emitter, and you can specify an alternate\n  emitter during instantiation, or via the \nZend\\Diactoros\\Response\\EmitterInterface\n\n  service when using the container factory.\n\n\nSecond, we provide \nZend\\Expressive\\Emitter\\EmitterStack\n, which allows you to\n  compose multiple emitter strategies; the first to return a value other than\n  boolean \nfalse\n will cause execution of the stack to short-circuit.\n  \nApplication\n composes an \nEmitterStack\n by default, with an \nSapiEmitter\n\n  composed at the bottom of the stack.\n\n\n\n\nEmitterStack\n\n\nThe \nEmitterStack\n is an \nSplStack\n extension that implements\n\nEmitterInterface\n. You can add emitters to the stack by pushing them on:\n\n\n$stack->push($emitterInstance);\n\n\n\nAs a stack, execution is in LIFO (last in, first out) order; the first emitter\non the stack will be evaluated last.",
            "title": "Emitters"
        },
        {
            "location": "/features/emitters/#emitters",
            "text": "To simplify the usage of Expressive, we added the  run()  method, which handles\nthe incoming request, and emits a response.  The latter aspect, emitting the response, is the responsibility of an emitter .\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.  Diactoros defines an  EmitterInterface , and \u2014 as of the time we write this \u2014 a\nsingle emitter implementation,  Zend\\Diactoros\\Response\\SapiEmitter , which\nsends headers and output using PHP's standard SAPI mechanisms (the  header() \nmethod and the output buffer).  We recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use  React , the SAPI\nemitter will likely not work for you.  To facilitate alternate emitters, we offer two facilities:   First,  Application  composes an emitter, and you can specify an alternate\n  emitter during instantiation, or via the  Zend\\Diactoros\\Response\\EmitterInterface \n  service when using the container factory.  Second, we provide  Zend\\Expressive\\Emitter\\EmitterStack , which allows you to\n  compose multiple emitter strategies; the first to return a value other than\n  boolean  false  will cause execution of the stack to short-circuit.\n   Application  composes an  EmitterStack  by default, with an  SapiEmitter \n  composed at the bottom of the stack.",
            "title": "Emitters"
        },
        {
            "location": "/features/emitters/#emitterstack",
            "text": "The  EmitterStack  is an  SplStack  extension that implements EmitterInterface . You can add emitters to the stack by pushing them on:  $stack->push($emitterInstance);  As a stack, execution is in LIFO (last in, first out) order; the first emitter\non the stack will be evaluated last.",
            "title": "EmitterStack"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/",
            "text": "How can I autowire routes and pipelines?\n\n\nExpressive 2.0 switches to \nprogrammatic\n pipelines and routes, versus\n\nconfiguration-driven\n pipelines and routing. One drawback is that with\nconfiguration-driven approaches, users could provide configuration via a module\n\nConfigProvider\n, and automatically expose new pipeline middleware or routes;\nwith a programmatic approach, this is no longer possible.\n\n\nOr is it?\n\n\nDelegator Factories\n\n\nOne possibility, available since the Expressive 2.X skeleton application, is to\nuse \ndelegator factories\n on the \nZend\\Expressive\\Application\n instance in order\nto inject these items.\n\n\nA \ndelegator factory\n is a factory that \ndelegates\n creation of an instance to a\ncallback, and then operates on that instance for the purpose of altering the\ninstance or providing a replacement (e.g., a decorator or proxy). The delegate\ncallback usually wraps a service factory, or, because delegator factories\n\nalso\n return an instance, additional delegator factories. As such, you assign\ndelegator \nfactories\n, plural, to instances, allowing multiple delegator\nfactories to intercept processing of the service initialization.\n\n\nFor the purposes of this particular example, we will use delegator factories to\nboth \npipe\n middleware as well as \nroute\n middleware.\n\n\nTo demonstrate, we'll take the default pipeline and routing from the skeleton\napplication, and provide it via a delegator factory instead.\n\n\nFirst, we'll create the class \nApp\\Factory\\PipelineAndRoutesDelegator\n, with\nthe following contents:\n\n\n<?php\n\nnamespace App\\Factory;\n\nuse App\\Action;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass PipelineAndRoutesDelegator\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $serviceName Name of the service being created.\n     * @param callable $callback Creates and returns the service.\n     * @return Application\n     */\n    public function __invoke(ContainerInterface $container, $serviceName, callable $callback)\n    {\n        /** @var $app Application */\n        $app = $callback();\n\n        // Setup pipeline:\n        $app->pipe(ErrorHandler::class);\n        $app->pipe(ServerUrlMiddleware::class);\n        $app->pipeRoutingMiddleware();\n        $app->pipe(ImplicitHeadMiddleware::class);\n        $app->pipe(ImplicitOptionsMiddleware::class);\n        $app->pipe(UrlHelperMiddleware::class);\n        $app->pipeDispatchMiddleware();\n        $app->pipe(NotFoundHandler::class);\n\n        // Setup routes:\n        $app->get('/', Action\\HomePageAction::class, 'home');\n        $app->get('/api/ping', Action\\PingAction::class, 'api.ping');\n\n        return $app;\n    }\n}\n\n\n\n\n\nWhere to put the factory\n\n\nYou will place the factory class in one of the following locations:\n\n\n\n\nsrc/App/Factory/PipelineAndRoutesDelegator.php\n if using the default, flat,\n  application structure.\n\n\nsrc/App/src/Factory/PipelineAndRoutesDelegator.php\n if using the\n  recommended, modular, application structure.\n\n\n\n\n\n\nOnce you've created this, edit the class \nApp\\ConfigProvider\n; in it, we'll\nupdate the \ngetDependencies()\n method to add the delegator factory:\n\n\npublic function getDependencies()\n{\n    return [\n        /* . . . */\n        'delegators' => [\n            \\Zend\\Expressive\\Application::class => [\n                Factory\\PipelineAndRoutesDelegator::class,\n            ],\n        ],\n    ];\n}\n\n\n\n\n\nWhere is the ConfigProvider class?\n\n\nThe \nConfigProvider\n class is in one of the following locations:\n\n\n\n\nsrc/App/ConfigProvider.php\n if using the default, flat, application\n  structure.\n\n\nsrc/App/src/ConfigProvider.php\n using the recommended, modular, application\n  structure.\n\n\n\n\nWhy is an array assigned?\n\n\nAs noted above in the description of delegator factories, since each delegator\nfactory returns an instance, you can nest multiple delegator factories in\norder to shape initialization of a service. As such, they are assigned as an\n\narray\n to the service.\n\n\n\n\nOnce you've done this, you can remove:\n\n\n\n\nconfig/pipeline.php\n\n\nconfig/routes.php\n\n\nThe following lines from \npublic/index.php\n:\n\n\n\n\n// Import programmatic/declarative middleware pipeline and routing\n// configuration statements\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n\n\nIf you reload your application at this point, you should see that everything\ncontinues to work as expected!\n\n\nCaution: pipelines\n\n\nUsing delegator factories is a nice way to keep your routing and pipeline\nconfiguration close to the modules in which they are defined. However, there is\na caveat: you likely should \nnot\n register pipeline middleware in a delegator\nfactory \nother than within your root application module\n.\n\n\nThe reason for this is simple: pipelines are linear, and specific to your\napplication. If one module pipes in middleware, there's no guarantee it will be\npiped before or after your main pipeline, and no way to pipe the middleware at a\nposition in the middle of the pipeline!\n\n\nAs such:\n\n\n\n\nUse a \nconfig/pipeline.php\n file for your pipeline, \nOR\n\n\nEnsure you only define the pipeline in a \nsingle\n delegator factory on your\n  \nApplication\n instance.\n\n\n\n\nCaution: third-party, distributed modules\n\n\nIf you are developing a module to distribute as a package via\n\nComposer\n, \nyou should not autowire any delegator\nfactories that inject pipeline middleware or routes in the \nApplication\n.\n\n\nWhy?\n\n\nAs noted in the above section, pipelines should be created exactly once, at\nthe application level. Registering pipeline middleware within a distributable\npackage will very likely not have the intended consequences.\n\n\nIf you ship with pipeline middleware, we suggest that you:\n\n\n\n\nDocument the middleware, and where you anticipate it being used in the\n  middleware pipeline.\n\n\nDocument how to add the middleware service to dependency configuration, or\n  provide the dependency configuration via your module's \nConfigProvider\n.\n\n\n\n\nWith regards to routes, there are other considerations:\n\n\n\n\n\n\nRoutes defined by the package might conflict with the application, or with\n  other packages used by the application.\n\n\n\n\n\n\nRouting definitions are typically highly specific to the router implementation\n  in use. As an example, each of the currently supported router implementations\n  has a different syntax for placeholders:\n\n\n\n\n/user/:id\n + \"constraints\" configuration to define constraints (zend-router)\n\n\n/user/{id}\n + \"tokens\" configuration to define constraints (Aura.Router)\n\n\n/user/{id:\\d+}\n (FastRoute)\n\n\n\n\n\n\n\n\nYour application may have specific routing considerations or design.\n\n\n\n\n\n\nYou could, of course, detect what router is in use, and provide routing for each\nknown, supported router implementation within your delegator factory. We even\nrecommend doing exactly that. However, we note that such an approach does not\nsolve the other two points above.\n\n\nHowever, we still recommend \nshipping\n a delegator factory that would register\nyour routes, since routes \nare\n often a part of module design; just \ndo not\nautowire\n that delegator factory. This way, end-users who \ncan\n use the\ndefaults do not need to cut-and-paste routing definitions from your\ndocumentation into their own applications; they will instead opt-in to your\ndelegator factory by wiring it into their own configuration.\n\n\nSynopsis\n\n\n\n\nWe recommend using delegator factories for the purpose of autowiring routes,\n  and, with caveats, pipeline middleware:\n\n\nThe pipeline should be created exactly once, so calls to \npipe()\n should\n  occur in exactly \none\n delegator factory.\n\n\n\n\n\n\nDistributable packages should create a delegator factory for \nroutes only\n,\n  but \nshould not\n register the delegator factory by default.",
            "title": "Autowiring routes and pipeline middleware"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/#how-can-i-autowire-routes-and-pipelines",
            "text": "Expressive 2.0 switches to  programmatic  pipelines and routes, versus configuration-driven  pipelines and routing. One drawback is that with\nconfiguration-driven approaches, users could provide configuration via a module ConfigProvider , and automatically expose new pipeline middleware or routes;\nwith a programmatic approach, this is no longer possible.  Or is it?",
            "title": "How can I autowire routes and pipelines?"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/#delegator-factories",
            "text": "One possibility, available since the Expressive 2.X skeleton application, is to\nuse  delegator factories  on the  Zend\\Expressive\\Application  instance in order\nto inject these items.  A  delegator factory  is a factory that  delegates  creation of an instance to a\ncallback, and then operates on that instance for the purpose of altering the\ninstance or providing a replacement (e.g., a decorator or proxy). The delegate\ncallback usually wraps a service factory, or, because delegator factories also  return an instance, additional delegator factories. As such, you assign\ndelegator  factories , plural, to instances, allowing multiple delegator\nfactories to intercept processing of the service initialization.  For the purposes of this particular example, we will use delegator factories to\nboth  pipe  middleware as well as  route  middleware.  To demonstrate, we'll take the default pipeline and routing from the skeleton\napplication, and provide it via a delegator factory instead.  First, we'll create the class  App\\Factory\\PipelineAndRoutesDelegator , with\nthe following contents:  <?php\n\nnamespace App\\Factory;\n\nuse App\\Action;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass PipelineAndRoutesDelegator\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $serviceName Name of the service being created.\n     * @param callable $callback Creates and returns the service.\n     * @return Application\n     */\n    public function __invoke(ContainerInterface $container, $serviceName, callable $callback)\n    {\n        /** @var $app Application */\n        $app = $callback();\n\n        // Setup pipeline:\n        $app->pipe(ErrorHandler::class);\n        $app->pipe(ServerUrlMiddleware::class);\n        $app->pipeRoutingMiddleware();\n        $app->pipe(ImplicitHeadMiddleware::class);\n        $app->pipe(ImplicitOptionsMiddleware::class);\n        $app->pipe(UrlHelperMiddleware::class);\n        $app->pipeDispatchMiddleware();\n        $app->pipe(NotFoundHandler::class);\n\n        // Setup routes:\n        $app->get('/', Action\\HomePageAction::class, 'home');\n        $app->get('/api/ping', Action\\PingAction::class, 'api.ping');\n\n        return $app;\n    }\n}",
            "title": "Delegator Factories"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/#where-to-put-the-factory",
            "text": "You will place the factory class in one of the following locations:   src/App/Factory/PipelineAndRoutesDelegator.php  if using the default, flat,\n  application structure.  src/App/src/Factory/PipelineAndRoutesDelegator.php  if using the\n  recommended, modular, application structure.    Once you've created this, edit the class  App\\ConfigProvider ; in it, we'll\nupdate the  getDependencies()  method to add the delegator factory:  public function getDependencies()\n{\n    return [\n        /* . . . */\n        'delegators' => [\n            \\Zend\\Expressive\\Application::class => [\n                Factory\\PipelineAndRoutesDelegator::class,\n            ],\n        ],\n    ];\n}",
            "title": "Where to put the factory"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/#where-is-the-configprovider-class",
            "text": "The  ConfigProvider  class is in one of the following locations:   src/App/ConfigProvider.php  if using the default, flat, application\n  structure.  src/App/src/ConfigProvider.php  using the recommended, modular, application\n  structure.",
            "title": "Where is the ConfigProvider class?"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/#why-is-an-array-assigned",
            "text": "As noted above in the description of delegator factories, since each delegator\nfactory returns an instance, you can nest multiple delegator factories in\norder to shape initialization of a service. As such, they are assigned as an array  to the service.   Once you've done this, you can remove:   config/pipeline.php  config/routes.php  The following lines from  public/index.php :   // Import programmatic/declarative middleware pipeline and routing\n// configuration statements\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';  If you reload your application at this point, you should see that everything\ncontinues to work as expected!",
            "title": "Why is an array assigned?"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/#caution-pipelines",
            "text": "Using delegator factories is a nice way to keep your routing and pipeline\nconfiguration close to the modules in which they are defined. However, there is\na caveat: you likely should  not  register pipeline middleware in a delegator\nfactory  other than within your root application module .  The reason for this is simple: pipelines are linear, and specific to your\napplication. If one module pipes in middleware, there's no guarantee it will be\npiped before or after your main pipeline, and no way to pipe the middleware at a\nposition in the middle of the pipeline!  As such:   Use a  config/pipeline.php  file for your pipeline,  OR  Ensure you only define the pipeline in a  single  delegator factory on your\n   Application  instance.",
            "title": "Caution: pipelines"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/#caution-third-party-distributed-modules",
            "text": "If you are developing a module to distribute as a package via Composer ,  you should not autowire any delegator\nfactories that inject pipeline middleware or routes in the  Application .  Why?  As noted in the above section, pipelines should be created exactly once, at\nthe application level. Registering pipeline middleware within a distributable\npackage will very likely not have the intended consequences.  If you ship with pipeline middleware, we suggest that you:   Document the middleware, and where you anticipate it being used in the\n  middleware pipeline.  Document how to add the middleware service to dependency configuration, or\n  provide the dependency configuration via your module's  ConfigProvider .   With regards to routes, there are other considerations:    Routes defined by the package might conflict with the application, or with\n  other packages used by the application.    Routing definitions are typically highly specific to the router implementation\n  in use. As an example, each of the currently supported router implementations\n  has a different syntax for placeholders:   /user/:id  + \"constraints\" configuration to define constraints (zend-router)  /user/{id}  + \"tokens\" configuration to define constraints (Aura.Router)  /user/{id:\\d+}  (FastRoute)     Your application may have specific routing considerations or design.    You could, of course, detect what router is in use, and provide routing for each\nknown, supported router implementation within your delegator factory. We even\nrecommend doing exactly that. However, we note that such an approach does not\nsolve the other two points above.  However, we still recommend  shipping  a delegator factory that would register\nyour routes, since routes  are  often a part of module design; just  do not\nautowire  that delegator factory. This way, end-users who  can  use the\ndefaults do not need to cut-and-paste routing definitions from your\ndocumentation into their own applications; they will instead opt-in to your\ndelegator factory by wiring it into their own configuration.",
            "title": "Caution: third-party, distributed modules"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/#synopsis",
            "text": "We recommend using delegator factories for the purpose of autowiring routes,\n  and, with caveats, pipeline middleware:  The pipeline should be created exactly once, so calls to  pipe()  should\n  occur in exactly  one  delegator factory.    Distributable packages should create a delegator factory for  routes only ,\n  but  should not  register the delegator factory by default.",
            "title": "Synopsis"
        },
        {
            "location": "/cookbook/common-prefix-for-routes/",
            "text": "How can I prepend a common path to all my routes?\n\n\nYou may have multiple middlewares providing their own functionality:\n\n\n$middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$app = AppFactory::create();\n$app->pipe($middleware1);\n$app->pipe($middleware2);\n\n$app->run();\n\n\n\nLet's assume the above represents an API.\n\n\nAs your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path \n/api\n.\n\n\nThis is essentially the same problem as addressed in the\n\n\"Segregating your application to a subpath\"\n example.\n\n\nTo accomplish it:\n\n\n\n\nCreate a new application.\n\n\nPipe the previous application to the new one, under the path \n/api\n.\n\n\n\n\n$middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$api = AppFactory::create();\n$api->pipe($middleware1);\n$api->pipe($middleware2);\n\n$app = AppFactory::create();\n$app->pipe('/api', $api);\n\n$app->run();\n\n\n\nThe above works, because every \nApplication\n instance is itself middleware, and, more specifically,\nan instance of \nStratigility's \nMiddlewarePipe\n,\nwhich provides the ability to compose middleware.",
            "title": "Prepending a common path to all routes"
        },
        {
            "location": "/cookbook/common-prefix-for-routes/#how-can-i-prepend-a-common-path-to-all-my-routes",
            "text": "You may have multiple middlewares providing their own functionality:  $middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$app = AppFactory::create();\n$app->pipe($middleware1);\n$app->pipe($middleware2);\n\n$app->run();  Let's assume the above represents an API.  As your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path  /api .  This is essentially the same problem as addressed in the \"Segregating your application to a subpath\"  example.  To accomplish it:   Create a new application.  Pipe the previous application to the new one, under the path  /api .   $middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$api = AppFactory::create();\n$api->pipe($middleware1);\n$api->pipe($middleware2);\n\n$app = AppFactory::create();\n$app->pipe('/api', $api);\n\n$app->run();  The above works, because every  Application  instance is itself middleware, and, more specifically,\nan instance of  Stratigility's  MiddlewarePipe ,\nwhich provides the ability to compose middleware.",
            "title": "How can I prepend a common path to all my routes?"
        },
        {
            "location": "/cookbook/route-specific-pipeline/",
            "text": "How can I specify a route-specific middleware pipeline?\n\n\nSometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:\n\n\n\n\ncheck for authentication credentials\n\n\ncheck for authorization for the selected action\n\n\nparse the incoming body\n\n\nvalidate the parsed body parameters\n\n\n\n\nbefore\n you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.\n\n\nYou can accomplish this in one of two ways:\n\n\n\n\nHave your middleware service resolve to a \nMiddlewarePipe\n instance that\n  composes the various middlewares.\n\n\nSpecify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a \nMiddlewarePipe\n.\n\n\n\n\nResolving to a MiddlewarePipe\n\n\nYou can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($container->get('ApiResource'));\n\n        return $pipeline;\n    }\n}\n\n\n\nThis gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.\n\n\nOne alternative when using zend-servicemanager is to use a \ndelegator factory\n.\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($callback());\n\n        return $pipeline;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}\n\n\n\nWhen configuring the container, you'd do something like the following:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            'AuthenticationMiddleware' => '...',\n            'AuthorizationMiddleware' => '...',\n            'BodyParsingMiddleware' => '...',\n            'ValidationMiddleware' => '...',\n            'ApiResourceMiddleware' => '...',\n        ],\n        'delegators' => [\n            'ApiResourceMiddleware' => [\n                'ApiResourcePipelineDelegatorFactory',\n            ],\n        ],\n    ],\n];\n\n\n\nThis approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.\n\n\nMiddleware Arrays\n\n\nIf you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares in your configuration or when routing manually.\n\n\nVia configuration looks like this:\n\n\nreturn [\n    'routes' => [\n        [\n            'name' => 'api-resource',\n            'path' => '/api/resource[/{id:[a-f0-9]{32}}]',\n            'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'],\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n                'ApiResourceMiddleware',\n            ],\n        ],\n    ],\n];\n\n\n\nManual routing looks like this:\n\n\n$app->route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    'AuthenticationMiddleware',\n    'AuthorizationMiddleware',\n    'BodyParsingMiddleware',\n    'ValidationMiddleware',\n    'ApiResourceMiddleware',\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');\n\n\n\nWhen either of these approaches are used, the individual middleware listed\n\nMUST\n be one of the following:\n\n\n\n\nan instance of \nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n;\n\n\na callable middleware (will be decorated as interop middleware);\n\n\na service name of middleware available in the container;\n\n\na fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.\n\n\n\n\nThis approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.\n\n\nWhat about pipeline middleware configuration?\n\n\nWhat if you want to do this with your pipeline middleware configuration? The\nanswer is that the syntax is exactly the same!\n\n\nreturn [\n    'middleware_pipeline' => [\n        'api' => [\n            'path' => '/api',\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n            ],\n            'priority' => 100,\n        ],\n    ],\n];",
            "title": "Route-specific middleware pipelines"
        },
        {
            "location": "/cookbook/route-specific-pipeline/#how-can-i-specify-a-route-specific-middleware-pipeline",
            "text": "Sometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:   check for authentication credentials  check for authorization for the selected action  parse the incoming body  validate the parsed body parameters   before  you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.  You can accomplish this in one of two ways:   Have your middleware service resolve to a  MiddlewarePipe  instance that\n  composes the various middlewares.  Specify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a  MiddlewarePipe .",
            "title": "How can I specify a route-specific middleware pipeline?"
        },
        {
            "location": "/cookbook/route-specific-pipeline/#resolving-to-a-middlewarepipe",
            "text": "You can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.  use Psr\\Container\\ContainerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($container->get('ApiResource'));\n\n        return $pipeline;\n    }\n}  This gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.  One alternative when using zend-servicemanager is to use a  delegator factory .\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:  use Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($callback());\n\n        return $pipeline;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}  When configuring the container, you'd do something like the following:  return [\n    'dependencies' => [\n        'factories' => [\n            'AuthenticationMiddleware' => '...',\n            'AuthorizationMiddleware' => '...',\n            'BodyParsingMiddleware' => '...',\n            'ValidationMiddleware' => '...',\n            'ApiResourceMiddleware' => '...',\n        ],\n        'delegators' => [\n            'ApiResourceMiddleware' => [\n                'ApiResourcePipelineDelegatorFactory',\n            ],\n        ],\n    ],\n];  This approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.",
            "title": "Resolving to a MiddlewarePipe"
        },
        {
            "location": "/cookbook/route-specific-pipeline/#middleware-arrays",
            "text": "If you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares in your configuration or when routing manually.  Via configuration looks like this:  return [\n    'routes' => [\n        [\n            'name' => 'api-resource',\n            'path' => '/api/resource[/{id:[a-f0-9]{32}}]',\n            'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'],\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n                'ApiResourceMiddleware',\n            ],\n        ],\n    ],\n];  Manual routing looks like this:  $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    'AuthenticationMiddleware',\n    'AuthorizationMiddleware',\n    'BodyParsingMiddleware',\n    'ValidationMiddleware',\n    'ApiResourceMiddleware',\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');  When either of these approaches are used, the individual middleware listed MUST  be one of the following:   an instance of  Interop\\Http\\ServerMiddleware\\MiddlewareInterface ;  a callable middleware (will be decorated as interop middleware);  a service name of middleware available in the container;  a fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.   This approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.",
            "title": "Middleware Arrays"
        },
        {
            "location": "/cookbook/route-specific-pipeline/#what-about-pipeline-middleware-configuration",
            "text": "What if you want to do this with your pipeline middleware configuration? The\nanswer is that the syntax is exactly the same!  return [\n    'middleware_pipeline' => [\n        'api' => [\n            'path' => '/api',\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n            ],\n            'priority' => 100,\n        ],\n    ],\n];",
            "title": "What about pipeline middleware configuration?"
        },
        {
            "location": "/cookbook/custom-404-page-handling/",
            "text": "How can I set custom 404 page handling?\n\n\n\n\nDeprecated\n\n\nThis recipe is deprecated with the release of Expressive 2.0, as that release\nnow expects and requires that you provide innermost middleware that will\nreturn a response, and provides \nZend\\Expressive\\Middleware\\NotFoundHandler\n\nas a default implementation. Please see the \nerror handling chapter\n\nfor more information.\n\n\n\n\nIn some cases, you may want to handle 404 errors separately from the\n\nfinal handler\n. This can be done by registering\nmiddleware that operates late \u2014 specifically, after the routing\nmiddleware. Such middleware will be executed if no other middleware has\nexecuted, and/or when all other middleware calls \nreturn $next()\n\nwithout returning a response. Such situations typically mean that no middleware\nwas able to complete the request.\n\n\nYour 404 handler can take one of two approaches:\n\n\n\n\nIt can set the response status and call \n$next()\n with an error condition. In\n  such a case, the final handler \nwill\n likely be executed, but will have an\n  explicit 404 status to work with.\n\n\nIt can create and return a 404 response itself.\n\n\n\n\nCalling next with an error condition\n\n\nIn the first approach, the \nNotFound\n middleware can be as simple as this:\n\n\nnamespace App;\n\nclass NotFound\n{\n    public function __invoke($req, $res, $next)\n    {\n        // Other things can be done here; e.g., logging\n        return $next($req, $res->withStatus(404), 'Page Not Found');\n    }\n}\n\n\n\nThis example uses the third, optional argument to \n$next()\n, which is an error\ncondition. Internally, the final handler will typically see this, and return an\nerror page of some sort. Since we set the response status, and it's an error\nstatus code, that status code will be used in the generated response.\n\n\nThe \nTemplatedErrorHandler\n will use the error template in this particular case,\nso you will likely need to make some accommodations for 404 responses in that\ntemplate if you choose this approach.\n\n\n404 Middleware\n\n\nIn the second approach, the \nNotFound\n middleware will return a full response.\nIn our example here, we will render a specific template, and use this to seed\nand return a response.\n\n\nnamespace App;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass NotFound\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function __invoke($req, $res, $next)\n    {\n        // other things can be done here; e.g., logging\n        // Now set the response status and write to the body\n        $response = $res->withStatus(404);\n        $response->getBody()->write($this->renderer->render('error::not-found'));\n        return $response;\n    }\n}\n\n\n\nThis approach allows you to have an application-specific workflow for 404 errors\nthat does not rely on the final handler.\n\n\nRegistering custom 404 handlers\n\n\nWe can register either \nApp\\NotFound\n class above as service in the\n\nservice container\n. In the case of the second approach,\nyou would also need to provide a factory for creating the middleware (to ensure\nyou inject the template renderer).\n\n\nFrom there, you still need to register the middleware. This middleware is not\nrouted, and thus needs to be piped to the application instance. You can do this\nvia either configuration, or manually.\n\n\nTo do this via configuration, add an entry under the \nmiddleware_pipeline\n\nconfiguration, after the dispatch middleware:\n\n\n'middleware_pipeline' => [\n    /* ... */\n    'routing' => [\n        'middleware' => [\n            Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n            Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n            Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        ],\n        'priority' => 1,\n    ],\n    [\n        'middleware' => 'App\\NotFound',\n        'priority' => -1,\n    ],\n    /* ... */\n],\n\n\n\nThe above example assumes you are using the \nApplicationFactory\n and/or the\nExpressive skeleton to manage your application instantiation and configuration.\n\n\nTo manually add the middleware, you will need to pipe it to the application\ninstance:\n\n\n$app->pipe($container->get('App\\NotFound'));\n\n\n\nThis must be done \nafter\n:\n\n\n\n\ncalling \n$app->pipeDispatchMiddleware()\n, \nOR\n\n\npulling the \nApplication\n instance from the service container (assuming you\n  used the \nApplicationFactory\n).\n\n\n\n\nThis is to ensure that the \nNotFound\n middleware executes \nafter\n any routed\nmiddleware, as you only want it to execute if no routed middleware was selected.",
            "title": "Setting custom 404 page handling"
        },
        {
            "location": "/cookbook/custom-404-page-handling/#how-can-i-set-custom-404-page-handling",
            "text": "",
            "title": "How can I set custom 404 page handling?"
        },
        {
            "location": "/cookbook/custom-404-page-handling/#deprecated",
            "text": "This recipe is deprecated with the release of Expressive 2.0, as that release\nnow expects and requires that you provide innermost middleware that will\nreturn a response, and provides  Zend\\Expressive\\Middleware\\NotFoundHandler \nas a default implementation. Please see the  error handling chapter \nfor more information.   In some cases, you may want to handle 404 errors separately from the final handler . This can be done by registering\nmiddleware that operates late \u2014 specifically, after the routing\nmiddleware. Such middleware will be executed if no other middleware has\nexecuted, and/or when all other middleware calls  return $next() \nwithout returning a response. Such situations typically mean that no middleware\nwas able to complete the request.  Your 404 handler can take one of two approaches:   It can set the response status and call  $next()  with an error condition. In\n  such a case, the final handler  will  likely be executed, but will have an\n  explicit 404 status to work with.  It can create and return a 404 response itself.",
            "title": "Deprecated"
        },
        {
            "location": "/cookbook/custom-404-page-handling/#calling-next-with-an-error-condition",
            "text": "In the first approach, the  NotFound  middleware can be as simple as this:  namespace App;\n\nclass NotFound\n{\n    public function __invoke($req, $res, $next)\n    {\n        // Other things can be done here; e.g., logging\n        return $next($req, $res->withStatus(404), 'Page Not Found');\n    }\n}  This example uses the third, optional argument to  $next() , which is an error\ncondition. Internally, the final handler will typically see this, and return an\nerror page of some sort. Since we set the response status, and it's an error\nstatus code, that status code will be used in the generated response.  The  TemplatedErrorHandler  will use the error template in this particular case,\nso you will likely need to make some accommodations for 404 responses in that\ntemplate if you choose this approach.",
            "title": "Calling next with an error condition"
        },
        {
            "location": "/cookbook/custom-404-page-handling/#404-middleware",
            "text": "In the second approach, the  NotFound  middleware will return a full response.\nIn our example here, we will render a specific template, and use this to seed\nand return a response.  namespace App;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass NotFound\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function __invoke($req, $res, $next)\n    {\n        // other things can be done here; e.g., logging\n        // Now set the response status and write to the body\n        $response = $res->withStatus(404);\n        $response->getBody()->write($this->renderer->render('error::not-found'));\n        return $response;\n    }\n}  This approach allows you to have an application-specific workflow for 404 errors\nthat does not rely on the final handler.",
            "title": "404 Middleware"
        },
        {
            "location": "/cookbook/custom-404-page-handling/#registering-custom-404-handlers",
            "text": "We can register either  App\\NotFound  class above as service in the service container . In the case of the second approach,\nyou would also need to provide a factory for creating the middleware (to ensure\nyou inject the template renderer).  From there, you still need to register the middleware. This middleware is not\nrouted, and thus needs to be piped to the application instance. You can do this\nvia either configuration, or manually.  To do this via configuration, add an entry under the  middleware_pipeline \nconfiguration, after the dispatch middleware:  'middleware_pipeline' => [\n    /* ... */\n    'routing' => [\n        'middleware' => [\n            Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n            Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n            Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        ],\n        'priority' => 1,\n    ],\n    [\n        'middleware' => 'App\\NotFound',\n        'priority' => -1,\n    ],\n    /* ... */\n],  The above example assumes you are using the  ApplicationFactory  and/or the\nExpressive skeleton to manage your application instantiation and configuration.  To manually add the middleware, you will need to pipe it to the application\ninstance:  $app->pipe($container->get('App\\NotFound'));  This must be done  after :   calling  $app->pipeDispatchMiddleware() ,  OR  pulling the  Application  instance from the service container (assuming you\n  used the  ApplicationFactory ).   This is to ensure that the  NotFound  middleware executes  after  any routed\nmiddleware, as you only want it to execute if no routed middleware was selected.",
            "title": "Registering custom 404 handlers"
        },
        {
            "location": "/cookbook/using-custom-view-helpers/",
            "text": "How do you register custom view helpers when using zend-view?\n\n\nIf you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?\n\n\nAssuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for \nZend\\View\\HelperPluginManager\n, and it will\nbe injected into the \nPhpRenderer\n instance used. Since the \nHelperPluginManager\n\nis available, we can configure it.\n\n\nOpen the file \nconfig/autoload/templates.global.php\n. In that file, you'll see\nthree top-level keys:\n\n\nreturn [\n    'dependencies' => [ /* ... */ ],\n    'templates' => [ /* ... */ ],\n    'view_helpers' => [ /* ... */ ],\n];\n\n\n\nThe last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created.\n\nSee the zend-view custom helpers documentation\n\nfor information on how to populate this configuration.",
            "title": "Registering custom view helpers when using zend-view"
        },
        {
            "location": "/cookbook/using-custom-view-helpers/#how-do-you-register-custom-view-helpers-when-using-zend-view",
            "text": "If you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?  Assuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for  Zend\\View\\HelperPluginManager , and it will\nbe injected into the  PhpRenderer  instance used. Since the  HelperPluginManager \nis available, we can configure it.  Open the file  config/autoload/templates.global.php . In that file, you'll see\nthree top-level keys:  return [\n    'dependencies' => [ /* ... */ ],\n    'templates' => [ /* ... */ ],\n    'view_helpers' => [ /* ... */ ],\n];  The last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created. See the zend-view custom helpers documentation \nfor information on how to populate this configuration.",
            "title": "How do you register custom view helpers when using zend-view?"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/",
            "text": "How can I use zend-form view helpers?\n\n\nIf you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:\n\n\n\n\nzend-form\n\n\nzend-i18n\n\n\nzend-navigation\n\n\n\n\nBy default, only the view helpers directly available in zend-view are available;\nhow can you add the others?\n\n\nTo add the zend-form view helpers create a file \nconfig/autoload/zend-form.global.php\n\nwith the contents:\n\n\n<?php\nuse Zend\\Form\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();\n\n\n\nand that will essentially do everything needed.\n\n\nIf you installed Expressive via the skeleton, the service\n\nZend\\View\\HelperPluginManager\n is registered for you, and represents the helper\nplugin manager injected into the \nPhpRenderer\n instance. As such, you only need\nto configure this. The question is: where?\n\n\nYou have three options:\n\n\n\n\nReplace the \nHelperPluginManager\n factory with your own; or\n\n\nAdd a delegator factory to or extend the \nHelperPluginManager\n service to\n  inject the additional helper configuration; or\n\n\nAdd pipeline middleware that composes the \nHelperPluginManager\n and configures\n  it.\n\n\n\n\nReplacing the HelperPluginManager factory\n\n\nThe zend-view integration provides \nZend\\Expressive\\ZendView\\HelperPluginManagerFactory\n,\nand the Expressive skeleton registers it be default. The simplest solution for\nadding other helpers is to replace it with your own. In your own factory, you\nwill \nalso\n configure the plugin manager with the configuration from the\nzend-form component (or whichever other components you wish to use).\n\n\nnamespace Your\\Application;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\View\\HelperPluginManager;\n\nclass HelperPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $manager = new HelperPluginManager($container);\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = isset($config['view_helpers']) ? $config['view_helpers'] : [];\n        (new Config($config))->configureServiceManager($manager);\n\n        return $manager;\n    }\n}\n\n\n\nIn your \nconfig/autoload/templates.global.php\n file, change the line that reads:\n\n\nZend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class,\n\n\n\nto instead read as:\n\n\nZend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class,\n\n\n\nThis approach will work for any of the various containers supported.\n\n\nDelegator factories/service extension\n\n\nDelegator factories\n\nand \nservice extension\n\noperate on the same principle: they intercept after the original factory was\ncalled, and then operate on the generated instance, either modifying or\nreplacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the\ntime of writing, we're unaware of a mechanism for doing so in Aura.Di.\n\n\nzend-servicemanager\n\n\nYou'll first need to create a delegator factory:\n\n\nnamespace Your\\Application;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FormHelpersDelegatorFactory\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $helpers = $callback();\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = new Config($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}\n\n\n\nThe above creates an instance of \nZend\\ServiceManager\\Config\n, uses it to\nconfigure the already created \nZend\\View\\HelperPluginManager\n instance, and then\nreturns the plugin manager instance.\n\n\nFrom here, you'll add a \ndelegators\n configuration key in your\n\nconfig/autoload/templates.global.php\n file:\n\n\nreturn [\n    'dependencies' => [\n        'delegators' => [\n            Zend\\View\\HelperPluginManager::class => [\n                Your\\Application\\FormHelpersDelegatorFactory::class,\n            ],\n        ],\n        /* ... */\n    ],\n    'templates' => [\n        /* ... */\n    ],\n    'view_helpers' => [\n        /* ... */\n    ],\n];\n\n\n\nNote: delegator factories are keyed by the service they modify, and the value is\nan \narray\n of delegator factories, to allow multiple such factories to be in\nuse.\n\n\nPimple\n\n\nFor Pimple, we don't currently support configuration of service extensions, so\nyou'll need to edit the main container configuration file,\n\nconfig/container.php\n. Place the following anywhere after the factories and\ninvokables are defined:\n\n\n// The following assumes you've added the following import statements to\n// the start of the file:\n// use Zend\\ServiceManager\\Config as ServiceConfig;\n// use Zend\\View\\HelperPluginManager;\n$container[HelperPluginManager::class] = $container->extend(\n    HelperPluginManager::class,\n    function ($helpers, $container) {\n        $config = isset($container['config']) ? $container['config'] : [];\n        $config = new ServiceConfig($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n);\n\n\n\nPipeline middleware\n\n\nAnother option is to use pipeline middleware. This approach will\nrequire that the middleware execute on every request, which introduces (very\nslight) performance overhead. However, it's a portable method that works\nregardless of the container implementation you choose.\n\n\nFirst, define the middleware:\n\n\nnamespace Your\\Application\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Form\\View\\HelperConfig as FormHelperConfig;\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddleware implements MiddlewareInterface\n{\n    private $helpers;\n\n    public function __construct(HelperPluginManager $helpers)\n    {\n        $this->helpers = $helpers;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $config = new FormHelperConfig();\n        $config->configureServiceManager($this->helpers);\n        return $delegate->process($request);\n    }\n}\n\n\n\nYou'll also need a factory for the middleware, to ensure it receives the\n\nHelperPluginManager\n:\n\n\nnamespace Your\\Application\n\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return new FormHelpersMiddleware(\n            $container->get(HelperPluginManager::class)\n        );\n    }\n}\n\n\n\nNext, register the middleware with its factory in one of\n\nconfig/autoload/middleware-pipeline.global.php\n or\n\nconfig/autoload/dependencies.global.php\n:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIf using programmatic pipelines, pipe the middleware in an appropriate location\nin your pipeline:\n\n\n$app->pipe(FormHelpersMiddleware::class);\n\n// or, perhaps, in a route-specific middleware pipeline:\n$app->post('/register', [\n    FormHelpersMiddleware::class,\n    RegisterMiddleware::class,\n], 'register');\n\n\n\nIf using configuration-driven pipelines or routing:\n\n\n// Via the middleware pipeline:\n'middleware_pipeline' => [\n    ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000],\n],\n\n// Or via routes:\n'routes' => [\n    [\n        'name'            => 'register',\n        'path'            => '/register',\n        'middleware'      => [\n            FormHelpersMiddleware::class,\n            RegisterMiddleware::class,\n        ],\n        'allowed_methods' => ['POST'],\n    ]\n]\n\n\n\nAt that point, you're all set!\n\n\nRegistering more helpers\n\n\nWhat if you need to register helpers from multiple components?\n\n\nYou can do so using the same technique above. Better yet, do them all at once!\n\n\n\n\nIf you chose to use delegator factories/service extension, do all helper\n  configuration registrations for all components in the same factory.\n\n\nIf you chose to use middleware, do all helper configuration registrations for\n  all components in the same middleware.",
            "title": "Using zend-form view helpers"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/#how-can-i-use-zend-form-view-helpers",
            "text": "If you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:   zend-form  zend-i18n  zend-navigation   By default, only the view helpers directly available in zend-view are available;\nhow can you add the others?  To add the zend-form view helpers create a file  config/autoload/zend-form.global.php \nwith the contents:  <?php\nuse Zend\\Form\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();  and that will essentially do everything needed.  If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager  is registered for you, and represents the helper\nplugin manager injected into the  PhpRenderer  instance. As such, you only need\nto configure this. The question is: where?  You have three options:   Replace the  HelperPluginManager  factory with your own; or  Add a delegator factory to or extend the  HelperPluginManager  service to\n  inject the additional helper configuration; or  Add pipeline middleware that composes the  HelperPluginManager  and configures\n  it.",
            "title": "How can I use zend-form view helpers?"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/#replacing-the-helperpluginmanager-factory",
            "text": "The zend-view integration provides  Zend\\Expressive\\ZendView\\HelperPluginManagerFactory ,\nand the Expressive skeleton registers it be default. The simplest solution for\nadding other helpers is to replace it with your own. In your own factory, you\nwill  also  configure the plugin manager with the configuration from the\nzend-form component (or whichever other components you wish to use).  namespace Your\\Application;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\View\\HelperPluginManager;\n\nclass HelperPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $manager = new HelperPluginManager($container);\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = isset($config['view_helpers']) ? $config['view_helpers'] : [];\n        (new Config($config))->configureServiceManager($manager);\n\n        return $manager;\n    }\n}  In your  config/autoload/templates.global.php  file, change the line that reads:  Zend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class,  to instead read as:  Zend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class,  This approach will work for any of the various containers supported.",
            "title": "Replacing the HelperPluginManager factory"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/#delegator-factoriesservice-extension",
            "text": "Delegator factories \nand  service extension \noperate on the same principle: they intercept after the original factory was\ncalled, and then operate on the generated instance, either modifying or\nreplacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the\ntime of writing, we're unaware of a mechanism for doing so in Aura.Di.",
            "title": "Delegator factories/service extension"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/#zend-servicemanager",
            "text": "You'll first need to create a delegator factory:  namespace Your\\Application;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FormHelpersDelegatorFactory\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $helpers = $callback();\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = new Config($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}  The above creates an instance of  Zend\\ServiceManager\\Config , uses it to\nconfigure the already created  Zend\\View\\HelperPluginManager  instance, and then\nreturns the plugin manager instance.  From here, you'll add a  delegators  configuration key in your config/autoload/templates.global.php  file:  return [\n    'dependencies' => [\n        'delegators' => [\n            Zend\\View\\HelperPluginManager::class => [\n                Your\\Application\\FormHelpersDelegatorFactory::class,\n            ],\n        ],\n        /* ... */\n    ],\n    'templates' => [\n        /* ... */\n    ],\n    'view_helpers' => [\n        /* ... */\n    ],\n];  Note: delegator factories are keyed by the service they modify, and the value is\nan  array  of delegator factories, to allow multiple such factories to be in\nuse.",
            "title": "zend-servicemanager"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/#pimple",
            "text": "For Pimple, we don't currently support configuration of service extensions, so\nyou'll need to edit the main container configuration file, config/container.php . Place the following anywhere after the factories and\ninvokables are defined:  // The following assumes you've added the following import statements to\n// the start of the file:\n// use Zend\\ServiceManager\\Config as ServiceConfig;\n// use Zend\\View\\HelperPluginManager;\n$container[HelperPluginManager::class] = $container->extend(\n    HelperPluginManager::class,\n    function ($helpers, $container) {\n        $config = isset($container['config']) ? $container['config'] : [];\n        $config = new ServiceConfig($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n);",
            "title": "Pimple"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/#pipeline-middleware",
            "text": "Another option is to use pipeline middleware. This approach will\nrequire that the middleware execute on every request, which introduces (very\nslight) performance overhead. However, it's a portable method that works\nregardless of the container implementation you choose.  First, define the middleware:  namespace Your\\Application\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Form\\View\\HelperConfig as FormHelperConfig;\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddleware implements MiddlewareInterface\n{\n    private $helpers;\n\n    public function __construct(HelperPluginManager $helpers)\n    {\n        $this->helpers = $helpers;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $config = new FormHelperConfig();\n        $config->configureServiceManager($this->helpers);\n        return $delegate->process($request);\n    }\n}  You'll also need a factory for the middleware, to ensure it receives the HelperPluginManager :  namespace Your\\Application\n\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return new FormHelpersMiddleware(\n            $container->get(HelperPluginManager::class)\n        );\n    }\n}  Next, register the middleware with its factory in one of config/autoload/middleware-pipeline.global.php  or config/autoload/dependencies.global.php :  return [\n    'dependencies' => [\n        'factories' => [\n            Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  If using programmatic pipelines, pipe the middleware in an appropriate location\nin your pipeline:  $app->pipe(FormHelpersMiddleware::class);\n\n// or, perhaps, in a route-specific middleware pipeline:\n$app->post('/register', [\n    FormHelpersMiddleware::class,\n    RegisterMiddleware::class,\n], 'register');  If using configuration-driven pipelines or routing:  // Via the middleware pipeline:\n'middleware_pipeline' => [\n    ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000],\n],\n\n// Or via routes:\n'routes' => [\n    [\n        'name'            => 'register',\n        'path'            => '/register',\n        'middleware'      => [\n            FormHelpersMiddleware::class,\n            RegisterMiddleware::class,\n        ],\n        'allowed_methods' => ['POST'],\n    ]\n]  At that point, you're all set!",
            "title": "Pipeline middleware"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/#registering-more-helpers",
            "text": "What if you need to register helpers from multiple components?  You can do so using the same technique above. Better yet, do them all at once!   If you chose to use delegator factories/service extension, do all helper\n  configuration registrations for all components in the same factory.  If you chose to use middleware, do all helper configuration registrations for\n  all components in the same middleware.",
            "title": "Registering more helpers"
        },
        {
            "location": "/cookbook/using-a-base-path/",
            "text": "How can I tell my application about a base path?\n\n\nIn some environments, your application may be running in a subdirectory of your\nweb root. For example:\n\n\nvar/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php\n\n\n\nwhere \n/var/www\n is the web root, and your Expressive application is in the\n\nexpressive/\n subdirectory. How can you make your application work correctly in\nthis environment?\n\n\n.htaccess in the application root.\n\n\nIf you are using Apache, your first step is to add an \n.htaccess\n file to your\napplication root, with directives for rewriting to the \npublic/\n directory:\n\n\nRewriteEngine On\nRewriteRule (.*) ./public/$1\n\n\n\n\n\nUsing other web servers\n\n\nIf you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to\n\nour issue tracker\n!\n\n\n\n\nUse middleware to rewrite the path\n\n\nThe above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!\n\n\nTo do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.\n\n\nAt the time of writing, we have two suggestions:\n\n\n\n\nlos/basepath\n provides the basic\n  mechanics of rewriting the URL, and has a stable release.\n\n\nmtymek/blast-base-url\n provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path, but does not have a stable release yet.\n\n\n\n\nlos/basepath\n\n\nTo use \nlos/basepath\n, install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.\n\n\nTo install and copy the configuration:\n\n\n$ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php\n\n\n\nWe recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):\n\n\n$ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php\n\n\n\nThen edit one or both, to change the \nlos_basepath\n settings:\n\n\nreturn [\n    'los_basepath' => '<base path here>',\n    /* ... */\n];\n\n\n\nThe base path should be the portion of the web root leading up to the\n\nindex.php\n of your application. In the above example, this would be\n\n/expressive\n.\n\n\nmtymek/blast-base-url\n\n\nTo use \nmtymek/blast-base-url\n, install it via Composer, and register some\nconfiguration.\n\n\nTo install it:\n\n\n$ composer require mtymek/blast-base-url\n\n\n\nTo configure it, update the file \nconfig/autoload/middleware-pipeline.global.php\n,\nor \nconfig/autoload/dependencies.global.php\n to map the middleware to its factory:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Blast\\BaseUrl\\BaseUrlMiddleware::class => Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIf using programmatic pipelines, pipe the middleware early in your pipeline:\n\n\n$app->pipe(\\Blast\\BaseUrl\\BaseUrlMiddleware::class);\n\n\n\nFor configuration-driven pipelines, add an entry in your\n\nconfig/autoload/middleware-pipeline.global.php\n file:\n\n\n'middleware_pipeline' => [\n    ['middleware' => [Blast\\BaseUrl\\BaseUrlMiddleware::class], 'priority' => 1000],\n    /* ... */\n],\n\n\n\nAt this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.\n\n\nThe primary advantage of \nmtymek/blast-base-url\n is in its additional features:\n\n\n\n\nit injects \nZend\\Expressive\\Helper\\UrlHelper\n with the base path, allowing you \n  to create relative route-based URLs.\n\n\nit provides a new helper, \nBlast\\BaseUrl\\BasePathHelper\n, which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.\n\n\n\n\nTo enable these features, we'll add some configuration to\n\nconfig/autoload/dependencies.global.php\n file:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Blast\\BaseUrl\\BasePathHelper::class => Blast\\BaseUrl\\BasePathHelper::class,            \n            /* ... */\n        ],\n    ],\n];\n\n\n\nFinally, if you're using zend-view, you can register a new \"basePath\" helper in\nyour \nconfig/autoload/templates.global.php\n:\n\n\nreturn [\n    /* ... */\n    'view_helpers' => [\n        'factories' => [\n            'basePath' => Blast\\BaseUrl\\BasePathViewHelperFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nUsage of the \nBasePath\n helper is as follows:\n\n\n// where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this->basePath('/icons/favicon.ico');",
            "title": "Using Expressive from a subdirectory"
        },
        {
            "location": "/cookbook/using-a-base-path/#how-can-i-tell-my-application-about-a-base-path",
            "text": "In some environments, your application may be running in a subdirectory of your\nweb root. For example:  var/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php  where  /var/www  is the web root, and your Expressive application is in the expressive/  subdirectory. How can you make your application work correctly in\nthis environment?",
            "title": "How can I tell my application about a base path?"
        },
        {
            "location": "/cookbook/using-a-base-path/#htaccess-in-the-application-root",
            "text": "If you are using Apache, your first step is to add an  .htaccess  file to your\napplication root, with directives for rewriting to the  public/  directory:  RewriteEngine On\nRewriteRule (.*) ./public/$1",
            "title": ".htaccess in the application root."
        },
        {
            "location": "/cookbook/using-a-base-path/#using-other-web-servers",
            "text": "If you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to our issue tracker !",
            "title": "Using other web servers"
        },
        {
            "location": "/cookbook/using-a-base-path/#use-middleware-to-rewrite-the-path",
            "text": "The above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!  To do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.  At the time of writing, we have two suggestions:   los/basepath  provides the basic\n  mechanics of rewriting the URL, and has a stable release.  mtymek/blast-base-url  provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path, but does not have a stable release yet.",
            "title": "Use middleware to rewrite the path"
        },
        {
            "location": "/cookbook/using-a-base-path/#losbasepath",
            "text": "To use  los/basepath , install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.  To install and copy the configuration:  $ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php  We recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):  $ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php  Then edit one or both, to change the  los_basepath  settings:  return [\n    'los_basepath' => '<base path here>',\n    /* ... */\n];  The base path should be the portion of the web root leading up to the index.php  of your application. In the above example, this would be /expressive .",
            "title": "los/basepath"
        },
        {
            "location": "/cookbook/using-a-base-path/#mtymekblast-base-url",
            "text": "To use  mtymek/blast-base-url , install it via Composer, and register some\nconfiguration.  To install it:  $ composer require mtymek/blast-base-url  To configure it, update the file  config/autoload/middleware-pipeline.global.php ,\nor  config/autoload/dependencies.global.php  to map the middleware to its factory:  return [\n    'dependencies' => [\n        'factories' => [\n            Blast\\BaseUrl\\BaseUrlMiddleware::class => Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  If using programmatic pipelines, pipe the middleware early in your pipeline:  $app->pipe(\\Blast\\BaseUrl\\BaseUrlMiddleware::class);  For configuration-driven pipelines, add an entry in your config/autoload/middleware-pipeline.global.php  file:  'middleware_pipeline' => [\n    ['middleware' => [Blast\\BaseUrl\\BaseUrlMiddleware::class], 'priority' => 1000],\n    /* ... */\n],  At this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.  The primary advantage of  mtymek/blast-base-url  is in its additional features:   it injects  Zend\\Expressive\\Helper\\UrlHelper  with the base path, allowing you \n  to create relative route-based URLs.  it provides a new helper,  Blast\\BaseUrl\\BasePathHelper , which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.   To enable these features, we'll add some configuration to config/autoload/dependencies.global.php  file:  return [\n    'dependencies' => [\n        'invokables' => [\n            Blast\\BaseUrl\\BasePathHelper::class => Blast\\BaseUrl\\BasePathHelper::class,            \n            /* ... */\n        ],\n    ],\n];  Finally, if you're using zend-view, you can register a new \"basePath\" helper in\nyour  config/autoload/templates.global.php :  return [\n    /* ... */\n    'view_helpers' => [\n        'factories' => [\n            'basePath' => Blast\\BaseUrl\\BasePathViewHelperFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Usage of the  BasePath  helper is as follows:  // where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this->basePath('/icons/favicon.ico');",
            "title": "mtymek/blast-base-url"
        },
        {
            "location": "/cookbook/modular-layout/",
            "text": "How can I make my application modular?\n\n\n\n\nDEPRECATED\n\n\nStarting in Expressive 2.0, we now ship features to allow modular applications\nboth at the time of installation, or to add following installation. Please\nsee the chapter on \nmodular applications\n\nfor more details.\n\n\n\n\nZend Framework 2 applications have a concept of modules, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.\n\n\nWhile zend-modulemanager could be used with Expressive, we suggest another\napproach: modules that are based only on configuration. This powerful approach\ndoesn't affect performance, and offers extensive flexibility: each module can\nprovide its own services (with factories), default configuration, and routes. \n\n\nThis cookbook will show how to organize modules using \n\nmtymek/expressive-config-manager\n,\na lightweight library that aggregates and merges configuration, optionally caching it.\n\n\nInstall the configuration manager\n\n\nThe configuration manager is available in Packagist:\n\n\n$ composer require mtymek/expressive-config-manager\n\n\n\nGenerate your config\n\n\nThe default Expressive skeleton installs a \nconfig/config.php\n file, which\naggregates all configuration. When using the configuration manager, you will\nneed to replace the contents of that file with the following code: \n\n\n<?php\n\nuse Zend\\Expressive\\ConfigManager\\ConfigManager;\nuse Zend\\Expressive\\ConfigManager\\PhpFileProvider;\n\n$configManager = new ConfigManager([\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\nreturn new ArrayObject($configManager->getMergedConfig());\n\n\n\nIf you open your application in a browser, it should still work in exactly the\nsame way as it was before. Now you can start adding your modules.\n\n\nFirst module\n\n\nConfigManager\n does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nFor instance, this is how your module could provide its own routes:\n\n\nnamespace MyModule;\n\nclass ModuleConfig\n{\n    public function __invoke()\n    {\n        return [\n            'routes' => [\n                [\n                    'name' => 'api.list-transactions',\n                    'path' => '/api/transactions',\n                    'middleware' => App\\Action\\ListTransactionsAction::class,\n                    'allowed_methods' => ['GET'],\n                ],\n                [\n                    'name' => 'api.refund-transaction',\n                    'path' => '/api/refund',\n                    'middleware' => App\\Action\\RefundAction::class,\n                    'allowed_methods' => ['POST'],\n                ],\n            ],\n        ];\n    }\n}\n\n\n\nEnabling the module\n\n\nFinally, you can enable your module by adding a reference to your config class\nwithin the arguments of the \nConfigManager\n constructor in the \nconfig/config.php\n\nfile:\n\n\n$configManager = new ConfigManager([\n    MyModule\\ModuleConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\n\n\nCaching configuration\n\n\nIn order to provide configuration caching, two things must occur:\n\n\n\n\nFirst, you must define a \nconfig_cache_enabled\n key in your configuration\n  somewhere.\n\n\nSecond, you must pass a second argument to the \nConfigManager\n, the location\n  of the cache file to use.\n\n\n\n\nThe \nconfig_cache_enabled\n key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:\n\n\n\n\nconfig/autoload/global.php\n should define the value to \ntrue\n, as the\n  production setting.\n\n\nconfig/autoload/local.php\n should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be \nfalse\n.\n\n\n\n\n// config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];\n\n\n\nYou would then alter your \nconfig/config.php\n file to add the second argument.\nThe following example builds on the previous, and demonstrates having the\n\nAppConfig\n entry enabled. The configuration will be cached to\n\ndata/config-cache.php\n in the application root:\n\n\n$configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');\n\n\n\nWhen the configuration cache path is present, if the \nconfig_cache_enabled\n flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.\n\n\nFinal notes\n\n\nThis approach may look simple, but it is flexible and powerful:\n\n\n\n\nYou pass a list of config providers to the \nConfigManager\n constructor.\n\n\nConfiguration is merged in the same order as it is passed, with later entries\n  having precedence.\n\n\nYou can override module configuration using \n*.global.php\n and \n*.local.php\n files.\n\n\nIf cached config is found, \nConfigManager\n does not iterate over provider list.\n\n\n\n\nFor more details, please refer to the\n\nConfig Manager Documentation\n.",
            "title": "Building modular applications"
        },
        {
            "location": "/cookbook/modular-layout/#how-can-i-make-my-application-modular",
            "text": "",
            "title": "How can I make my application modular?"
        },
        {
            "location": "/cookbook/modular-layout/#deprecated",
            "text": "Starting in Expressive 2.0, we now ship features to allow modular applications\nboth at the time of installation, or to add following installation. Please\nsee the chapter on  modular applications \nfor more details.   Zend Framework 2 applications have a concept of modules, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.  While zend-modulemanager could be used with Expressive, we suggest another\napproach: modules that are based only on configuration. This powerful approach\ndoesn't affect performance, and offers extensive flexibility: each module can\nprovide its own services (with factories), default configuration, and routes.   This cookbook will show how to organize modules using  mtymek/expressive-config-manager ,\na lightweight library that aggregates and merges configuration, optionally caching it.",
            "title": "DEPRECATED"
        },
        {
            "location": "/cookbook/modular-layout/#install-the-configuration-manager",
            "text": "The configuration manager is available in Packagist:  $ composer require mtymek/expressive-config-manager",
            "title": "Install the configuration manager"
        },
        {
            "location": "/cookbook/modular-layout/#generate-your-config",
            "text": "The default Expressive skeleton installs a  config/config.php  file, which\naggregates all configuration. When using the configuration manager, you will\nneed to replace the contents of that file with the following code:   <?php\n\nuse Zend\\Expressive\\ConfigManager\\ConfigManager;\nuse Zend\\Expressive\\ConfigManager\\PhpFileProvider;\n\n$configManager = new ConfigManager([\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\nreturn new ArrayObject($configManager->getMergedConfig());  If you open your application in a browser, it should still work in exactly the\nsame way as it was before. Now you can start adding your modules.",
            "title": "Generate your config"
        },
        {
            "location": "/cookbook/modular-layout/#first-module",
            "text": "ConfigManager  does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  For instance, this is how your module could provide its own routes:  namespace MyModule;\n\nclass ModuleConfig\n{\n    public function __invoke()\n    {\n        return [\n            'routes' => [\n                [\n                    'name' => 'api.list-transactions',\n                    'path' => '/api/transactions',\n                    'middleware' => App\\Action\\ListTransactionsAction::class,\n                    'allowed_methods' => ['GET'],\n                ],\n                [\n                    'name' => 'api.refund-transaction',\n                    'path' => '/api/refund',\n                    'middleware' => App\\Action\\RefundAction::class,\n                    'allowed_methods' => ['POST'],\n                ],\n            ],\n        ];\n    }\n}",
            "title": "First module"
        },
        {
            "location": "/cookbook/modular-layout/#enabling-the-module",
            "text": "Finally, you can enable your module by adding a reference to your config class\nwithin the arguments of the  ConfigManager  constructor in the  config/config.php \nfile:  $configManager = new ConfigManager([\n    MyModule\\ModuleConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);",
            "title": "Enabling the module"
        },
        {
            "location": "/cookbook/modular-layout/#caching-configuration",
            "text": "In order to provide configuration caching, two things must occur:   First, you must define a  config_cache_enabled  key in your configuration\n  somewhere.  Second, you must pass a second argument to the  ConfigManager , the location\n  of the cache file to use.   The  config_cache_enabled  key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:   config/autoload/global.php  should define the value to  true , as the\n  production setting.  config/autoload/local.php  should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be  false .   // config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];  You would then alter your  config/config.php  file to add the second argument.\nThe following example builds on the previous, and demonstrates having the AppConfig  entry enabled. The configuration will be cached to data/config-cache.php  in the application root:  $configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');  When the configuration cache path is present, if the  config_cache_enabled  flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.",
            "title": "Caching configuration"
        },
        {
            "location": "/cookbook/modular-layout/#final-notes",
            "text": "This approach may look simple, but it is flexible and powerful:   You pass a list of config providers to the  ConfigManager  constructor.  Configuration is merged in the same order as it is passed, with later entries\n  having precedence.  You can override module configuration using  *.global.php  and  *.local.php  files.  If cached config is found,  ConfigManager  does not iterate over provider list.   For more details, please refer to the Config Manager Documentation .",
            "title": "Final notes"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/",
            "text": "How can I setup the locale depending on a routing parameter?\n\n\nLocalized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.\n\n\n\n\nRouting parameters\n\n\nUsing the approach in this chapter requires that you add a \n/:locale\n (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non \nsetting the locale without routing parameters\n.\n\n\n\n\nSetting up the route\n\n\nIf you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.\n\n\nIn the following examples, we use the \nlocale\n parameter, which should consist\nof two lowercase alphabetical characters.\n\n\nDependency configuration\n\n\nThe examples assume the following middleware dependency configuration:\n\n\nuse Application\\Action;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Action\\HomePageAction::class    => Action\\HomePageFactory::class,\n            Action\\ContactPageAction::class => Action\\ContactPageFactory::class,\n        ],\n    ],\n];\n\n\n\nProgrammatic routes\n\n\nThe following describes routing configuration for use when using a\nprogrammatic application.\n\n\nuse Application\\Action\\ContactPageAction;\nuse Application\\Action\\HomePageAction;\n\n$localeOptions = ['locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)'];\n\n$app->get('/:locale', HomePageAction::class, 'home')\n    ->setOptions($localeOptions);\n$app->get('/:locale/contact', ContactPageAction::class, 'contact')\n    ->setOptions($localeOptions);\n\n\n\nConfiguration-based routes\n\n\nThe following describes routing configuration for use when using a\nconfiguration-driven application.\n\n\nreturn [\n    'routes' => [\n        [\n            'name' => 'home',\n            'path' => '/:locale',\n            'middleware' => Application\\Action\\HomePageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n        [\n            'name' => 'contact',\n            'path' => '/:locale/contact',\n            'middleware' => Application\\Action\\ContactPageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nNote: Routing may differ based on router\n\n\nThe routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.\n\n\nFor Aura.Router, the 'home' route as listed above would read:\n\n\n[\n    'name' => 'home',\n    'path' => '/{locale}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n    'options'         => [\n        'constraints' => [\n            'tokens' => [\n                'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n            ],\n        ],\n    ],\n]\n\n\n\nFor FastRoute:\n\n\n[\n    'name' => 'home',\n    'path' => '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n]\n\n\n\nAs such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.\n\n\n\n\nCreate a route result middleware class for localization\n\n\nTo make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.\n\n\nSuch a \nLocalizationMiddleware\n class could look similar to this:\n\n\n<?php\n\nnamespace Application\\I18n;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass LocalizationMiddleware implements MiddlewareInterface\n{\n    const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request->getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $delegate->process($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale));\n    }\n}\n\n\n\n\n\nLocale::setDefault is unsafe\n\n\nDo not use \nLocale::setDefault($locale)\n to set a global static locale.\nPSR-7 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.\n\n\nUse a request parameter as detailed above instead, as the request is created\nspecific to each process.\n\n\n\n\nRegister this new middleware in either \nconfig/autoload/middleware-pipeline.global.php\n\nor \nconfig/autoload/dependencies.global.php\n:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            LocalizationMiddleware::class => LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIf using a programmatic pipeline, pipe it immediately after your routing middleware:\n\n\nuse Application\\I18n\\LocalizationMiddleware;\n\n/* ... */\n$app->pipeRoutingMiddleware();\n$app->pipe(LocalizationMiddleware::class);\n/* ... */\n\n\n\nIf using a configuration-driven application, register it within your \n\nconfig/autoload/middleware-pipeline.global.php\n file, injecting it\ninto the pipeline following the routing middleware:\n\n\nreturn [\n    'middleware_pipeline' => [\n        /* ... */\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                LocalizationMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];",
            "title": "Setting a locale based on a routing parameter"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#how-can-i-setup-the-locale-depending-on-a-routing-parameter",
            "text": "Localized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.",
            "title": "How can I setup the locale depending on a routing parameter?"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#routing-parameters",
            "text": "Using the approach in this chapter requires that you add a  /:locale  (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non  setting the locale without routing parameters .",
            "title": "Routing parameters"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#setting-up-the-route",
            "text": "If you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.  In the following examples, we use the  locale  parameter, which should consist\nof two lowercase alphabetical characters.",
            "title": "Setting up the route"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#dependency-configuration",
            "text": "The examples assume the following middleware dependency configuration:  use Application\\Action;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Action\\HomePageAction::class    => Action\\HomePageFactory::class,\n            Action\\ContactPageAction::class => Action\\ContactPageFactory::class,\n        ],\n    ],\n];",
            "title": "Dependency configuration"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#programmatic-routes",
            "text": "The following describes routing configuration for use when using a\nprogrammatic application.  use Application\\Action\\ContactPageAction;\nuse Application\\Action\\HomePageAction;\n\n$localeOptions = ['locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)'];\n\n$app->get('/:locale', HomePageAction::class, 'home')\n    ->setOptions($localeOptions);\n$app->get('/:locale/contact', ContactPageAction::class, 'contact')\n    ->setOptions($localeOptions);",
            "title": "Programmatic routes"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#configuration-based-routes",
            "text": "The following describes routing configuration for use when using a\nconfiguration-driven application.  return [\n    'routes' => [\n        [\n            'name' => 'home',\n            'path' => '/:locale',\n            'middleware' => Application\\Action\\HomePageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n        [\n            'name' => 'contact',\n            'path' => '/:locale/contact',\n            'middleware' => Application\\Action\\ContactPageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration-based routes"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#note-routing-may-differ-based-on-router",
            "text": "The routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.  For Aura.Router, the 'home' route as listed above would read:  [\n    'name' => 'home',\n    'path' => '/{locale}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n    'options'         => [\n        'constraints' => [\n            'tokens' => [\n                'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n            ],\n        ],\n    ],\n]  For FastRoute:  [\n    'name' => 'home',\n    'path' => '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n]  As such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.",
            "title": "Note: Routing may differ based on router"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#create-a-route-result-middleware-class-for-localization",
            "text": "To make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.  Such a  LocalizationMiddleware  class could look similar to this:  <?php\n\nnamespace Application\\I18n;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass LocalizationMiddleware implements MiddlewareInterface\n{\n    const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request->getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $delegate->process($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale));\n    }\n}",
            "title": "Create a route result middleware class for localization"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#localesetdefault-is-unsafe",
            "text": "Do not use  Locale::setDefault($locale)  to set a global static locale.\nPSR-7 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.  Use a request parameter as detailed above instead, as the request is created\nspecific to each process.   Register this new middleware in either  config/autoload/middleware-pipeline.global.php \nor  config/autoload/dependencies.global.php :  return [\n    'dependencies' => [\n        'invokables' => [\n            LocalizationMiddleware::class => LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  If using a programmatic pipeline, pipe it immediately after your routing middleware:  use Application\\I18n\\LocalizationMiddleware;\n\n/* ... */\n$app->pipeRoutingMiddleware();\n$app->pipe(LocalizationMiddleware::class);\n/* ... */  If using a configuration-driven application, register it within your  config/autoload/middleware-pipeline.global.php  file, injecting it\ninto the pipeline following the routing middleware:  return [\n    'middleware_pipeline' => [\n        /* ... */\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                LocalizationMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];",
            "title": "Locale::setDefault is unsafe"
        },
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/",
            "text": "How can I setup the locale without routing parameters?\n\n\nLocalized web applications often set the locale (and therefore the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.\n\n\n\n\nDistinguishing between routes that require localization\n\n\nIf your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the\n\n\"Setting a locale based on a routing parameter\" recipe\n.\n\n\n\n\nSetup a middleware to extract the locale from the URI\n\n\nFirst, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If if doesn't find one, it sets a default.\n\n\nIf it does find one, it uses the value to setup the locale. It also:\n\n\n\n\namends the request with a truncated path (removing the locale segment).\n\n\nadds the locale segment as the base path of the \nUrlHelper\n.\n\n\n\n\n<?php\nnamespace Application\\I18n;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $uri = $request->getUri();\n\n        $path = $uri->getPath();\n\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            Locale::setDefault('de_DE');\n            return $delegate->process($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $delegate->process($request->withUri(\n            $uri->withPath(substr($path, 3))\n        ));\n    }\n}\n\n\n\nThen you will need a factory for the \nSetLocaleMiddleware\n to inject the\n\nUrlHelper\n instance.\n\n\n<?php\nnamespace Application\\I18n;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SetLocaleMiddleware(\n            $container->get(UrlHelper::class)\n        );\n    }\n}\n\n\n\nNext, map the middleware to its factory in either\n\n/config/autoload/dependencies.global.php\n or\n\n/config/autoload/middleware-pipeline.global.php\n:\n\n\nuse Application\\I18n\\SetLocaleMiddleware;\nuse Application\\I18n\\SetLocaleMiddlewareFactory;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nFinally, you will need to configure your middleware pipeline to ensure this\nmiddleware is executed on every request.\n\n\nIf using a programmatic pipeline:\n\n\nuse Application\\I18n\\SetLocaleMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n/* ... */\n$app->pipe(SetLocaleMiddleware::class);\n/* ... */\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n/* ... */\n\n\n\nIf using a configuration-driven application, update\n\n/config/autoload/middleware-pipeline.global.php\n to add the middleware:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [\n            'middleware' => [\n                Application\\I18n\\SetLocaleMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 1000,\n        ],\n\n        /* ... */\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        /* ... */\n    ],\n];\n\n\n\nUrl generation in the view\n\n\nSince the \nUrlHelper\n has the locale set as a base path, you don't need \nto worry about generating URLs within your view. Just use the helper to \ngenerate a URL and it will do the rest.\n\n\n<?php echo $this->url('your-route') ?>\n\n\n\n\n\nHelpers differ between template renderers\n\n\nThe above example is specific to zend-view; syntax will differ for\nTwig and Plates.\n\n\n\n\nRedirecting within your middleware\n\n\nIf you want to add the locale parameter when creating URIs within your \naction middleware, you just need to inject the \nUrlHelper\n into your \nmiddleware and use it for URL generation:\n\n\n<?php\nnamespace Application\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectAction implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param DelegateInterface      $delegate\n     * @return RedirectResponse\n     */\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this->helper->generate('your-route', $routeParams)\n        );\n    }\n}\n\n\n\nInjecting the \nUrlHelper\n into your middleware will also require that the\nmiddleware have a factory that manages the injection. As an example, the\nfollowing would work for the above middleware:\n\n\nnamespace Application\\Action;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectAction(\n            $container->get(UrlHelper::class)\n        );\n    }\n}",
            "title": "Setting a locale without a routing parameter"
        },
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#how-can-i-setup-the-locale-without-routing-parameters",
            "text": "Localized web applications often set the locale (and therefore the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.",
            "title": "How can I setup the locale without routing parameters?"
        },
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#distinguishing-between-routes-that-require-localization",
            "text": "If your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the \"Setting a locale based on a routing parameter\" recipe .",
            "title": "Distinguishing between routes that require localization"
        },
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#setup-a-middleware-to-extract-the-locale-from-the-uri",
            "text": "First, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If if doesn't find one, it sets a default.  If it does find one, it uses the value to setup the locale. It also:   amends the request with a truncated path (removing the locale segment).  adds the locale segment as the base path of the  UrlHelper .   <?php\nnamespace Application\\I18n;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $uri = $request->getUri();\n\n        $path = $uri->getPath();\n\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            Locale::setDefault('de_DE');\n            return $delegate->process($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $delegate->process($request->withUri(\n            $uri->withPath(substr($path, 3))\n        ));\n    }\n}  Then you will need a factory for the  SetLocaleMiddleware  to inject the UrlHelper  instance.  <?php\nnamespace Application\\I18n;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SetLocaleMiddleware(\n            $container->get(UrlHelper::class)\n        );\n    }\n}  Next, map the middleware to its factory in either /config/autoload/dependencies.global.php  or /config/autoload/middleware-pipeline.global.php :  use Application\\I18n\\SetLocaleMiddleware;\nuse Application\\I18n\\SetLocaleMiddlewareFactory;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ],\n];  Finally, you will need to configure your middleware pipeline to ensure this\nmiddleware is executed on every request.  If using a programmatic pipeline:  use Application\\I18n\\SetLocaleMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n/* ... */\n$app->pipe(SetLocaleMiddleware::class);\n/* ... */\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n/* ... */  If using a configuration-driven application, update /config/autoload/middleware-pipeline.global.php  to add the middleware:  return [\n    'middleware_pipeline' => [\n        [\n            'middleware' => [\n                Application\\I18n\\SetLocaleMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 1000,\n        ],\n\n        /* ... */\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        /* ... */\n    ],\n];",
            "title": "Setup a middleware to extract the locale from the URI"
        },
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#url-generation-in-the-view",
            "text": "Since the  UrlHelper  has the locale set as a base path, you don't need \nto worry about generating URLs within your view. Just use the helper to \ngenerate a URL and it will do the rest.  <?php echo $this->url('your-route') ?>",
            "title": "Url generation in the view"
        },
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#helpers-differ-between-template-renderers",
            "text": "The above example is specific to zend-view; syntax will differ for\nTwig and Plates.",
            "title": "Helpers differ between template renderers"
        },
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#redirecting-within-your-middleware",
            "text": "If you want to add the locale parameter when creating URIs within your \naction middleware, you just need to inject the  UrlHelper  into your \nmiddleware and use it for URL generation:  <?php\nnamespace Application\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectAction implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param DelegateInterface      $delegate\n     * @return RedirectResponse\n     */\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this->helper->generate('your-route', $routeParams)\n        );\n    }\n}  Injecting the  UrlHelper  into your middleware will also require that the\nmiddleware have a factory that manages the injection. As an example, the\nfollowing would work for the above middleware:  namespace Application\\Action;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectAction(\n            $container->get(UrlHelper::class)\n        );\n    }\n}",
            "title": "Redirecting within your middleware"
        },
        {
            "location": "/cookbook/debug-toolbars/",
            "text": "How can I get a debug toolbar for my Expressive application?\n\n\nMany modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?\n\n\nZend Server Z-Ray\n\n\nZend Server\n ships with a tool\ncalled \nZ-Ray\n, which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently \navailable as a standalone technology\npreview\n, and can be added\nas an extension to an existing PHP installation.\n\n\nWhen using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the\n\nZ-Ray documentation\n\nfor full usage details.\n\n\nbitExpert/prophiler-psr7-middleware\n\n\nAnother option is bitExpert's \nprophiler-psr7-middleware\n.\nThis package wraps \nfabfuel/prophiler\n,\nwhich provides a PHP-based profiling tool and toolbar; the bitExpert package\nwraps this in PSR-7 middleware to make consumption in those paradigms trivial.\n\n\nTo add the toolbar middleware to your application, use composer:\n\n\n$ composer require bitExpert/prophiler-psr7-middleware\n\n\n\nFrom there, you will need to create a factory for the middleware, and add it to\nyour middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written\na \npost detailing these steps\n.\n\n\n\n\nUse locally!\n\n\nOne minor change we recommend over the directions Stephan provides is that you\nconfigure the factory and middleware in the\n\nconfig/autoload/middleware-pipeline.local.php\n file, vs the \n.global\n version.\nDoing so enables the middleware and toolbar only in the local environment\n\u2014 and not in production, where you likely do not want to expose such\ninformation!\n\n\n\n\nphp-middleware/php-debug-bar\n\n\nphp-middleware/php-debug-bar\n\nprovides a PSR-7 middleware wrapper around \nmaximebf/php-debugbar\n,\na popular framework-agnostic debug bar for PHP projects.\n\n\nFirst, install the middleware in your application:\n\n\n$ composer require php-middleware/php-debug-bar\n\n\n\nThis package supplies a config provider, which could be added to your\n\nconfig/config.php\n when using zend-config-aggregator or\nexpressive-config-manager. However, because it should only be enabled in\ndevelopment, we recommend creating a \"local\" configuration file (e.g.,\n\nconfig/autoload/php-debugbar.local.php\n) when you need to enable it, with the\nfollowing contents:\n\n\n<?php\nuse PhpMiddleware\\PhpDebugBar\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();\n\n\n\n\n\nUse locally!\n\n\nRemember to enable \nPhpMiddleware\\PhpDebugBar\\ConfigProvider\n only in your\ndevelopment enviroments!",
            "title": "Enabling debug toolbars"
        },
        {
            "location": "/cookbook/debug-toolbars/#how-can-i-get-a-debug-toolbar-for-my-expressive-application",
            "text": "Many modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?",
            "title": "How can I get a debug toolbar for my Expressive application?"
        },
        {
            "location": "/cookbook/debug-toolbars/#zend-server-z-ray",
            "text": "Zend Server  ships with a tool\ncalled  Z-Ray , which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently  available as a standalone technology\npreview , and can be added\nas an extension to an existing PHP installation.  When using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the Z-Ray documentation \nfor full usage details.",
            "title": "Zend Server Z-Ray"
        },
        {
            "location": "/cookbook/debug-toolbars/#bitexpertprophiler-psr7-middleware",
            "text": "Another option is bitExpert's  prophiler-psr7-middleware .\nThis package wraps  fabfuel/prophiler ,\nwhich provides a PHP-based profiling tool and toolbar; the bitExpert package\nwraps this in PSR-7 middleware to make consumption in those paradigms trivial.  To add the toolbar middleware to your application, use composer:  $ composer require bitExpert/prophiler-psr7-middleware  From there, you will need to create a factory for the middleware, and add it to\nyour middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written\na  post detailing these steps .",
            "title": "bitExpert/prophiler-psr7-middleware"
        },
        {
            "location": "/cookbook/debug-toolbars/#use-locally",
            "text": "One minor change we recommend over the directions Stephan provides is that you\nconfigure the factory and middleware in the config/autoload/middleware-pipeline.local.php  file, vs the  .global  version.\nDoing so enables the middleware and toolbar only in the local environment\n\u2014 and not in production, where you likely do not want to expose such\ninformation!",
            "title": "Use locally!"
        },
        {
            "location": "/cookbook/debug-toolbars/#php-middlewarephp-debug-bar",
            "text": "php-middleware/php-debug-bar \nprovides a PSR-7 middleware wrapper around  maximebf/php-debugbar ,\na popular framework-agnostic debug bar for PHP projects.  First, install the middleware in your application:  $ composer require php-middleware/php-debug-bar  This package supplies a config provider, which could be added to your config/config.php  when using zend-config-aggregator or\nexpressive-config-manager. However, because it should only be enabled in\ndevelopment, we recommend creating a \"local\" configuration file (e.g., config/autoload/php-debugbar.local.php ) when you need to enable it, with the\nfollowing contents:  <?php\nuse PhpMiddleware\\PhpDebugBar\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();",
            "title": "php-middleware/php-debug-bar"
        },
        {
            "location": "/cookbook/debug-toolbars/#use-locally_1",
            "text": "Remember to enable  PhpMiddleware\\PhpDebugBar\\ConfigProvider  only in your\ndevelopment enviroments!",
            "title": "Use locally!"
        },
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/",
            "text": "Handling multiple routes in a single class\n\n\nTypically, in Expressive, we would define one middleware class per route. For a\nstandard CRUD-style application, however, this leads to multiple related\nclasses:\n\n\n\n\nAlbumPageIndex\n\n\nAlbumPageEdit\n\n\nAlbumPageAdd\n\n\n\n\nIf you are familiar with frameworks that provide controllers capable of handling\nmultiple \"actions\", such as those found in Zend Framework's MVC layer, Symfony,\nCodeIgniter, CakePHP, and other popular frameworks, you may want to apply a\nsimilar pattern when using Expressive.\n\n\nIn other words, what if we want to use only one middleware class to facilitate\nall three of the above?\n\n\nIn the following example, we'll use an \naction\n routing parameter which our\nmiddleware class will use in order to determine which internal method to invoke.\n\n\nConsider the following route configuration:\n\n\nuse Album\\Action\\AlbumPage;\n\n// Programmatic:\n$app->get('/album[/{action:add|edit}[/{id}]]', AlbumPage::class, 'album');\n\n// Config-driven:\nreturn [\n    /* ... */\n    'routes' => [\n        /* ... */\n        [\n            'name'            => 'album',\n            'path'            => '/album[/{action:add|edit}[/{id}]]',\n            'middleware'      => AlbumPage::class,\n            'allowed_methods' => ['GET'],\n        ],\n        /* ... */\n    ],\n];\n\nThe above each define a route that will match any of the following:\n\n\n\n\n/album\n\n\n/album/add\n\n\n/album/edit/3\n\n\n\n\nThe \naction\n attribute can thus be one of \nadd\n or \nedit\n, and we can optionally\nalso receive an \nid\n attribute (in the latter example, it would be \n3\n).\n\n\n\n\nRouting definitions may vary\n\n\nDepending on the router you chose when starting your project, your routing\ndefinition may differ. The above example uses the default \nFastRoute\n\nimplementation.\n\n\n\n\nWe might then implement \nAlbum\\Action\\AlbumPage\n as follows:\n\n\n<?php\nnamespace Album\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage implements MiddlewareInterface\n{\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        switch ($request->getAttribute('action', 'index')) {\n            case 'index':\n                return $this->indexAction($request, $delegate);\n            case 'add':\n                return $this->addAction($request, $delegate);\n            case 'edit':\n                return $this->editAction($request, $delegate);\n            default:\n                // Invalid; thus, a 404!\n                return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n    }\n\n    public function indexAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new HtmlResponse($this->template->render('album::album-page'));\n    }\n\n    public function addAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new HtmlResponse($this->template->render('album::album-page-add'));\n    }\n\n    public function editAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new \\InvalidArgumentException('id parameter must be provided');\n        }\n\n        return new HtmlResponse(\n            $this->template->render('album::album-page-edit', ['id' => $id])\n        );\n    }\n}\n\n\n\nThis allows us to have the same dependencies for a set of related actions, and,\nif desired, even have common internal methods each can utilize.\n\n\nThis approach is reasonable, but requires that I create a similar \nprocess()\n\nimplementation every time I want to accomplish a similar workflow. Let's create\na generic implementation, via an \nAbstractPage\n class:\n\n\n<?php\nnamespace App\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\n\nabstract class AbstractPage implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n\n        return $this->$action($request, $delegate);\n    }\n}\n\n\n\nThe above abstract class pulls the \naction\n attribute on invocation, and\nconcatenates it with the word \nAction\n. It then uses this value to determine if\na corresponding method exists in the current class, and, if so, calls it with\nthe arguments it received; otherwise, it returns an empty 404 response.\n\n\nOur original \nAlbumPage\n implementation could then be modified to extend\n\nAbstractPage\n:\n\n\nnamespace Album\\Action;\n\nuse App\\Action\\AbstractPage;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage extends AbstractPage\n{\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}\n\n\n\n\n\nOr use a trait\n\n\nAs an alternative to an abstract class, you could define the \n__invoke()\n\nlogic in a trait, which you then compose into your middleware:\n\n\n<?php\nnamespace App\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\n\ntrait ActionBasedInvocation\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n\n        return $this->$action($request, $delegate);\n    }\n}\n\n\n\nYou would then compose it into a class as follows:\n\n\n<?php\nnamespace Album\\Action;\n\nuse App\\Action\\ActionBasedInvocation;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    use ActionBasedInvocation;\n\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Handling multiple routes in a single class"
        },
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/#handling-multiple-routes-in-a-single-class",
            "text": "Typically, in Expressive, we would define one middleware class per route. For a\nstandard CRUD-style application, however, this leads to multiple related\nclasses:   AlbumPageIndex  AlbumPageEdit  AlbumPageAdd   If you are familiar with frameworks that provide controllers capable of handling\nmultiple \"actions\", such as those found in Zend Framework's MVC layer, Symfony,\nCodeIgniter, CakePHP, and other popular frameworks, you may want to apply a\nsimilar pattern when using Expressive.  In other words, what if we want to use only one middleware class to facilitate\nall three of the above?  In the following example, we'll use an  action  routing parameter which our\nmiddleware class will use in order to determine which internal method to invoke.  Consider the following route configuration:  use Album\\Action\\AlbumPage;\n\n// Programmatic:\n$app->get('/album[/{action:add|edit}[/{id}]]', AlbumPage::class, 'album');\n\n// Config-driven:\nreturn [\n    /* ... */\n    'routes' => [\n        /* ... */\n        [\n            'name'            => 'album',\n            'path'            => '/album[/{action:add|edit}[/{id}]]',\n            'middleware'      => AlbumPage::class,\n            'allowed_methods' => ['GET'],\n        ],\n        /* ... */\n    ],\n]; \nThe above each define a route that will match any of the following:   /album  /album/add  /album/edit/3   The  action  attribute can thus be one of  add  or  edit , and we can optionally\nalso receive an  id  attribute (in the latter example, it would be  3 ).",
            "title": "Handling multiple routes in a single class"
        },
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/#routing-definitions-may-vary",
            "text": "Depending on the router you chose when starting your project, your routing\ndefinition may differ. The above example uses the default  FastRoute \nimplementation.   We might then implement  Album\\Action\\AlbumPage  as follows:  <?php\nnamespace Album\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage implements MiddlewareInterface\n{\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        switch ($request->getAttribute('action', 'index')) {\n            case 'index':\n                return $this->indexAction($request, $delegate);\n            case 'add':\n                return $this->addAction($request, $delegate);\n            case 'edit':\n                return $this->editAction($request, $delegate);\n            default:\n                // Invalid; thus, a 404!\n                return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n    }\n\n    public function indexAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new HtmlResponse($this->template->render('album::album-page'));\n    }\n\n    public function addAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new HtmlResponse($this->template->render('album::album-page-add'));\n    }\n\n    public function editAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new \\InvalidArgumentException('id parameter must be provided');\n        }\n\n        return new HtmlResponse(\n            $this->template->render('album::album-page-edit', ['id' => $id])\n        );\n    }\n}  This allows us to have the same dependencies for a set of related actions, and,\nif desired, even have common internal methods each can utilize.  This approach is reasonable, but requires that I create a similar  process() \nimplementation every time I want to accomplish a similar workflow. Let's create\na generic implementation, via an  AbstractPage  class:  <?php\nnamespace App\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\n\nabstract class AbstractPage implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n\n        return $this->$action($request, $delegate);\n    }\n}  The above abstract class pulls the  action  attribute on invocation, and\nconcatenates it with the word  Action . It then uses this value to determine if\na corresponding method exists in the current class, and, if so, calls it with\nthe arguments it received; otherwise, it returns an empty 404 response.  Our original  AlbumPage  implementation could then be modified to extend AbstractPage :  namespace Album\\Action;\n\nuse App\\Action\\AbstractPage;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage extends AbstractPage\n{\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Routing definitions may vary"
        },
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/#or-use-a-trait",
            "text": "As an alternative to an abstract class, you could define the  __invoke() \nlogic in a trait, which you then compose into your middleware:  <?php\nnamespace App\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\n\ntrait ActionBasedInvocation\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n\n        return $this->$action($request, $delegate);\n    }\n}  You would then compose it into a class as follows:  <?php\nnamespace Album\\Action;\n\nuse App\\Action\\ActionBasedInvocation;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    use ActionBasedInvocation;\n\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Or use a trait"
        },
        {
            "location": "/cookbook/flash-messengers/",
            "text": "How Can I Implement Flash Messages?\n\n\nFlash messages\n are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a\n\nPost/Redirect/Get (PRG)\n\nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.\n\n\nExpressive does not provide native session facilities out-of-the-box, which\nmeans you will need:\n\n\n\n\nSession functionality.\n\n\nFlash message functionality, for handling message expiry from the session\n  after first access.\n\n\n\n\nA number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are slim/flash and\ndamess/expressive-session-middleware.\n\n\nslim/flash\n\n\nSlim's \nFlash messages service provider\n can be \nused in Expressive. It uses PHP's native session support.\n\n\nFirst, you'll need to add it to your application:\n\n\n$ composer require slim/flash\n\n\n\nSecond, create middleware that will add the flash message provider to the request:\n\n\n<?php\nnamespace App;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Start the session whenever we use this!\n        session_start();\n\n        return $delegate->process(\n            $request->withAttribute('flash', new Messages())\n        );\n    }\n}\n\n\n\nThird, we will register the new middleware with our container as an invokable.\nEdit either the file \nconfig/autoload/dependencies.global.php\n or\n\nconfig/autoload/middleware-pipeline.global.php\n to add the following:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nFinally, let's register it with our middleware pipeline. For programmatic\npipelines, pipe the middleware somewhere, generally before the routing middleware:\n\n\n$app->pipe(App\\SlimFlashMiddleware::class);\n\n\n\nOr as part of a routed middleware pipeline:\n\n\n$app->post('/form/handler', [\n    App\\SlimFlashMiddleware::class,\n    FormHandlerMiddleware::class,\n]);\n\n\n\nIf using configuration-driven pipelines, edit\n\nconfig/autoload/middleware-pipeline.global.php\n to make the following\nadditions:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\nWhere to register the flash middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead, as demonstrated\nin the programmatic pipelines above.\n\n\n\n\nFrom here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $flash = $request->getAttribute('flash');\n    $flash->addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\nAnd middleware consuming the message might read:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $flash = $request->getAttribute('flash');\n    $messages = $flash->getMessages();\n    // ...\n}\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.\n\n\ndamess/expressive-session-middleware and Aura.Session\n\n\ndamess/expressive-session-middleware\n\nprovides middleware for initializing an\n\nAura.Session\n instance; Aura.Session\nprovides flash messaging capabilities as part of its featureset.\n\n\nInstall it via Composer:\n\n\n$ composer require damess/expressive-session-middleware\n\n\n\nIn \nconfig/autoload/dependencies.global.php\n, add an entry for Aura.Session:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIn either \nconfig/autoload/dependencies.global.php\n or\n\nconfig/autoload/middleware-pipeline.global.php\n, add a factory entry for the\n\ndamess/expressive-session-middleware\n:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nFinally, add it to your middleware pipeline. For programmatic pipelines:\n\n\nuse DaMess\\Http\\SessionMiddleware;\n\n$app->pipe(SessionMiddleware::class);\n/* ... */\n\n\n\nIf using configuration-driven pipelines, edit \nconfig/autoload/middleware-pipeline.global.php\n\nand add an entry for the new middleware:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                DaMess\\Http\\SessionMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\nWhere to register the session middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the session\nmiddleware enabled for every request. If this is the case, add the session\nmiddleware as part of a route-specific pipeline instead.\n\n\n\n\nOnce enabled, the \nSessionMiddleware\n will inject the Aura.Session instance into\nthe request as the \nsession\n attribute; you can thus retrieve it within\nmiddleware using the following:\n\n\n$session = $request->getAttribute('session');\n\n\n\nTo create and consume flash messages, use Aura.Session's\n\nflash values\n. As\nan example, the middleware that is processing a POST request might set a flash\nmessage:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $session = $request->getAttribute('session');\n    $session->getSegment(__NAMESPACE__)\n            ->setFlash('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\nAnother middleware, to which the original middleware redirects, might look like\nthis:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $session = $request->getAttribute('session');\n    $message = $session->getSegment(__NAMESPACE__)\n                       ->getFlash('message');\n    // ...\n}\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.",
            "title": "Flash Messengers"
        },
        {
            "location": "/cookbook/flash-messengers/#how-can-i-implement-flash-messages",
            "text": "Flash messages  are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) \nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.  Expressive does not provide native session facilities out-of-the-box, which\nmeans you will need:   Session functionality.  Flash message functionality, for handling message expiry from the session\n  after first access.   A number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are slim/flash and\ndamess/expressive-session-middleware.",
            "title": "How Can I Implement Flash Messages?"
        },
        {
            "location": "/cookbook/flash-messengers/#slimflash",
            "text": "Slim's  Flash messages service provider  can be \nused in Expressive. It uses PHP's native session support.  First, you'll need to add it to your application:  $ composer require slim/flash  Second, create middleware that will add the flash message provider to the request:  <?php\nnamespace App;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Start the session whenever we use this!\n        session_start();\n\n        return $delegate->process(\n            $request->withAttribute('flash', new Messages())\n        );\n    }\n}  Third, we will register the new middleware with our container as an invokable.\nEdit either the file  config/autoload/dependencies.global.php  or config/autoload/middleware-pipeline.global.php  to add the following:  return [\n    'dependencies' => [\n        'invokables' => [\n            App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Finally, let's register it with our middleware pipeline. For programmatic\npipelines, pipe the middleware somewhere, generally before the routing middleware:  $app->pipe(App\\SlimFlashMiddleware::class);  Or as part of a routed middleware pipeline:  $app->post('/form/handler', [\n    App\\SlimFlashMiddleware::class,\n    FormHandlerMiddleware::class,\n]);  If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php  to make the following\nadditions:  return [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];",
            "title": "slim/flash"
        },
        {
            "location": "/cookbook/flash-messengers/#where-to-register-the-flash-middleware",
            "text": "Sessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead, as demonstrated\nin the programmatic pipelines above.   From here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $flash = $request->getAttribute('flash');\n    $flash->addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  And middleware consuming the message might read:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $flash = $request->getAttribute('flash');\n    $messages = $flash->getMessages();\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.",
            "title": "Where to register the flash middleware"
        },
        {
            "location": "/cookbook/flash-messengers/#damessexpressive-session-middleware-and-aurasession",
            "text": "damess/expressive-session-middleware \nprovides middleware for initializing an Aura.Session  instance; Aura.Session\nprovides flash messaging capabilities as part of its featureset.  Install it via Composer:  $ composer require damess/expressive-session-middleware  In  config/autoload/dependencies.global.php , add an entry for Aura.Session:  return [\n    'dependencies' => [\n        'factories' => [\n            Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  In either  config/autoload/dependencies.global.php  or config/autoload/middleware-pipeline.global.php , add a factory entry for the damess/expressive-session-middleware :  return [\n    'dependencies' => [\n        'factories' => [\n            DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Finally, add it to your middleware pipeline. For programmatic pipelines:  use DaMess\\Http\\SessionMiddleware;\n\n$app->pipe(SessionMiddleware::class);\n/* ... */  If using configuration-driven pipelines, edit  config/autoload/middleware-pipeline.global.php \nand add an entry for the new middleware:  return [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                DaMess\\Http\\SessionMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];",
            "title": "damess/expressive-session-middleware and Aura.Session"
        },
        {
            "location": "/cookbook/flash-messengers/#where-to-register-the-session-middleware",
            "text": "Sessions can sometimes be expensive. As such, you may not want the session\nmiddleware enabled for every request. If this is the case, add the session\nmiddleware as part of a route-specific pipeline instead.   Once enabled, the  SessionMiddleware  will inject the Aura.Session instance into\nthe request as the  session  attribute; you can thus retrieve it within\nmiddleware using the following:  $session = $request->getAttribute('session');  To create and consume flash messages, use Aura.Session's flash values . As\nan example, the middleware that is processing a POST request might set a flash\nmessage:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $session = $request->getAttribute('session');\n    $session->getSegment(__NAMESPACE__)\n            ->setFlash('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  Another middleware, to which the original middleware redirects, might look like\nthis:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $session = $request->getAttribute('session');\n    $message = $session->getSegment(__NAMESPACE__)\n                       ->getFlash('message');\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.",
            "title": "Where to register the session middleware"
        },
        {
            "location": "/cookbook/passing-data-between-middleware/",
            "text": "Passing Data Between Middleware\n\n\nA frequently asked question is how to pass data between middleware.\n\n\nThe answer is present in every middleware: via request object attributes.\n\n\nMiddleware is always executed in the order in which it is piped to the\napplication. This way you can ensure the request object in middleware receiving\ndata contains an attribute containing data passed by outer middleware.\n\n\nIn the following example, \nPassingDataMiddleware\n prepares data to pass as a\nrequest attribute to nested middleware. We use the fully qualified class name\nfor the attribute name to ensure uniqueness, but you can name it anything you\nwant.\n\n\nnamespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass PassingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Do something first\n        $data = [\n            'foo' => 'bar',  \n        ];\n\n        // Step 2: Inject data into the request, call the next middleware and wait for the response\n        $response = $delegate->process($request->withAttribute(self::class, $data));\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}\n\n\n\nLater, \nReceivingDataMiddleware\n grabs the data and processes it:\n\n\nnamespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass ReceivingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Grab the data from the request and use it\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n\n        // Step 2: Call the next middleware and wait for the response\n        $response = $delegate->process($request);\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}\n\n\n\nOf course, you could also use the data in routed middleware, which is usually at\nthe innermost layer of your application. The \nExampleAction\n below takes that\ninformation and passes it to the template renderer to create an \nHtmlResponse\n:\n\n\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass ExampleAction implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Grab the data from the request\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n        $id = $request->getAttribute('id');\n\n        // Step 2: Do some more stuff\n\n        // Step 3: Return a Response\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'data' => $data,\n                'id' => $id,\n            ])\n        );\n    }\n}",
            "title": "Passing data between middleware"
        },
        {
            "location": "/cookbook/passing-data-between-middleware/#passing-data-between-middleware",
            "text": "A frequently asked question is how to pass data between middleware.  The answer is present in every middleware: via request object attributes.  Middleware is always executed in the order in which it is piped to the\napplication. This way you can ensure the request object in middleware receiving\ndata contains an attribute containing data passed by outer middleware.  In the following example,  PassingDataMiddleware  prepares data to pass as a\nrequest attribute to nested middleware. We use the fully qualified class name\nfor the attribute name to ensure uniqueness, but you can name it anything you\nwant.  namespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass PassingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Do something first\n        $data = [\n            'foo' => 'bar',  \n        ];\n\n        // Step 2: Inject data into the request, call the next middleware and wait for the response\n        $response = $delegate->process($request->withAttribute(self::class, $data));\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}  Later,  ReceivingDataMiddleware  grabs the data and processes it:  namespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass ReceivingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Grab the data from the request and use it\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n\n        // Step 2: Call the next middleware and wait for the response\n        $response = $delegate->process($request);\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}  Of course, you could also use the data in routed middleware, which is usually at\nthe innermost layer of your application. The  ExampleAction  below takes that\ninformation and passes it to the template renderer to create an  HtmlResponse :  namespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass ExampleAction implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Grab the data from the request\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n        $id = $request->getAttribute('id');\n\n        // Step 2: Do some more stuff\n\n        // Step 3: Return a Response\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'data' => $data,\n                'id' => $id,\n            ])\n        );\n    }\n}",
            "title": "Passing Data Between Middleware"
        },
        {
            "location": "/why-expressive/",
            "text": "Should You Choose zend-expressive Over zend-mvc?\n\n\nWe recommend that you choose Expressive for any new project \u2014 \nif the\nchoice is yours to make\n.\n\n\nWhy Use zend-mvc?\n\n\nzend-mvc is a proven platform, with half a decade of development behind it. It\nis stable and battle-tested in production platforms.\n\n\nBecause it is opinionated about project structure and architecture, fewer\ndecisions need be made up front; developers know where new code goes, and how it\nwill wire into the overall application.\n\n\nAdditionally, a number of training courses exist, including \nofferings by\nZend\n, allowing you\nor your team to fully learn the framework and take advantage of all its features.\n\n\nFinally, zend-mvc has a lively \nmodule ecosystem\n,\nallowing you to add features and capabilities to your application without\nneeding to develop them from scratch.\n\n\nWe Recommend Expressive\n\n\nzend-mvc\n has many preconceptions\nabout how things work, yet they're very broad and general. What\u2019s more, it\nalso has several pre-wired structures in place that may either aid you \u2014\nor get in your way.\n\n\nAs a result, you are required to know a lot of what those things are \u2014 \nif\n you\nwant to use it optimally. And to acquire that depth of knowledge, you\u2019re going\nto need to spend a lot of time digging deep into zend-mvc\u2019s internals before\nyou begin to get the most out of it.\n\n\nTo quote Zend Framework project lead, \nMatthew Weier O\u2019Phinney\n:\n\n\n\n\nThe problem is that zend-mvc is anything but beginner-friendly at this point.\nYou're required to deep dive into the event manager, service manager, and\nmodule system \u2014 right from the outset; And to do this you need more than a\npassing understanding of object-oriented programming and a range of design\npatterns.\n\n\n\n\nExpressive (specifically applications based on\n\nthe Expressive Skeleton Installer\n)\non the other hand, comes with barely any of these assumptions and requirements.\n\n\nIt provides a very minimalist structure. Essentially all you have to become\nfamiliar with are five core components. These are:\n\n\n\n\nA DI container.\n\n\nA router.\n\n\nAn error handler for development.\n\n\nA template engine (if you\u2019re not creating an API).\n\n\nPSR-7 messages and http-interop (future PSR-15) middleware.\n\n\n\n\nIn many cases, these are provided for you by the skeleton, and do not require\nany additional knowledge on your part. Given that, you can quickly get up to\nspeed with the framework and begin creating the application that you need. We\nbelieve that this approach \u2014 in contrast to the zend-mvc approach \u2014\nis more flexible and accommodating.\n\n\nWhat\u2019s more, you can mix and match the types of applications that you create.\n\n\n\n\nDo you just need an API? Great; you can do that quite quickly.\n\n\nDo you want an HTML-based front-end? That\u2019s available too.\n\n\n\n\nWhen building applications with Expressive, you can make use of the various Zend\ncomponents, or any third-party components or middleware. You can pick and\nchoose what you need, as and when you need it. You\u2019re not bound by many, if\nany, constraints and design decisions.\n\n\nIn Conclusion\n\n\nFor what it\u2019s worth, we\u2019re \nnot\n saying that zend-mvc is a poor choice!  What\nwe are saying is:\n\n\n\n\nThe learning curve, from getting started to building the first application,\n   is \nsignificantly\n lower with Expressive\n\n\nThe ways in which you can create applications, whether through multiple\n   pieces of middleware or by combining multiple Expressive apps, into one\n   larger one, is a much more efficient and fluid way to work\n\n\n\n\nUltimately, the choice is always up to you, your team, and your project\u2019s needs.\nWe just want to ensure that you\u2019ve got all the information you need, to make an\ninformed decision.",
            "title": "Why choose Expressive?"
        },
        {
            "location": "/why-expressive/#should-you-choose-zend-expressive-over-zend-mvc",
            "text": "We recommend that you choose Expressive for any new project \u2014  if the\nchoice is yours to make .",
            "title": "Should You Choose zend-expressive Over zend-mvc?"
        },
        {
            "location": "/why-expressive/#why-use-zend-mvc",
            "text": "zend-mvc is a proven platform, with half a decade of development behind it. It\nis stable and battle-tested in production platforms.  Because it is opinionated about project structure and architecture, fewer\ndecisions need be made up front; developers know where new code goes, and how it\nwill wire into the overall application.  Additionally, a number of training courses exist, including  offerings by\nZend , allowing you\nor your team to fully learn the framework and take advantage of all its features.  Finally, zend-mvc has a lively  module ecosystem ,\nallowing you to add features and capabilities to your application without\nneeding to develop them from scratch.",
            "title": "Why Use zend-mvc?"
        },
        {
            "location": "/why-expressive/#we-recommend-expressive",
            "text": "zend-mvc  has many preconceptions\nabout how things work, yet they're very broad and general. What\u2019s more, it\nalso has several pre-wired structures in place that may either aid you \u2014\nor get in your way.  As a result, you are required to know a lot of what those things are \u2014  if  you\nwant to use it optimally. And to acquire that depth of knowledge, you\u2019re going\nto need to spend a lot of time digging deep into zend-mvc\u2019s internals before\nyou begin to get the most out of it.  To quote Zend Framework project lead,  Matthew Weier O\u2019Phinney :   The problem is that zend-mvc is anything but beginner-friendly at this point.\nYou're required to deep dive into the event manager, service manager, and\nmodule system \u2014 right from the outset; And to do this you need more than a\npassing understanding of object-oriented programming and a range of design\npatterns.   Expressive (specifically applications based on the Expressive Skeleton Installer )\non the other hand, comes with barely any of these assumptions and requirements.  It provides a very minimalist structure. Essentially all you have to become\nfamiliar with are five core components. These are:   A DI container.  A router.  An error handler for development.  A template engine (if you\u2019re not creating an API).  PSR-7 messages and http-interop (future PSR-15) middleware.   In many cases, these are provided for you by the skeleton, and do not require\nany additional knowledge on your part. Given that, you can quickly get up to\nspeed with the framework and begin creating the application that you need. We\nbelieve that this approach \u2014 in contrast to the zend-mvc approach \u2014\nis more flexible and accommodating.  What\u2019s more, you can mix and match the types of applications that you create.   Do you just need an API? Great; you can do that quite quickly.  Do you want an HTML-based front-end? That\u2019s available too.   When building applications with Expressive, you can make use of the various Zend\ncomponents, or any third-party components or middleware. You can pick and\nchoose what you need, as and when you need it. You\u2019re not bound by many, if\nany, constraints and design decisions.",
            "title": "We Recommend Expressive"
        },
        {
            "location": "/why-expressive/#in-conclusion",
            "text": "For what it\u2019s worth, we\u2019re  not  saying that zend-mvc is a poor choice!  What\nwe are saying is:   The learning curve, from getting started to building the first application,\n   is  significantly  lower with Expressive  The ways in which you can create applications, whether through multiple\n   pieces of middleware or by combining multiple Expressive apps, into one\n   larger one, is a much more efficient and fluid way to work   Ultimately, the choice is always up to you, your team, and your project\u2019s needs.\nWe just want to ensure that you\u2019ve got all the information you need, to make an\ninformed decision.",
            "title": "In Conclusion"
        },
        {
            "location": "/reference/cli-tooling/",
            "text": "Command Line Tooling\n\n\nExpressive offers a number of tools for assisting in project development. This\npage catalogues each.\n\n\nDevelopment Mode\n\n\n\n\nSince 2.0.\n\n\n\n\nThe package \nzfcampus/zf-development-mode\n\nprovides a simple way to toggle in and out of \ndevelopment mode\n. Doing so\nallows you to ship known development-specific settings within your repository,\nwhile ensuring they are not enabled in production. The tooling essentially\nenables optional, development-specific configuration in your application by:\n\n\n\n\nCopying the file \nconfig/development.config.php.dist\n to\n  \nconfig/development.config.php\n; this can be used to enable\n  development-specific modules or settings (such as the \ndebug\n flag).\n\n\nCopying the file \nconfig/autoload/development.local.php.dist\n to\n  \nconfig/autoload/development.local.php\n; this can be used to provide local\n  overrides of a number of configuration settings.\n\n\n\n\nThe package provides the tooling via \nvendor/bin/zf-development-mode\n. If you\nare using the Expressive skeleton, it provides aliases via Composer:\n\n\n$ composer development-enable\n$ composer development-disable\n$ composer development-status\n\n\n\nAdd settings to your \ndevelopment.*.php.dist\n files, and commit those files to\nyour repository; always toggle out of and into development mode after making\nchanges, to ensure they pick up in your development environment.\n\n\nExpressive command-line tool\n\n\n\n\nSince zend-expressive-tooling 0.4.0 and zend-expressive-skeleton 2.0.2\n\n\n\n\nThe package \nzendframework/zend-expressive-tooling\n\nprovides the script \nvendor/bin/expressive\n, which contains a number of commands\nrelated to migration, modules, and middleware.\n\n\nYou can install it if it is not already present in your application:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nIf you installed the Expressive skeleton prior to version 2.0.2, you will want\nto update the tooling to get the latest release, which contains the \nexpressive\n\nbinary, as follows:\n\n\n$ composer require --dev \"zendframework/zend-expressive-tooling:^0.4.1\"\n\n\n\nOnce installed, invoking the binary without arguments will give a listing of\navailable tools:\n\n\n$ ./vendor/bin/expressive\n\n\n\nCommands supported include:\n\n\n\n\n\n\nmiddleware:create <middleware>\n: Create a class file for the named\n  middleware class. The class \nmust\n use a namespace already declared in your\n  application, and will be created relative to the path associated with that\n  namespace.\n\n\n\n\n\n\nmigrate:error-middleware-scanner [--dir|-d]\n: Scan the associated\n  directory (defaults to \nsrc\n) for declarations of legacy Stratigility v1 error\n  middleware, or invocations of \n$next()\n that provide an error argument. See\n  the \nsection on detecting legacy error middleware\n\n  for more details.\n\n\n\n\n\n\nmigrate:original-messages [--src|-s]\n: Scan the associated source directory\n  (defaults to \nsrc\n) for \ngetOriginal*()\n method calls and replace them with\n  \ngetAttribute()\n calls. See the \nsection on detecting legacy\n  calls\n for more details.\n\n\n\n\n\n\nmigrate:pipeline [--config-file|-c]\n: Convert configuration-driven\n  pipelines and routing to programmatic declarations. See the \nsection on\n  migrating to programmatic pipelines\n for\n  more details.\n\n\n\n\n\n\nmodule:create [--composer|-c] [--modules-path|-p] <module>\n: Create the\n  named module, add and generate autoloading rules for it, and register the\n  module's \nConfigProvider\n with your application.\n\n\n\n\n\n\nmodule:register [--composer|-c] [--modules-path|-p] <module>\n: Add and\n  generate autoloading rules for the named module,  and register the module's\n  \nConfigProvider\n with your application.\n\n\n\n\n\n\nmodule:deregister [--composer|-c] [--modules-path|-p] <module>\n: Remove\n  autoloading rules for the named module and regenerate autoloading rules;\n  remove the module's \nConfigProvider\n from the application configuration.\n\n\n\n\n\n\nYou may obtain full help for each command by invoking:\n\n\n$ ./vendor/bin/expressive help <command>\n\n\n\nModules\n\n\n\n\nSince 2.0.\n\n\nDeprecated since zend-expressive-tooling 0.4.0; see the \nExpressive CLI tool\n  section above\n.\n\n\n\n\nThe package \nzendframework/zend-expressive-tooling\n\nprovides the binary \nvendor/bin/expressive-module\n, which allows you to create,\nregister, and deregister modules, assuming you are using a \nmodular application\nlayout\n.\n\n\n\n\nAdding tooling to existing applications\n\n\nIf you have upgraded from Expressive 1.X, you can install\nzendframework/zend-expressive-tooling via Composer:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\n\n\nFor instance, if you wish to create a new module for managing users, you might\nexecute the following:\n\n\n$ ./vendor/bin/expressive-module create User\n\n\n\nWhich would create the following tree:\n\n\nsrc/\n  User/\n    src/\n      ConfigProvider.php\n    templates/\n\n\n\nIt would also create an autoloading rule within your \ncomposer.json\n for the\n\nUser\n namespace, pointing it at the \nsrc/User/src/\n tree (and updating the\nautoloader in the process), and register the new module's \nConfigProvider\n\nwithin your \nconfig/config.php\n.\n\n\nThe \nregister\n command will take an existing module and:\n\n\n\n\nAdd an autoloading rule for it to your \ncomposer.json\n, if necessary.\n\n\nAdd an entry for the module's \nConfigProvider\n class to your\n  \nconfig/config.php\n, if possible.\n\n\n\n\n$ ./vendor/bin/expressive-module register Account\n\n\n\nThe \nderegister\n command does the opposite of \nregister\n.\n\n\n$ ./vendor/bin/expressive-module deregister Account\n\n\n\nMigrate to programmatic pipelines\n\n\n\n\nSince 2.0.\n\n\nDeprecated since zend-expressive-tooling 0.4.0; see the \nExpressive CLI tool\n  section above\n.\n\n\n\n\nStarting in 2.0, we recommend using \nprogrammatic pipelines\n, versus\nconfiguration-defined pipelines. For those upgrading their applications from 1.X\nversions, we provide a tool that will read their application configuration and\ngenerate:\n\n\n\n\nconfig/pipeline.php\n, with the middleware pipeline\n\n\nconfig/routes.php\n, with routing directives\n\n\nconfig/autoload/zend-expressive.global.php\n, with settings to ensure\n  programmatic pipelines are used, and new middleware provided for Expressive\n  2.0 is registered.\n\n\ndirectives within \npublic/index.php\n for using the generated pipeline and\n  routes directives.\n\n\n\n\nTo use this feature, you will need to first install\nzendframework/zend-expressive-tooling:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nInvoke it as follows:\n\n\n$ ./vendor/bin/expressive-pipeline-from-config generate\n\n\n\nThe tool will notify you of any errors, including whether or not it found (and\nskipped) Stratigility v1-style \"error middleware\".\n\n\nDetect usage of legacy getOriginal*() calls\n\n\n\n\nSince 2.0.\n\n\nDeprecated since zend-expressive-tooling 0.4.0; see the \nExpressive CLI tool\n  section above\n.\n\n\n\n\nWhen upgrading to version 2.0, you will also receive an upgrade to\nzendframework/zend-stratigility 2.0. That version eliminates internal decorator\nclasses for the request and response instances, which were used to provide\naccess to the outermost request/response; internal layers could use these to\ndetermine the full URI that resulted in their invocation, which is useful when\nyou pipe using a path argument (as the path provided during piping is stripped\nfrom the URI when invoking the matched middleware).\n\n\nThis affects the following methods:\n\n\n\n\nRequest::getOriginalRequest()\n\n\nRequest::getOriginalUri()\n\n\nResponse::getOriginalResponse()\n\n\n\n\nTo provide equivalent functionality, we provide a couple of tools.\n\n\nFirst, Stratigility provides middleware, \nZend\\Stratigility\\Middleware\\OriginalMessages\n,\nwhich will inject the current request, its URI, and, if invoked as double-pass\nmiddleware, current response, as \nrequest attributes\n, named, respectively,\n\noriginalRequest\n, \noriginalUri\n, and \noriginalResponse\n. (Since Expressive 2.0\ndecorates double-pass middleware using a wrapper that composes a response, the\n\"original response\" will be the response prototype composed in the \nApplication\n\ninstance.) This should be registered as the outermost middleware layer.\nMiddleware that needs access to these instances can then use the following\nsyntax to retrieve them:\n\n\n$originalRequest = $request->getAttribute('originalRequest', $request);\n$originalUri = $request->getAttribute('originalUri', $request->getUri();\n$originalResponse = $request->getAttribute('originalResponse') ?: new Response();\n\n\n\n\n\nOriginal response is not trustworthy\n\n\nAs noted above, the \"original response\" will likely be injected with the\nresponse prototype from the \nApplication\n instance. We recommend not using it,\nand instead either composing a pristine response instance in your middleware,\nor creating a new instance on-the-fly.\n\n\n\n\nTo aid you in migrating your existing code to use the new \ngetAttribute()\n\nsyntax, zendframework/zend-expressive-tooling provides a binary,\n\nvendor/bin/expressive-migrate-original-messages\n. First, install that package:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nThen invoke it as follows:\n\n\n$ ./vendor/bin/expressive-migrate-original-messages scan\n\n\n\nThis script will update any \ngetOriginalRequest()\n and \ngetOriginalUri()\n calls,\nand notify you of any \ngetOriginalResponse()\n calls, providing you with details\non how to correct those manually.\n\n\nDetect usage of legacy error middleware\n\n\n\n\nSince 2.0.\n\n\nDeprecated since zend-expressive-tooling 0.4.0; see the \nExpressive CLI tool\n  section above\n.\n\n\n\n\nWhen upgrading to version 2.0, you will also receive an upgrade to\nzendframework/zend-stratigility 2.0. That version eliminates what was known as\n\"error middleware\", middleware that either implemented\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n, or duck-typed it by implementing\nthe signature \nfunction ($error, $request, $response, callable $next)\n.\n\n\nSuch \"error middleware\" allowed other middleware to invoke the \n$next\n argument\nwith an additional, third argument representing an error condition; when that\noccurred, Stratigility/Expressive would start iterating through error middleware\nuntil one was able to return a response. Each would receive the error as the\nfirst argument, and determine how to act upon it.\n\n\nWith version 2.0 of each project, such middleware is now no longer accepted, and\nusers should instead be using \nthe new error handling\nfeatures\n. However, you may find that:\n\n\n\n\nYou have defined error middleware in your application.\n\n\nYou have standard middleware in your application that invokes \n$next\n with the\n  third, error argument.\n\n\n\n\nTo help you identify such instances, zendframework/zend-expressive-tooling\nprovides the script \nvendor/bin/expressive-scan-for-error-middleware\n. First,\ninstall that package:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nThen invoke it as follows:\n\n\n$ ./vendor/bin/expressive-scan-for-error-middleware scan\n\n\n\nThe script will notify you of any places where it finds either use case, and\nprovide feedback on how to update your application.",
            "title": "CLI Tooling"
        },
        {
            "location": "/reference/cli-tooling/#command-line-tooling",
            "text": "Expressive offers a number of tools for assisting in project development. This\npage catalogues each.",
            "title": "Command Line Tooling"
        },
        {
            "location": "/reference/cli-tooling/#development-mode",
            "text": "Since 2.0.   The package  zfcampus/zf-development-mode \nprovides a simple way to toggle in and out of  development mode . Doing so\nallows you to ship known development-specific settings within your repository,\nwhile ensuring they are not enabled in production. The tooling essentially\nenables optional, development-specific configuration in your application by:   Copying the file  config/development.config.php.dist  to\n   config/development.config.php ; this can be used to enable\n  development-specific modules or settings (such as the  debug  flag).  Copying the file  config/autoload/development.local.php.dist  to\n   config/autoload/development.local.php ; this can be used to provide local\n  overrides of a number of configuration settings.   The package provides the tooling via  vendor/bin/zf-development-mode . If you\nare using the Expressive skeleton, it provides aliases via Composer:  $ composer development-enable\n$ composer development-disable\n$ composer development-status  Add settings to your  development.*.php.dist  files, and commit those files to\nyour repository; always toggle out of and into development mode after making\nchanges, to ensure they pick up in your development environment.",
            "title": "Development Mode"
        },
        {
            "location": "/reference/cli-tooling/#expressive-command-line-tool",
            "text": "Since zend-expressive-tooling 0.4.0 and zend-expressive-skeleton 2.0.2   The package  zendframework/zend-expressive-tooling \nprovides the script  vendor/bin/expressive , which contains a number of commands\nrelated to migration, modules, and middleware.  You can install it if it is not already present in your application:  $ composer require --dev zendframework/zend-expressive-tooling  If you installed the Expressive skeleton prior to version 2.0.2, you will want\nto update the tooling to get the latest release, which contains the  expressive \nbinary, as follows:  $ composer require --dev \"zendframework/zend-expressive-tooling:^0.4.1\"  Once installed, invoking the binary without arguments will give a listing of\navailable tools:  $ ./vendor/bin/expressive  Commands supported include:    middleware:create <middleware> : Create a class file for the named\n  middleware class. The class  must  use a namespace already declared in your\n  application, and will be created relative to the path associated with that\n  namespace.    migrate:error-middleware-scanner [--dir|-d] : Scan the associated\n  directory (defaults to  src ) for declarations of legacy Stratigility v1 error\n  middleware, or invocations of  $next()  that provide an error argument. See\n  the  section on detecting legacy error middleware \n  for more details.    migrate:original-messages [--src|-s] : Scan the associated source directory\n  (defaults to  src ) for  getOriginal*()  method calls and replace them with\n   getAttribute()  calls. See the  section on detecting legacy\n  calls  for more details.    migrate:pipeline [--config-file|-c] : Convert configuration-driven\n  pipelines and routing to programmatic declarations. See the  section on\n  migrating to programmatic pipelines  for\n  more details.    module:create [--composer|-c] [--modules-path|-p] <module> : Create the\n  named module, add and generate autoloading rules for it, and register the\n  module's  ConfigProvider  with your application.    module:register [--composer|-c] [--modules-path|-p] <module> : Add and\n  generate autoloading rules for the named module,  and register the module's\n   ConfigProvider  with your application.    module:deregister [--composer|-c] [--modules-path|-p] <module> : Remove\n  autoloading rules for the named module and regenerate autoloading rules;\n  remove the module's  ConfigProvider  from the application configuration.    You may obtain full help for each command by invoking:  $ ./vendor/bin/expressive help <command>",
            "title": "Expressive command-line tool"
        },
        {
            "location": "/reference/cli-tooling/#modules",
            "text": "Since 2.0.  Deprecated since zend-expressive-tooling 0.4.0; see the  Expressive CLI tool\n  section above .   The package  zendframework/zend-expressive-tooling \nprovides the binary  vendor/bin/expressive-module , which allows you to create,\nregister, and deregister modules, assuming you are using a  modular application\nlayout .",
            "title": "Modules"
        },
        {
            "location": "/reference/cli-tooling/#adding-tooling-to-existing-applications",
            "text": "If you have upgraded from Expressive 1.X, you can install\nzendframework/zend-expressive-tooling via Composer:  $ composer require --dev zendframework/zend-expressive-tooling   For instance, if you wish to create a new module for managing users, you might\nexecute the following:  $ ./vendor/bin/expressive-module create User  Which would create the following tree:  src/\n  User/\n    src/\n      ConfigProvider.php\n    templates/  It would also create an autoloading rule within your  composer.json  for the User  namespace, pointing it at the  src/User/src/  tree (and updating the\nautoloader in the process), and register the new module's  ConfigProvider \nwithin your  config/config.php .  The  register  command will take an existing module and:   Add an autoloading rule for it to your  composer.json , if necessary.  Add an entry for the module's  ConfigProvider  class to your\n   config/config.php , if possible.   $ ./vendor/bin/expressive-module register Account  The  deregister  command does the opposite of  register .  $ ./vendor/bin/expressive-module deregister Account",
            "title": "Adding tooling to existing applications"
        },
        {
            "location": "/reference/cli-tooling/#migrate-to-programmatic-pipelines",
            "text": "Since 2.0.  Deprecated since zend-expressive-tooling 0.4.0; see the  Expressive CLI tool\n  section above .   Starting in 2.0, we recommend using  programmatic pipelines , versus\nconfiguration-defined pipelines. For those upgrading their applications from 1.X\nversions, we provide a tool that will read their application configuration and\ngenerate:   config/pipeline.php , with the middleware pipeline  config/routes.php , with routing directives  config/autoload/zend-expressive.global.php , with settings to ensure\n  programmatic pipelines are used, and new middleware provided for Expressive\n  2.0 is registered.  directives within  public/index.php  for using the generated pipeline and\n  routes directives.   To use this feature, you will need to first install\nzendframework/zend-expressive-tooling:  $ composer require --dev zendframework/zend-expressive-tooling  Invoke it as follows:  $ ./vendor/bin/expressive-pipeline-from-config generate  The tool will notify you of any errors, including whether or not it found (and\nskipped) Stratigility v1-style \"error middleware\".",
            "title": "Migrate to programmatic pipelines"
        },
        {
            "location": "/reference/cli-tooling/#detect-usage-of-legacy-getoriginal-calls",
            "text": "Since 2.0.  Deprecated since zend-expressive-tooling 0.4.0; see the  Expressive CLI tool\n  section above .   When upgrading to version 2.0, you will also receive an upgrade to\nzendframework/zend-stratigility 2.0. That version eliminates internal decorator\nclasses for the request and response instances, which were used to provide\naccess to the outermost request/response; internal layers could use these to\ndetermine the full URI that resulted in their invocation, which is useful when\nyou pipe using a path argument (as the path provided during piping is stripped\nfrom the URI when invoking the matched middleware).  This affects the following methods:   Request::getOriginalRequest()  Request::getOriginalUri()  Response::getOriginalResponse()   To provide equivalent functionality, we provide a couple of tools.  First, Stratigility provides middleware,  Zend\\Stratigility\\Middleware\\OriginalMessages ,\nwhich will inject the current request, its URI, and, if invoked as double-pass\nmiddleware, current response, as  request attributes , named, respectively, originalRequest ,  originalUri , and  originalResponse . (Since Expressive 2.0\ndecorates double-pass middleware using a wrapper that composes a response, the\n\"original response\" will be the response prototype composed in the  Application \ninstance.) This should be registered as the outermost middleware layer.\nMiddleware that needs access to these instances can then use the following\nsyntax to retrieve them:  $originalRequest = $request->getAttribute('originalRequest', $request);\n$originalUri = $request->getAttribute('originalUri', $request->getUri();\n$originalResponse = $request->getAttribute('originalResponse') ?: new Response();",
            "title": "Detect usage of legacy getOriginal*() calls"
        },
        {
            "location": "/reference/cli-tooling/#original-response-is-not-trustworthy",
            "text": "As noted above, the \"original response\" will likely be injected with the\nresponse prototype from the  Application  instance. We recommend not using it,\nand instead either composing a pristine response instance in your middleware,\nor creating a new instance on-the-fly.   To aid you in migrating your existing code to use the new  getAttribute() \nsyntax, zendframework/zend-expressive-tooling provides a binary, vendor/bin/expressive-migrate-original-messages . First, install that package:  $ composer require --dev zendframework/zend-expressive-tooling  Then invoke it as follows:  $ ./vendor/bin/expressive-migrate-original-messages scan  This script will update any  getOriginalRequest()  and  getOriginalUri()  calls,\nand notify you of any  getOriginalResponse()  calls, providing you with details\non how to correct those manually.",
            "title": "Original response is not trustworthy"
        },
        {
            "location": "/reference/cli-tooling/#detect-usage-of-legacy-error-middleware",
            "text": "Since 2.0.  Deprecated since zend-expressive-tooling 0.4.0; see the  Expressive CLI tool\n  section above .   When upgrading to version 2.0, you will also receive an upgrade to\nzendframework/zend-stratigility 2.0. That version eliminates what was known as\n\"error middleware\", middleware that either implemented Zend\\Stratigility\\ErrorMiddlewareInterface , or duck-typed it by implementing\nthe signature  function ($error, $request, $response, callable $next) .  Such \"error middleware\" allowed other middleware to invoke the  $next  argument\nwith an additional, third argument representing an error condition; when that\noccurred, Stratigility/Expressive would start iterating through error middleware\nuntil one was able to return a response. Each would receive the error as the\nfirst argument, and determine how to act upon it.  With version 2.0 of each project, such middleware is now no longer accepted, and\nusers should instead be using  the new error handling\nfeatures . However, you may find that:   You have defined error middleware in your application.  You have standard middleware in your application that invokes  $next  with the\n  third, error argument.   To help you identify such instances, zendframework/zend-expressive-tooling\nprovides the script  vendor/bin/expressive-scan-for-error-middleware . First,\ninstall that package:  $ composer require --dev zendframework/zend-expressive-tooling  Then invoke it as follows:  $ ./vendor/bin/expressive-scan-for-error-middleware scan  The script will notify you of any places where it finds either use case, and\nprovide feedback on how to update your application.",
            "title": "Detect usage of legacy error middleware"
        },
        {
            "location": "/reference/usage-examples/",
            "text": "Usage Examples\n\n\nBelow are several usage examples, covering a variety of ways of creating and\nmanaging an application.\n\n\nIn all examples, the assumption is the following directory structure:\n\n\n.\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 public\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 vendor\n\n\n\nWe assume also that:\n\n\n\n\nYou have installed zend-expressive per the \ninstallation instructions\n.\n\n\npublic/\n will be the document root of your application.\n\n\nYour own classes are under \nsrc/\n with the top-level namespace \nApp\n,\n  and you have configured \nautoloading\n\n  in your \ncomposer.json\n for those classes (this should be done for you during\n  installation).\n\n\n\n\n\n\nUsing the built-in web server\n\n\nYou can use the built-in web server to run the examples. Run:\n\n\n$ php -S 0.0.0.0:8080 -t public\n\n\n\nfrom the application root to start up a web server running on port 8080, and\nthen browse to http://localhost:8080/. If you used the Expressive installer,\nthe following is equivalent:\n\n\n$ composer run --timeout=0 serve\n\n\n\nSetting up autoloading for the Application namespace\n\n\nIn your \ncomposer.json\n file, place the following:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"src/\"\n    }\n},\n\n\n\nOnce done, run:\n\n\n$ composer dump-autoload\n\n\n\n\n\nRouting\n\n\nAs noted in the \nApplication documentation\n,\nrouting is abstracted and can be accomplished by calling any of the following\nmethods:\n\n\n\n\nroute($path, $middleware, array $methods = null, $name = null)\n to route to a\n  path and match any HTTP method, multiple HTTP methods, or custom HTTP methods.\n\n\nget($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the GET HTTP method.\n\n\npost($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the POST HTTP method.\n\n\nput($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the PUT HTTP method.\n\n\npatch($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the PATCH HTTP method.\n\n\ndelete($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the DELETE HTTP method.\n\n\n\n\nAll methods return a \nZend\\Expressive\\Router\\Route\n method, which allows you to\nspecify additional options to associate with the route (e.g., for specifying\ncriteria, default values to match, etc.).\n\n\nAs examples:\n\n\n// GET\n// This demonstrates passing a middleware instance (assuming $helloWorld is\n// valid middleware)\n$app->get('/', $helloWorld);\n\n// POST\n// This example specifies the middleware as a service name instead of as\n// actual executable middleware.\n$app->post('/trackback', 'TrackBack');\n\n// PUT\n// This example shows operating on the returned route. In this case, it's adding\n// regex tokens to restrict what values for {id} will match. (The tokens feature\n// is specific to Aura.Router.)\n$app->put('/post/{id}', 'ReplacePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// PATCH\n// This example builds on the one above. Expressive allows you to specify\n// the same path for a route matching on a different HTTP method, and\n// corresponding to different middleware.\n$app->patch('/post/{id}', 'UpdatePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// DELETE\n$app->delete('/post/{id}', 'DeletePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// Matching ALL HTTP methods\n// If the underlying router supports matching any HTTP method, the following\n// will do so. Note: FastRoute *requires* you to specify the HTTP methods\n// allowed explicitly, and does not support wildcard routes. As such, the\n// following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH,\n// PUT, TRACE, and DELETE.\n// Just like the previous examples, it returns a Route instance that you can\n// further manipulate.\n$app->route('/post/{id}', 'HandlePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// Matching multiple HTTP methods\n// You can pass an array of HTTP methods as a third argument to route(); in such\n// cases, routing will match if any of the specified HTTP methods are provided.\n$app->route('/post', 'HandlePostCollection', ['GET', 'POST']);\n\n// Matching NO HTTP methods\n// Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be\n// honored. (In FastRoute, GET is also honored.)\n$app->route('/post', 'WillThisHandlePost', []);\n\n\n\nFinally, if desired, you can create a \nZend\\Expressive\\Router\\Route\n instance\nmanually and pass it to \nroute()\n as the sole argument:\n\n\n$route = new Route('/post', 'HandlePost', ['GET', 'POST']);\n$route->setOptions($options);\n\n$app->route($route);\n\n\n\nHello World using a Container\n\n\nExpressive works with \nPSR-11 Container\n,\nthough it's an optional feature. By default, if you use the \nAppFactory\n, it\nwill use \nzend-servicemanager\n\nso long as that package is installed.\n\n\nIn the following example, we'll populate the container with our middleware, and\nthe application will pull it from there when matched.\n\n\nEdit your \npublic/index.php\n to read as follows:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$container = new ServiceManager();\n\n$container->setFactory('HelloWorld', function ($container) {\n    return function ($request, DelegateInterface $delegate) {\n        return new TextResponse('Hello, world!');\n    };\n});\n\n$container->setFactory('Ping', function ($container) {\n    return function ($request, DelegateInterface $delegate) {\n        return new JsonResponse(['ack' => time()]);\n    };\n});\n\n$app = AppFactory::create($container);\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n$app->run();\n\n\n\nIn the example above, we pass our container to \nAppFactory\n. We could have also\ndone this instead:\n\n\n$app = AppFactory::create();\n$container = $app->getContainer();\n\n\n\nand then added our service definitions. We recommend passing the container to\nthe factory instead; if we ever change which container we use by default, your\ncode might not work!\n\n\nThe following two lines are the ones of interest:\n\n\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n\n\nThese map the two paths to \nservice names\n instead of callables. When routing\nmatches a path, it does the following:\n\n\n\n\nIf the middleware provided when defining the route is callable, it uses it\n  directly.\n\n\nIf the middleware is a valid service name in the container, it pulls it from\n  the container. \nThis is what happens in this example.\n\n\nFinally, if no container is available, or the service name is not found in the\n  container, it checks to see if it's a valid class name; if so, it instantiates\n  and returns the class instance.\n\n\n\n\nIf you fire up your web server, you'll find that the \n/\n and \n/ping\n paths\ncontinue to work.\n\n\nOne other approach you could take would be to define the application itself in\nthe container, and then pull it from there:\n\n\n$container->setFactory('Zend\\Expressive\\Application', function ($container) {\n    $app = AppFactory::create($container);\n    $app->get('/', 'HelloWorld');\n    $app->get('/ping', 'Ping');\n    return $app;\n});\n\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();\n\n\n\nThis is a nice way to encapsulate the application creation. You could then\npotentially move all service configuration to another file! (We already\n\ndocument an ApplicationFactory for exactly this scenario.\n)\n\n\nHello World using a Configuration-Driven Container\n\n\nIn the above example, we configured our middleware as services, and then passed\nour service container to the application. At the end, we hinted that you could\npotentially define the application itself as a service.\n\n\nExpressive already provides a service factory for the application instance\nto provide fine-grained control over your application. In this example, we'll\nleverage it, defining our routes via configuration.\n\n\nFirst, we're going to leverage zend-config to merge configuration files. This is\nimportant, as it allows us to define local, environment-specific configuration\nin files that we then can exclude from our repository. This practice ensures\nthat things like credentials are not accidentally published in a public\nrepository, and also provides a mechanism for slip-streaming in\nconfiguration based on our environment (you might use different settings in\ndevelopment than in production, after all!).\n\n\nFirst, install zend-config and zend-stdlib:\n\n\n$ composer require zendframework/zend-config zendframework/zend-stdlib\n\n\n\nNow we can start creating our configuration files and container factories.\n\n\nIn \nconfig/config.php\n, place the following:\n\n\n<?php\n\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Stdlib\\Glob;\n\n$config = [];\n// Load configuration from autoload path\nforeach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) {\n    $config = ArrayUtils::merge($config, include $file);\n}\n\n// Return an ArrayObject so we can inject the config as a service in Aura.Di\n// and still use array checks like ``is_array``.\nreturn new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS);\n\n\n\nIn \nconfig/container.php\n, place the following:\n\n\n<?php\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// Load configuration\n$config = require __DIR__.'/config.php';\n\n// Build container\n$container = new ServiceManager();\n(new Config($config['dependencies']))->configureServiceManager($container);\n\n// Inject config\n$container->setService('config', $config);\n\nreturn $container;\n\n\n\nIn \nconfig/autoload/dependencies.global.php\n, place the following:\n\n\n<?php\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            \\Application\\HelloWorldAction::class => InvokableFactory::class,\n            \\Application\\PingAction::class => InvokableFactory::class,\n        ],\n        'factories' => [\n            \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class,\n        ],\n    ]\n];\n\n\n\nIn \nconfig/autoload/routes.global.php\n, place the following:\n\n\n<?php\n\nreturn [\n    'routes' => [\n        [\n            'path' => '/',\n            'middleware' => \\Application\\HelloWorldAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n        [\n            'path' => '/ping',\n            'middleware' => \\Application\\PingAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n    ],\n];\n\n\n\nIn \nsrc/Application/HelloWorld.php\n, place the following:\n\n\n<?php\nnamespace Application;\n\nclass HelloWorld\n{\n    public function __invoke($req, $res, $next)\n    {\n        $res->getBody()->write('Hello, world!');\n        return $res;\n    }\n}\n\n\n\nIn \nsrc/Application/Ping.php\n, place the following:\n\n\n<?php\nnamespace Application;\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass Ping\n{\n    public function __invoke($req, $res, $next)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\nAfter that\u2019s done run:\n\n\ncomposer dump-autoload\n\n\n\nFinally, in \npublic/index.php\n, place the following:\n\n\n<?php\n// Change to the project root, to simplify resolving paths\nchdir(dirname(__DIR__));\n\n// Setup autoloading\nrequire 'vendor/autoload.php';\n\n$container = include 'config/container.php';\n$app       = $container->get(Zend\\Expressive\\Application::class);\n$app->run();\n\n\n\nNotice that our index file now doesn't have any code related to setting up the\napplication any longer! All it does is setup autoloading, retrieve our service\ncontainer, pull the application from it, and run it. Our choices for container,\nrouter, etc. are all abstracted, and if we change our mind later, this code will\ncontinue to work.\n\n\nFiring up the web server, you'll see the same responses as the previous\nexamples.\n\n\nHybrid Container and Programmatic Creation\n\n\nThe above example may look a little daunting at first. By making everything\nconfiguration-driven, you sometimes lose a sense for how the code all fits\ntogether.\n\n\nFortunately, you can mix the two. Building on the example above, we'll add a new\nroute and middleware. Between pulling the application from the container and\ncalling \n$app->run()\n, add the following in your \npublic/index.php\n:\n\n\n$app->post('/post', function ($request, \\Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) {\n    return new \\Zend\\Diactoros\\Response\\TextResponse('IN POST!');\n});\n\n\n\nNote that we're using \npost()\n here; that means you'll have to use cURL, HTTPie,\nPostman, or some other tool to test making a POST request to the path:\n\n\n$ curl -X POST http://localhost:8080/post\n\n\n\nYou should see \nIN POST!\n for the response!\n\n\nUsing this approach, you can build re-usable applications that are\ncontainer-driven, and add one-off routes and middleware as needed.\n\n\nUsing the container to register middleware\n\n\nIf you use a container to fetch your application instance, you have an\nadditional option for specifying middleware for the pipeline: configuration:\n\n\n<?php\nreturn [\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware Service Name or Callable',\n            'allowed_methods' => ['GET', 'POST', 'PATCH'],\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n    'middleware_pipeline' => [\n        // See specification below\n    ],\n];\n\n\n\nThe key to note is \nmiddleware_pipeline\n, which is an array of middlewares to\nregister in the pipeline; each will each be \npipe()\n'd to the Application in the\norder specified.\n\n\nEach middleware specified must be in the following form:\n\n\n[\n    // required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // optional:\n    'path'  => '/path/to/match',\n    'priority' => 1, // Integer\n]\n\n\n\nPriority should be an integer, and follows the semantics of\n\nSplPriorityQueue\n: higher numbers indicate\nhigher priority (top of the queue; executed earliest), while lower numbers\nindicated lower priority (bottom of the queue, executed last); \nnegative values\nare low priority\n. Items of the same priority are executed in the order in which\nthey are attached.\n\n\nThe default priority is 1, and this priority is used by the routing and dispatch\nmiddleware. To indicate that middleware should execute \nbefore\n these, use a\npriority higher than 1.\n\n\nThe above specification can be used for all middleware, with one exception:\nregistration of the \nrouting\n and/or \ndispatch\n middleware that Expressive\nprovides. In these cases, use the following constants, which will be caught by\nthe factory and expanded:\n\n\n\n\nZend\\Expressive\\Application::ROUTING_MIDDLEWARE\n for the\n  routing middleware; this should always come before the dispatch middleware.\n\n\nZend\\Expressive\\Application::DISPATCH_MIDDLEWARE\n for the\n  dispatch middleware.\n\n\n\n\nAs an example:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n        Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n        [ /* ... */ ],\n    ],\n];\n\n\n\n\n\nPlace routing middleware correctly\n\n\nIf you are defining routes \nand\n defining other middleware for the pipeline,\nyou \nmust\n add the routing middleware. When you do so, make sure you put\nit at the appropriate location in the pipeline.\n\n\nTypically, you will place any middleware you want to execute on all requests\nprior to the routing middleware. This includes utilities for bootstrapping\nthe application (such as injection of the \nServerUrlHelper\n),\nutilities for injecting common response headers (such as CORS support), etc.\nMake sure these middleware specifications include the \npriority\n key, and that\nthe value of this key is greater than 1.\n\n\nUse priority to shape the specific workflow you want for your middleware.\n\n\n\n\nMiddleware items may be any \nvalid middleware\n,\nincluding \narrays\n of middleware, which indicate a nested middleware pipeline;\nthese may even contain the routing and dispatch middleware constants:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n                /* ... middleware that introspects routing results ... */\n                Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        [ /* ... */ ],\n    ],\n];\n\n\n\n\n\nPipeline keys are ignored\n\n\nKeys in a \nmiddleware_pipeline\n specification are ignored. However, they can\nbe useful when merging several configurations; if multiple configuration files\nspecify the same key, then those entries will be merged. Be aware, however,\nthat the \nmiddleware\n entry for each, since it is an indexed array, will\nmerge arrays by appending; in other words, order will not be guaranteed within\nthat array after merging. If order is critical, define a middleware spec with\n\npriority\n keys.\n\n\n\n\nThe path, if specified, can only be a literal path to match, and is typically\nused for segregating middleware applications or applying rules to subsets of an\napplication that match a common path root.\n\n\nSegregating your application to a subpath\n\n\nOne benefit of a middleware-based application is the ability to compose\nmiddleware and segregate them by paths. \nZend\\Expressive\\Application\n is itself\nmiddleware, allowing you to do exactly that if desired.\n\n\nIn the following example, we'll assume that \n$api\n and \n$blog\n are\n\nZend\\Expressive\\Application\n instances, and compose them into a\n\nZend\\Stratigility\\MiddlewarePipe\n.\n\n\nuse Zend\\Diactoros\\Server;\nuse Zend\\Diactoros\\ServerRequestFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$server = Server::createServerFromRequest(\n    $app,\n    ServerRequestFactory::fromGlobals()\n);\n$server->listen();\n\n\n\nYou could also compose them in an \nApplication\n instance, and utilize \nrun()\n:\n\n\n$app = AppFactory::create();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$app->run();\n\n\n\nThis approach allows you to develop discrete applications and compose them\ntogether to create a website.",
            "title": "Examples"
        },
        {
            "location": "/reference/usage-examples/#usage-examples",
            "text": "Below are several usage examples, covering a variety of ways of creating and\nmanaging an application.  In all examples, the assumption is the following directory structure:  .\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 public\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 vendor  We assume also that:   You have installed zend-expressive per the  installation instructions .  public/  will be the document root of your application.  Your own classes are under  src/  with the top-level namespace  App ,\n  and you have configured  autoloading \n  in your  composer.json  for those classes (this should be done for you during\n  installation).",
            "title": "Usage Examples"
        },
        {
            "location": "/reference/usage-examples/#using-the-built-in-web-server",
            "text": "You can use the built-in web server to run the examples. Run:  $ php -S 0.0.0.0:8080 -t public  from the application root to start up a web server running on port 8080, and\nthen browse to http://localhost:8080/. If you used the Expressive installer,\nthe following is equivalent:  $ composer run --timeout=0 serve",
            "title": "Using the built-in web server"
        },
        {
            "location": "/reference/usage-examples/#setting-up-autoloading-for-the-application-namespace",
            "text": "In your  composer.json  file, place the following:  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"src/\"\n    }\n},  Once done, run:  $ composer dump-autoload",
            "title": "Setting up autoloading for the Application namespace"
        },
        {
            "location": "/reference/usage-examples/#routing",
            "text": "As noted in the  Application documentation ,\nrouting is abstracted and can be accomplished by calling any of the following\nmethods:   route($path, $middleware, array $methods = null, $name = null)  to route to a\n  path and match any HTTP method, multiple HTTP methods, or custom HTTP methods.  get($path, $middleware, $name = null)  to route to a path that will only\n  respond to the GET HTTP method.  post($path, $middleware, $name = null)  to route to a path that will only\n  respond to the POST HTTP method.  put($path, $middleware, $name = null)  to route to a path that will only\n  respond to the PUT HTTP method.  patch($path, $middleware, $name = null)  to route to a path that will only\n  respond to the PATCH HTTP method.  delete($path, $middleware, $name = null)  to route to a path that will only\n  respond to the DELETE HTTP method.   All methods return a  Zend\\Expressive\\Router\\Route  method, which allows you to\nspecify additional options to associate with the route (e.g., for specifying\ncriteria, default values to match, etc.).  As examples:  // GET\n// This demonstrates passing a middleware instance (assuming $helloWorld is\n// valid middleware)\n$app->get('/', $helloWorld);\n\n// POST\n// This example specifies the middleware as a service name instead of as\n// actual executable middleware.\n$app->post('/trackback', 'TrackBack');\n\n// PUT\n// This example shows operating on the returned route. In this case, it's adding\n// regex tokens to restrict what values for {id} will match. (The tokens feature\n// is specific to Aura.Router.)\n$app->put('/post/{id}', 'ReplacePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// PATCH\n// This example builds on the one above. Expressive allows you to specify\n// the same path for a route matching on a different HTTP method, and\n// corresponding to different middleware.\n$app->patch('/post/{id}', 'UpdatePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// DELETE\n$app->delete('/post/{id}', 'DeletePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// Matching ALL HTTP methods\n// If the underlying router supports matching any HTTP method, the following\n// will do so. Note: FastRoute *requires* you to specify the HTTP methods\n// allowed explicitly, and does not support wildcard routes. As such, the\n// following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH,\n// PUT, TRACE, and DELETE.\n// Just like the previous examples, it returns a Route instance that you can\n// further manipulate.\n$app->route('/post/{id}', 'HandlePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// Matching multiple HTTP methods\n// You can pass an array of HTTP methods as a third argument to route(); in such\n// cases, routing will match if any of the specified HTTP methods are provided.\n$app->route('/post', 'HandlePostCollection', ['GET', 'POST']);\n\n// Matching NO HTTP methods\n// Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be\n// honored. (In FastRoute, GET is also honored.)\n$app->route('/post', 'WillThisHandlePost', []);  Finally, if desired, you can create a  Zend\\Expressive\\Router\\Route  instance\nmanually and pass it to  route()  as the sole argument:  $route = new Route('/post', 'HandlePost', ['GET', 'POST']);\n$route->setOptions($options);\n\n$app->route($route);",
            "title": "Routing"
        },
        {
            "location": "/reference/usage-examples/#hello-world-using-a-container",
            "text": "Expressive works with  PSR-11 Container ,\nthough it's an optional feature. By default, if you use the  AppFactory , it\nwill use  zend-servicemanager \nso long as that package is installed.  In the following example, we'll populate the container with our middleware, and\nthe application will pull it from there when matched.  Edit your  public/index.php  to read as follows:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$container = new ServiceManager();\n\n$container->setFactory('HelloWorld', function ($container) {\n    return function ($request, DelegateInterface $delegate) {\n        return new TextResponse('Hello, world!');\n    };\n});\n\n$container->setFactory('Ping', function ($container) {\n    return function ($request, DelegateInterface $delegate) {\n        return new JsonResponse(['ack' => time()]);\n    };\n});\n\n$app = AppFactory::create($container);\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n$app->run();  In the example above, we pass our container to  AppFactory . We could have also\ndone this instead:  $app = AppFactory::create();\n$container = $app->getContainer();  and then added our service definitions. We recommend passing the container to\nthe factory instead; if we ever change which container we use by default, your\ncode might not work!  The following two lines are the ones of interest:  $app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');  These map the two paths to  service names  instead of callables. When routing\nmatches a path, it does the following:   If the middleware provided when defining the route is callable, it uses it\n  directly.  If the middleware is a valid service name in the container, it pulls it from\n  the container.  This is what happens in this example.  Finally, if no container is available, or the service name is not found in the\n  container, it checks to see if it's a valid class name; if so, it instantiates\n  and returns the class instance.   If you fire up your web server, you'll find that the  /  and  /ping  paths\ncontinue to work.  One other approach you could take would be to define the application itself in\nthe container, and then pull it from there:  $container->setFactory('Zend\\Expressive\\Application', function ($container) {\n    $app = AppFactory::create($container);\n    $app->get('/', 'HelloWorld');\n    $app->get('/ping', 'Ping');\n    return $app;\n});\n\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();  This is a nice way to encapsulate the application creation. You could then\npotentially move all service configuration to another file! (We already document an ApplicationFactory for exactly this scenario. )",
            "title": "Hello World using a Container"
        },
        {
            "location": "/reference/usage-examples/#hello-world-using-a-configuration-driven-container",
            "text": "In the above example, we configured our middleware as services, and then passed\nour service container to the application. At the end, we hinted that you could\npotentially define the application itself as a service.  Expressive already provides a service factory for the application instance\nto provide fine-grained control over your application. In this example, we'll\nleverage it, defining our routes via configuration.  First, we're going to leverage zend-config to merge configuration files. This is\nimportant, as it allows us to define local, environment-specific configuration\nin files that we then can exclude from our repository. This practice ensures\nthat things like credentials are not accidentally published in a public\nrepository, and also provides a mechanism for slip-streaming in\nconfiguration based on our environment (you might use different settings in\ndevelopment than in production, after all!).  First, install zend-config and zend-stdlib:  $ composer require zendframework/zend-config zendframework/zend-stdlib  Now we can start creating our configuration files and container factories.  In  config/config.php , place the following:  <?php\n\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Stdlib\\Glob;\n\n$config = [];\n// Load configuration from autoload path\nforeach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) {\n    $config = ArrayUtils::merge($config, include $file);\n}\n\n// Return an ArrayObject so we can inject the config as a service in Aura.Di\n// and still use array checks like ``is_array``.\nreturn new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS);  In  config/container.php , place the following:  <?php\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// Load configuration\n$config = require __DIR__.'/config.php';\n\n// Build container\n$container = new ServiceManager();\n(new Config($config['dependencies']))->configureServiceManager($container);\n\n// Inject config\n$container->setService('config', $config);\n\nreturn $container;  In  config/autoload/dependencies.global.php , place the following:  <?php\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            \\Application\\HelloWorldAction::class => InvokableFactory::class,\n            \\Application\\PingAction::class => InvokableFactory::class,\n        ],\n        'factories' => [\n            \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class,\n        ],\n    ]\n];  In  config/autoload/routes.global.php , place the following:  <?php\n\nreturn [\n    'routes' => [\n        [\n            'path' => '/',\n            'middleware' => \\Application\\HelloWorldAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n        [\n            'path' => '/ping',\n            'middleware' => \\Application\\PingAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n    ],\n];  In  src/Application/HelloWorld.php , place the following:  <?php\nnamespace Application;\n\nclass HelloWorld\n{\n    public function __invoke($req, $res, $next)\n    {\n        $res->getBody()->write('Hello, world!');\n        return $res;\n    }\n}  In  src/Application/Ping.php , place the following:  <?php\nnamespace Application;\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass Ping\n{\n    public function __invoke($req, $res, $next)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}  After that\u2019s done run:  composer dump-autoload  Finally, in  public/index.php , place the following:  <?php\n// Change to the project root, to simplify resolving paths\nchdir(dirname(__DIR__));\n\n// Setup autoloading\nrequire 'vendor/autoload.php';\n\n$container = include 'config/container.php';\n$app       = $container->get(Zend\\Expressive\\Application::class);\n$app->run();  Notice that our index file now doesn't have any code related to setting up the\napplication any longer! All it does is setup autoloading, retrieve our service\ncontainer, pull the application from it, and run it. Our choices for container,\nrouter, etc. are all abstracted, and if we change our mind later, this code will\ncontinue to work.  Firing up the web server, you'll see the same responses as the previous\nexamples.",
            "title": "Hello World using a Configuration-Driven Container"
        },
        {
            "location": "/reference/usage-examples/#hybrid-container-and-programmatic-creation",
            "text": "The above example may look a little daunting at first. By making everything\nconfiguration-driven, you sometimes lose a sense for how the code all fits\ntogether.  Fortunately, you can mix the two. Building on the example above, we'll add a new\nroute and middleware. Between pulling the application from the container and\ncalling  $app->run() , add the following in your  public/index.php :  $app->post('/post', function ($request, \\Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) {\n    return new \\Zend\\Diactoros\\Response\\TextResponse('IN POST!');\n});  Note that we're using  post()  here; that means you'll have to use cURL, HTTPie,\nPostman, or some other tool to test making a POST request to the path:  $ curl -X POST http://localhost:8080/post  You should see  IN POST!  for the response!  Using this approach, you can build re-usable applications that are\ncontainer-driven, and add one-off routes and middleware as needed.",
            "title": "Hybrid Container and Programmatic Creation"
        },
        {
            "location": "/reference/usage-examples/#using-the-container-to-register-middleware",
            "text": "If you use a container to fetch your application instance, you have an\nadditional option for specifying middleware for the pipeline: configuration:  <?php\nreturn [\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware Service Name or Callable',\n            'allowed_methods' => ['GET', 'POST', 'PATCH'],\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n    'middleware_pipeline' => [\n        // See specification below\n    ],\n];  The key to note is  middleware_pipeline , which is an array of middlewares to\nregister in the pipeline; each will each be  pipe() 'd to the Application in the\norder specified.  Each middleware specified must be in the following form:  [\n    // required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // optional:\n    'path'  => '/path/to/match',\n    'priority' => 1, // Integer\n]  Priority should be an integer, and follows the semantics of SplPriorityQueue : higher numbers indicate\nhigher priority (top of the queue; executed earliest), while lower numbers\nindicated lower priority (bottom of the queue, executed last);  negative values\nare low priority . Items of the same priority are executed in the order in which\nthey are attached.  The default priority is 1, and this priority is used by the routing and dispatch\nmiddleware. To indicate that middleware should execute  before  these, use a\npriority higher than 1.  The above specification can be used for all middleware, with one exception:\nregistration of the  routing  and/or  dispatch  middleware that Expressive\nprovides. In these cases, use the following constants, which will be caught by\nthe factory and expanded:   Zend\\Expressive\\Application::ROUTING_MIDDLEWARE  for the\n  routing middleware; this should always come before the dispatch middleware.  Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE  for the\n  dispatch middleware.   As an example:  return [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n        Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n        [ /* ... */ ],\n    ],\n];",
            "title": "Using the container to register middleware"
        },
        {
            "location": "/reference/usage-examples/#place-routing-middleware-correctly",
            "text": "If you are defining routes  and  defining other middleware for the pipeline,\nyou  must  add the routing middleware. When you do so, make sure you put\nit at the appropriate location in the pipeline.  Typically, you will place any middleware you want to execute on all requests\nprior to the routing middleware. This includes utilities for bootstrapping\nthe application (such as injection of the  ServerUrlHelper ),\nutilities for injecting common response headers (such as CORS support), etc.\nMake sure these middleware specifications include the  priority  key, and that\nthe value of this key is greater than 1.  Use priority to shape the specific workflow you want for your middleware.   Middleware items may be any  valid middleware ,\nincluding  arrays  of middleware, which indicate a nested middleware pipeline;\nthese may even contain the routing and dispatch middleware constants:  return [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n                /* ... middleware that introspects routing results ... */\n                Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        [ /* ... */ ],\n    ],\n];",
            "title": "Place routing middleware correctly"
        },
        {
            "location": "/reference/usage-examples/#pipeline-keys-are-ignored",
            "text": "Keys in a  middleware_pipeline  specification are ignored. However, they can\nbe useful when merging several configurations; if multiple configuration files\nspecify the same key, then those entries will be merged. Be aware, however,\nthat the  middleware  entry for each, since it is an indexed array, will\nmerge arrays by appending; in other words, order will not be guaranteed within\nthat array after merging. If order is critical, define a middleware spec with priority  keys.   The path, if specified, can only be a literal path to match, and is typically\nused for segregating middleware applications or applying rules to subsets of an\napplication that match a common path root.",
            "title": "Pipeline keys are ignored"
        },
        {
            "location": "/reference/usage-examples/#segregating-your-application-to-a-subpath",
            "text": "One benefit of a middleware-based application is the ability to compose\nmiddleware and segregate them by paths.  Zend\\Expressive\\Application  is itself\nmiddleware, allowing you to do exactly that if desired.  In the following example, we'll assume that  $api  and  $blog  are Zend\\Expressive\\Application  instances, and compose them into a Zend\\Stratigility\\MiddlewarePipe .  use Zend\\Diactoros\\Server;\nuse Zend\\Diactoros\\ServerRequestFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$server = Server::createServerFromRequest(\n    $app,\n    ServerRequestFactory::fromGlobals()\n);\n$server->listen();  You could also compose them in an  Application  instance, and utilize  run() :  $app = AppFactory::create();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$app->run();  This approach allows you to develop discrete applications and compose them\ntogether to create a website.",
            "title": "Segregating your application to a subpath"
        },
        {
            "location": "/reference/expressive-projects/",
            "text": "Projects powered by zend-expressive\n\n\nzend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.\n\n\nSample Code & Tutorials\n\n\n\n\nExpressive Tutorial (WIP) - \nsource\n\n\nAstroSplash\n - \nsource\n\n  (Also, read the \nrelated article on sitepoint\n)\n\n\nphp-ddd-cargo-sample\n - \nsource\n\n\n\n\nPersonal Sites\n\n\n\n\nmwop.net\n - \nsource\n\n\nxtreamwayz.com\n - \nsource\n\n\nalejandrocelaya.com\n - \nsource\n\n\nzimuel.it\n - \nsource",
            "title": "Expressive Projects"
        },
        {
            "location": "/reference/expressive-projects/#projects-powered-by-zend-expressive",
            "text": "zend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.",
            "title": "Projects powered by zend-expressive"
        },
        {
            "location": "/reference/expressive-projects/#sample-code-tutorials",
            "text": "Expressive Tutorial (WIP) -  source  AstroSplash  -  source \n  (Also, read the  related article on sitepoint )  php-ddd-cargo-sample  -  source",
            "title": "Sample Code &amp; Tutorials"
        },
        {
            "location": "/reference/expressive-projects/#personal-sites",
            "text": "mwop.net  -  source  xtreamwayz.com  -  source  alejandrocelaya.com  -  source  zimuel.it  -  source",
            "title": "Personal Sites"
        },
        {
            "location": "/reference/migration/rc-to-v1/",
            "text": "Migration from RC5 or earlier\n\n\nRC6 introduced changes to the following:\n\n\n\n\nThe routing middleware was split into separate middleware, one for routing,\n  and one for dispatching.\n\n\nDue to the above change, we decided to remove auto-registration of routing\n  middleware.\n\n\nThe above change also suggested an alternative to the middleware pipeline\n  configuration that simplifies it.\n\n\nRoute result observers are deprecated, and no longer triggered for routing\n  failures.\n\n\nMiddleware configuration specifications now accept a \npriority\n key to\n  guarantee the order of items. If you have defined your middleware pipeline in\n  multiple files that are then merged, you will need to defined these keys to\n  ensure order.\n\n\n\n\nRouting and Dispatch middleware\n\n\nPrior to RC6, the routing middleware:\n\n\n\n\nperformed routing\n\n\nnotified route result observers\n\n\ncreated a new request that composed the matched routing parameters as request\n  attributes, and composed the route result instance itself as a request\n  attribute.\n\n\nmarshaled the middleware matched by routing\n\n\ndispatched the marshaled middleware\n\n\n\n\nTo provide a better separation of concerns, we split the routing middleware into\ntwo distinct methods: \nroutingMiddleware()\n and \ndispatchMiddleware()\n.\n\n\nroutingMiddleware()\n performs the following duties:\n\n\n\n\nrouting; and\n\n\ncreating a new request that composes the matched routing parameters as request\n  attributes, and composes the route result instance itself as a request\n  attribute.\n\n\n\n\ndispatchMiddleware()\n performs the following duties:\n\n\n\n\nmarshaling the middleware specified in the route result; and\n\n\ndispatching the marshaled middleware.\n\n\n\n\nOne reason for this split is to allow injecting middleware to operate between\nrouting and dispatch. As an example, you could have middleware that determines\nif a matched route requires an authenticated identity:\n\n\npublic function __invoke($request, $response, $next)\n{\n    $result = $request->getAttribute(RouteResult::class);\n    if (! in_array($result->getMatchedRouteName(), $this->authRequired)) {\n        return $next($request, $response);\n    }\n\n    if (! $this->authenticated) {\n        return $next($request, $response->withStatus(401), 'authentication\n        required');\n    }\n}\n\n\n\nThe above could then be piped between the routing and dispatch middleware:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipe(AuthenticationMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n\n\nSince the routing middleware has been split, we determined we could no longer\nautomatically pipe the routing middleware; detection would require detecting\nboth sets of middleware, and ensuring they are in the correct order.\nAdditionally, since one goal of splitting the middleware is to allow\n\nsubstitutions\n for these responsibilities, auto-injection could in some cases\nbe undesired. As a result, we now require you to inject each manually.\n\n\nImpact\n\n\nThis change will require changes in your application.\n\n\n\n\nIf you are using Expressive programmatically (i.e., you are not using\n   a container and the \nZend\\Expressive\\Container\\ApplicationFactory\n),\n   you are now \nrequired\n to call \nApplication::pipeRoutingMiddleware()\n.\n   Additionally, a new method, \nApplication::pipeDispatchMiddleware()\n exists\n   for injecting the application with the dispatch middleware, this, too, must\n   be called.\n\n\n\n\nThis has a fortunate side effect: registering routed middleware no longer\n   affects the middleware pipeline order. As such, you can register your\n   pipeline first or last prior to running the application. The only stipulation\n   is that \nunless you register the routing \nand\n dispatch middleware, your routed\n   middleware will not be executed!\n As such, the following two lines \nmust\n\n   be added to your application prior to calling \nApplication::run()\n:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\n\n\nIf you are creating your \nApplication\n instance using a container and the\n   \nZend\\Expressive\\Container\\ApplicationFactory\n, you will need to update your\n   configuration to list the routing and dispatch middleware. The next section\n   details the configuration changes necessary.\n\n\n\n\nApplicationFactory configuration changes\n\n\nAs noted in the document summary, the middleware pipeline configuration was\nchanged starting in RC6.  The changes are done in such a way as to honor\nconfiguration from RC5 and earlier, but using such configuration will now prompt\nyou to update your application.\n\n\nRC5 and earlier defined the default \nmiddleware_pipeline\n configuration as follows:\n\n\nreturn [\n    'middleware_pipeline' => [\n        // An array of middleware to register prior to registration of the\n        // routing middleware\n        'pre_routing' => [\n            //[\n            // Required:\n            //    'middleware' => 'Name or array of names of middleware services and/or callables',\n            // Optional:\n            //    'path'  => '/path/to/match',\n            //    'error' => true,\n            //],\n            [\n                'middleware' => [\n                    Helper\\ServerUrlMiddleware::class,\n                    Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n        ],\n\n        // An array of middleware to register after registration of the\n        // routing middleware\n        'post_routing' => [\n            //[\n            // Required:\n            //    'middleware' => 'Name of middleware service, or a callable',\n            // Optional:\n            //    'path'  => '/path/to/match',\n            //    'error' => true,\n            //],\n        ],\n    ],\n];\n\n\n\nThe following changes have been made:\n\n\n\n\nThe concept of \npre_routing\n and \npost_routing\n have been deprecated, and will\n  be removed starting with the 1.1 version. A single middleware pipeline is now\n  provided, though \nany individual specification can also specify an array of\n  middleware\n.\n\n\nThe routing and dispatch middleware must now be added to your configuration\n  for them to be added to your application.\n\n\nMiddleware specifications can now optionally provide a \npriority\n key, with 1\n  being the default. High integer priority indicates earlier execution, while\n  low/negative integer priority indicates later execution. Items with the same\n  priority are executed in the order they are registered. Priority is now how\n  you can indicate the order in which middleware should execute.\n\n\n\n\nImpact\n\n\nWhile the configuration from RC5 and earlier will continue to work, it will\nraise deprecation notices. As such, you will need to update your configuration\nto follow the guidelines created with RC6.\n\n\nRC6 and later change the configuration to remove the \npre_routing\n and\n\npost_routing\n keys. However, individual items within the array retain the same\nformat as middleware inside those keys, with the addition of a new key,\n\npriority\n:\n\n\n[\n    // Required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // Optional:\n    //    'path'  => '/path/to/match',\n    //    'error' => true,\n    //    'priority' => 1, // integer\n]\n\n\n\nThe \npriority\n key is used to determine the order in which middleware is piped\nto the application. Higher integer values are piped earlier, while\nlower/negative integer values are piped later; middleware with the same priority\nare piped in the order in which they are discovered in the pipeline. The default\npriority used is 1.\n\n\nAdditionally, the routing and dispatch middleware now become items in the array;\nthey (or equivalent entries for your own implementations) must be present in\nyour configuration if you want your routed middleware to dispatch!  This change\ngives you full control over the flow of the pipeline.\n\n\nTo specify the routing middleware, use the constant\n\nZend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE\n in place of\na middleware array; this has the value \nEXPRESSIVE_ROUTING_MIDDLEWARE\n, if you\ndo not want to import the class. Similarly, for the dispatch middleware, use the\nconstant \nZend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE\n\n(value \nEXPRESSIVE_DISPATCH_MIDDLEWARE\n) to specify the dispatch middleware.\n\n\nAs such, the default configuration now becomes:\n\n\nreturn [\n    'middleware_pipeline' => [\n        // An array of middleware to pipe to the application.\n        // Each item is of the following structure:\n        // [\n        //     // Required:\n        //     'middleware' => 'Name or array of names of middleware services and/or callables',\n        //     // Optional:\n        //     'path'  => '/path/to/match',\n        //     'error' => true,\n        // ],\n        [\n            'middleware' => [\n                Helper\\ServerUrlMiddleware::class,\n            ],\n            'priority' => PHP_INT_MAX,\n        ],\n\n        // The following is an entry for:\n        // - routing middleware\n        // - middleware that reacts to the routing results\n        // - dispatch middleware\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ]\n\n        // The following is an entry for the dispatch middleware:\n\n        // Place error handling middleware after the routing and dispatch\n        // middleware, with negative priority.\n        // [\n        //     'middleware' => [\n        //     ],\n        //     'priority' => -1000,\n        // ],\n    ],\n];\n\n\n\nTo update an existing application:\n\n\n\n\nPromote all \npre_routing\n middleware up a level, and remove the \npre_routing\n\n  key. Provide a \npriority\n value greater than 1. We recommend having a single\n  middleware specification with an array of middleware that represents the \"pre\n  routing\" middleware.\n\n\nAdd the entries for \nZend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE\n\n  and \nZend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE\n\n  immediately following any \npre_routing\n middleware, and before any\n  \npost_routing\n middleware; we recommend grouping it per the above example.\n\n\nPromote all \npost_routing\n middleware up a level, and remove the\n  \npost_routing\n key. Provide a \npriority\n value less than 1 or negative.\n\n\nIf you have \nmiddleware_pipeline\n specifications in multiple files\n, you\n  will need to specify \npriority\n keys for all middleware in order to guarantee\n  order after merging. We recommend having a single middleware specification\n  with an array of middleware that represents the \"post routing\" middleware.\n\n\n\n\nAs an example, consider the following application configuration:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'pre_routing' => [\n            [\n                'middleware' => [\n                    Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                    Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n            ['middleware' => DebugToolbarMiddleware::class],\n            [\n                'middleware' => ApiMiddleware::class,\n                'path' => '/api',\n            ],\n        ],\n\n        'post_routing' => [\n            ['middleware' => NotFoundMiddleware::class, 'error' => true],\n        ],\n    ],\n];\n\n\n\nThis would be rewritten to the following to work with RC6 and later:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                DebugToolbarMiddleware::class,\n            ],\n            'priority' => PHP_INT_MAX,\n        ],\n        'api' => [\n            'middleware' => ApiMiddleware::class,\n            'path' => '/api',\n            'priority' => 100,\n        ],\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        'error' => [\n            'middleware' => [\n                NotFoundMiddleware::class,\n            ],\n            'error' => true,\n            'priority' => -1000,\n        ],\n    ],\n]\n\n\n\nNote in the above example the various groupings. By grouping middleware by\npriority, you can simplify adding new middleware, particularly if you know it\nshould execute before routing, or as error middleware, or between routing and\ndispatch.\n\n\n\n\nKeys are ignored\n\n\nThe above example provides keys for each middleware specification. The factory\nwill ignore these, but they can be useful for cases when you might want to\nspecify configuration in multiple files, and merge specific entries together.\nBe aware, however, that the \nmiddleware\n key itself is an indexed array;\nitems will be appended based on the order in which configuration files are\nmerged. If order of these is important, create separate specifications with\nrelevant \npriority\n values.\n\n\n\n\nRoute result observer deprecation\n\n\nAs of RC6, the following changes have occurred with regards to route result\nobservers:\n\n\n\n\nThey are deprecated for usage with \nZend\\Expressive\\Application\n, and that\n  class will not be a route result subject starting in 1.1. You will need to\n  start migrating to alternative solutions.\n\n\nThe functionality for notifying observers has been moved from the routing\n  middleware into a dedicated \nApplication::routeResultObserverMiddleware()\n\n  method. This middleware must be piped separately to the middleware pipeline\n  for it to trigger.\n\n\n\n\nImpact\n\n\nIf you are using any route result observers, you will need to ensure your\napplication notifies them, and you will want to migrate to alternative solutions\nto ensure your functionality continues to work.\n\n\nTo ensure your observers are triggered, you will need to adapt your application,\nbased on how you create your instance.\n\n\nIf you are \nnot\n using the \nApplicationFactory\n, you will need to pipe the\n\nrouteResultObserverMiddleware\n to your application, between the routing and\ndispatch middleware:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeRouteResultObserverMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nIf you are using the \nApplicationFactory\n, you may need to update your\nconfiguration to allow injecting the route result observer middleware. If you\nhave \nnot\n updated your configuration to remove the \npre_routing\n and/or\n\npost_routing\n keys, the middleware \nwill\n be registered for you. If you have,\nhowever, you will need to register it following the routing middleware:\n\n\n[\n    'middleware_pipeline' => [\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTE_RESULT_OBSERVER_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n]\n\n\n\nTo make your observers forwards-compatible requires two changes:\n\n\n\n\nRewriting your observer as middleware.\n\n\nRegistering your observer as middleware following the routing middleware.\n\n\n\n\nIf your observer looked like the following:\n\n\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Router\\RouteResultObserverInterface;\n\nclass MyObserver implements RouteResultObserverInterface\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function update(RouteResult $result)\n    {\n        $this->logger->log($result);\n    }\n}\n\n\n\nYou could rewrite it as follows:\n\n\nuse Zend\\Expressive\\Router\\RouteResult;\n\nclass MyObserver\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $result = $request->getAttribute(RouteResult::class, false);\n        if (! $result) {\n            return $next($request, $response);\n        }\n\n        $this->logger->log($result);\n        return $next($request, $response);\n    }\n}\n\n\n\nYou would then register it following the routing middleware. If you are building\nyour application programmatically, you would do this as follows:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipe(MyObserver::class);\n$app->pipeDispatchMiddleware();\n\n\n\nIf you are using the \nApplicationFactory\n, alter your configuration:\n\n\n[\n    'middleware_pipeline' => [\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                MyObserver::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n]\n\n\n\nTimeline for migration\n\n\nThe following features will be removed in version 1.1.0:\n\n\n\n\nSupport for the \npre_routing\n and \npost_routing\n configuration.\n\n\nSupport for route result observers.",
            "title": "From RC5 and Earlier"
        },
        {
            "location": "/reference/migration/rc-to-v1/#migration-from-rc5-or-earlier",
            "text": "RC6 introduced changes to the following:   The routing middleware was split into separate middleware, one for routing,\n  and one for dispatching.  Due to the above change, we decided to remove auto-registration of routing\n  middleware.  The above change also suggested an alternative to the middleware pipeline\n  configuration that simplifies it.  Route result observers are deprecated, and no longer triggered for routing\n  failures.  Middleware configuration specifications now accept a  priority  key to\n  guarantee the order of items. If you have defined your middleware pipeline in\n  multiple files that are then merged, you will need to defined these keys to\n  ensure order.",
            "title": "Migration from RC5 or earlier"
        },
        {
            "location": "/reference/migration/rc-to-v1/#routing-and-dispatch-middleware",
            "text": "Prior to RC6, the routing middleware:   performed routing  notified route result observers  created a new request that composed the matched routing parameters as request\n  attributes, and composed the route result instance itself as a request\n  attribute.  marshaled the middleware matched by routing  dispatched the marshaled middleware   To provide a better separation of concerns, we split the routing middleware into\ntwo distinct methods:  routingMiddleware()  and  dispatchMiddleware() .  routingMiddleware()  performs the following duties:   routing; and  creating a new request that composes the matched routing parameters as request\n  attributes, and composes the route result instance itself as a request\n  attribute.   dispatchMiddleware()  performs the following duties:   marshaling the middleware specified in the route result; and  dispatching the marshaled middleware.   One reason for this split is to allow injecting middleware to operate between\nrouting and dispatch. As an example, you could have middleware that determines\nif a matched route requires an authenticated identity:  public function __invoke($request, $response, $next)\n{\n    $result = $request->getAttribute(RouteResult::class);\n    if (! in_array($result->getMatchedRouteName(), $this->authRequired)) {\n        return $next($request, $response);\n    }\n\n    if (! $this->authenticated) {\n        return $next($request, $response->withStatus(401), 'authentication\n        required');\n    }\n}  The above could then be piped between the routing and dispatch middleware:  $app->pipeRoutingMiddleware();\n$app->pipe(AuthenticationMiddleware::class);\n$app->pipeDispatchMiddleware();  Since the routing middleware has been split, we determined we could no longer\nautomatically pipe the routing middleware; detection would require detecting\nboth sets of middleware, and ensuring they are in the correct order.\nAdditionally, since one goal of splitting the middleware is to allow substitutions  for these responsibilities, auto-injection could in some cases\nbe undesired. As a result, we now require you to inject each manually.",
            "title": "Routing and Dispatch middleware"
        },
        {
            "location": "/reference/migration/rc-to-v1/#impact",
            "text": "This change will require changes in your application.   If you are using Expressive programmatically (i.e., you are not using\n   a container and the  Zend\\Expressive\\Container\\ApplicationFactory ),\n   you are now  required  to call  Application::pipeRoutingMiddleware() .\n   Additionally, a new method,  Application::pipeDispatchMiddleware()  exists\n   for injecting the application with the dispatch middleware, this, too, must\n   be called.   This has a fortunate side effect: registering routed middleware no longer\n   affects the middleware pipeline order. As such, you can register your\n   pipeline first or last prior to running the application. The only stipulation\n   is that  unless you register the routing  and  dispatch middleware, your routed\n   middleware will not be executed!  As such, the following two lines  must \n   be added to your application prior to calling  Application::run() :  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();   If you are creating your  Application  instance using a container and the\n    Zend\\Expressive\\Container\\ApplicationFactory , you will need to update your\n   configuration to list the routing and dispatch middleware. The next section\n   details the configuration changes necessary.",
            "title": "Impact"
        },
        {
            "location": "/reference/migration/rc-to-v1/#applicationfactory-configuration-changes",
            "text": "As noted in the document summary, the middleware pipeline configuration was\nchanged starting in RC6.  The changes are done in such a way as to honor\nconfiguration from RC5 and earlier, but using such configuration will now prompt\nyou to update your application.  RC5 and earlier defined the default  middleware_pipeline  configuration as follows:  return [\n    'middleware_pipeline' => [\n        // An array of middleware to register prior to registration of the\n        // routing middleware\n        'pre_routing' => [\n            //[\n            // Required:\n            //    'middleware' => 'Name or array of names of middleware services and/or callables',\n            // Optional:\n            //    'path'  => '/path/to/match',\n            //    'error' => true,\n            //],\n            [\n                'middleware' => [\n                    Helper\\ServerUrlMiddleware::class,\n                    Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n        ],\n\n        // An array of middleware to register after registration of the\n        // routing middleware\n        'post_routing' => [\n            //[\n            // Required:\n            //    'middleware' => 'Name of middleware service, or a callable',\n            // Optional:\n            //    'path'  => '/path/to/match',\n            //    'error' => true,\n            //],\n        ],\n    ],\n];  The following changes have been made:   The concept of  pre_routing  and  post_routing  have been deprecated, and will\n  be removed starting with the 1.1 version. A single middleware pipeline is now\n  provided, though  any individual specification can also specify an array of\n  middleware .  The routing and dispatch middleware must now be added to your configuration\n  for them to be added to your application.  Middleware specifications can now optionally provide a  priority  key, with 1\n  being the default. High integer priority indicates earlier execution, while\n  low/negative integer priority indicates later execution. Items with the same\n  priority are executed in the order they are registered. Priority is now how\n  you can indicate the order in which middleware should execute.",
            "title": "ApplicationFactory configuration changes"
        },
        {
            "location": "/reference/migration/rc-to-v1/#impact_1",
            "text": "While the configuration from RC5 and earlier will continue to work, it will\nraise deprecation notices. As such, you will need to update your configuration\nto follow the guidelines created with RC6.  RC6 and later change the configuration to remove the  pre_routing  and post_routing  keys. However, individual items within the array retain the same\nformat as middleware inside those keys, with the addition of a new key, priority :  [\n    // Required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // Optional:\n    //    'path'  => '/path/to/match',\n    //    'error' => true,\n    //    'priority' => 1, // integer\n]  The  priority  key is used to determine the order in which middleware is piped\nto the application. Higher integer values are piped earlier, while\nlower/negative integer values are piped later; middleware with the same priority\nare piped in the order in which they are discovered in the pipeline. The default\npriority used is 1.  Additionally, the routing and dispatch middleware now become items in the array;\nthey (or equivalent entries for your own implementations) must be present in\nyour configuration if you want your routed middleware to dispatch!  This change\ngives you full control over the flow of the pipeline.  To specify the routing middleware, use the constant Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE  in place of\na middleware array; this has the value  EXPRESSIVE_ROUTING_MIDDLEWARE , if you\ndo not want to import the class. Similarly, for the dispatch middleware, use the\nconstant  Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE \n(value  EXPRESSIVE_DISPATCH_MIDDLEWARE ) to specify the dispatch middleware.  As such, the default configuration now becomes:  return [\n    'middleware_pipeline' => [\n        // An array of middleware to pipe to the application.\n        // Each item is of the following structure:\n        // [\n        //     // Required:\n        //     'middleware' => 'Name or array of names of middleware services and/or callables',\n        //     // Optional:\n        //     'path'  => '/path/to/match',\n        //     'error' => true,\n        // ],\n        [\n            'middleware' => [\n                Helper\\ServerUrlMiddleware::class,\n            ],\n            'priority' => PHP_INT_MAX,\n        ],\n\n        // The following is an entry for:\n        // - routing middleware\n        // - middleware that reacts to the routing results\n        // - dispatch middleware\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ]\n\n        // The following is an entry for the dispatch middleware:\n\n        // Place error handling middleware after the routing and dispatch\n        // middleware, with negative priority.\n        // [\n        //     'middleware' => [\n        //     ],\n        //     'priority' => -1000,\n        // ],\n    ],\n];  To update an existing application:   Promote all  pre_routing  middleware up a level, and remove the  pre_routing \n  key. Provide a  priority  value greater than 1. We recommend having a single\n  middleware specification with an array of middleware that represents the \"pre\n  routing\" middleware.  Add the entries for  Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE \n  and  Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE \n  immediately following any  pre_routing  middleware, and before any\n   post_routing  middleware; we recommend grouping it per the above example.  Promote all  post_routing  middleware up a level, and remove the\n   post_routing  key. Provide a  priority  value less than 1 or negative.  If you have  middleware_pipeline  specifications in multiple files , you\n  will need to specify  priority  keys for all middleware in order to guarantee\n  order after merging. We recommend having a single middleware specification\n  with an array of middleware that represents the \"post routing\" middleware.   As an example, consider the following application configuration:  return [\n    'middleware_pipeline' => [\n        'pre_routing' => [\n            [\n                'middleware' => [\n                    Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                    Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n            ['middleware' => DebugToolbarMiddleware::class],\n            [\n                'middleware' => ApiMiddleware::class,\n                'path' => '/api',\n            ],\n        ],\n\n        'post_routing' => [\n            ['middleware' => NotFoundMiddleware::class, 'error' => true],\n        ],\n    ],\n];  This would be rewritten to the following to work with RC6 and later:  return [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                DebugToolbarMiddleware::class,\n            ],\n            'priority' => PHP_INT_MAX,\n        ],\n        'api' => [\n            'middleware' => ApiMiddleware::class,\n            'path' => '/api',\n            'priority' => 100,\n        ],\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        'error' => [\n            'middleware' => [\n                NotFoundMiddleware::class,\n            ],\n            'error' => true,\n            'priority' => -1000,\n        ],\n    ],\n]  Note in the above example the various groupings. By grouping middleware by\npriority, you can simplify adding new middleware, particularly if you know it\nshould execute before routing, or as error middleware, or between routing and\ndispatch.",
            "title": "Impact"
        },
        {
            "location": "/reference/migration/rc-to-v1/#keys-are-ignored",
            "text": "The above example provides keys for each middleware specification. The factory\nwill ignore these, but they can be useful for cases when you might want to\nspecify configuration in multiple files, and merge specific entries together.\nBe aware, however, that the  middleware  key itself is an indexed array;\nitems will be appended based on the order in which configuration files are\nmerged. If order of these is important, create separate specifications with\nrelevant  priority  values.",
            "title": "Keys are ignored"
        },
        {
            "location": "/reference/migration/rc-to-v1/#route-result-observer-deprecation",
            "text": "As of RC6, the following changes have occurred with regards to route result\nobservers:   They are deprecated for usage with  Zend\\Expressive\\Application , and that\n  class will not be a route result subject starting in 1.1. You will need to\n  start migrating to alternative solutions.  The functionality for notifying observers has been moved from the routing\n  middleware into a dedicated  Application::routeResultObserverMiddleware() \n  method. This middleware must be piped separately to the middleware pipeline\n  for it to trigger.",
            "title": "Route result observer deprecation"
        },
        {
            "location": "/reference/migration/rc-to-v1/#impact_2",
            "text": "If you are using any route result observers, you will need to ensure your\napplication notifies them, and you will want to migrate to alternative solutions\nto ensure your functionality continues to work.  To ensure your observers are triggered, you will need to adapt your application,\nbased on how you create your instance.  If you are  not  using the  ApplicationFactory , you will need to pipe the routeResultObserverMiddleware  to your application, between the routing and\ndispatch middleware:  $app->pipeRoutingMiddleware();\n$app->pipeRouteResultObserverMiddleware();\n$app->pipeDispatchMiddleware();  If you are using the  ApplicationFactory , you may need to update your\nconfiguration to allow injecting the route result observer middleware. If you\nhave  not  updated your configuration to remove the  pre_routing  and/or post_routing  keys, the middleware  will  be registered for you. If you have,\nhowever, you will need to register it following the routing middleware:  [\n    'middleware_pipeline' => [\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTE_RESULT_OBSERVER_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n]  To make your observers forwards-compatible requires two changes:   Rewriting your observer as middleware.  Registering your observer as middleware following the routing middleware.   If your observer looked like the following:  use Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Router\\RouteResultObserverInterface;\n\nclass MyObserver implements RouteResultObserverInterface\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function update(RouteResult $result)\n    {\n        $this->logger->log($result);\n    }\n}  You could rewrite it as follows:  use Zend\\Expressive\\Router\\RouteResult;\n\nclass MyObserver\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $result = $request->getAttribute(RouteResult::class, false);\n        if (! $result) {\n            return $next($request, $response);\n        }\n\n        $this->logger->log($result);\n        return $next($request, $response);\n    }\n}  You would then register it following the routing middleware. If you are building\nyour application programmatically, you would do this as follows:  $app->pipeRoutingMiddleware();\n$app->pipe(MyObserver::class);\n$app->pipeDispatchMiddleware();  If you are using the  ApplicationFactory , alter your configuration:  [\n    'middleware_pipeline' => [\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                MyObserver::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n]",
            "title": "Impact"
        },
        {
            "location": "/reference/migration/rc-to-v1/#timeline-for-migration",
            "text": "The following features will be removed in version 1.1.0:   Support for the  pre_routing  and  post_routing  configuration.  Support for route result observers.",
            "title": "Timeline for migration"
        },
        {
            "location": "/reference/migration/to-v1-1/",
            "text": "Migration to Expressive 1.1\n\n\nExpressive 1.1 should not result in any upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:\n\n\n\n\nDeprecations\n\n\nOriginal request and response messages\n\n\nRecommendation to use programmatic pipelines\n\n\nError handling\n\n\n\n\nDeprecations\n\n\nThe following classes and/or methods are deprecated with the 1.1.0 release, and\nwill be removed for the 2.0 release:\n\n\n\n\n\n\nZend\\Expressive\\Application::pipeErrorHandler()\n: Stratigility v1 error\n  middleware are removed in the Stratigility v2 release, which Expressive 2.0 will\n  adopt.\n\n\n\n\n\n\nZend\\Expressive\\Application::routeMiddleware()\n: routing middleware moves to\n  a dedicated class starting in Expressive 2.0. If you were referencing the\n  method in order to pipe it as middleware, use \npipeRoutingMiddleware()\n or\n  \npipe(ApplicationFactory::ROUTING_MIDDLEWARE)\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Application::dispatchMiddleware()\n: dispatch middleware moves\n  to a dedicated class starting in Expressive 2.0.If you were referencing the\n  method in order to pipe it as middleware, use \npipeDispatchMiddleware()\n or\n  \npipe(ApplicationFactory::DISPATCH_MIDDLEWARE)\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Application::getFinalHandler()\n: this method gets renamed to\n  \ngetDefaultDelegate()\n in Expressive 2.0. We recommend retrieving the value\n  from the application dependency injection container if you need it elsewhere.\n\n\n\n\n\n\nZend\\Expressive\\Application::raiseThrowables()\n: this method becomes a no-op\n  in Stratigility 2.0, on which Expressive 2.0 is based; the behavior it enabled\n  becomes the default behavior in that version.\n\n\n\n\n\n\nZend\\Expressive\\Container\\Exception\\InvalidArgumentException\n: this exception\n  type is thrown by \nApplicationFactory\n; in Expressive 2.0, it throws\n  \nZend\\Expressive\\Exception\\InvalidArgumentException\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Container\\Exception\\NotFoundException\n: this exception type\n  is not currently used anyways.\n\n\n\n\n\n\nZend\\Expressive\\ErrorMiddlewarePipe\n: Stratigility v1 error middleware are\n  removed in the Stratigility v2 release, which Expressive 2.0 will adopt,\n  making this specialized middleware pipe type irrelvant.\n\n\n\n\n\n\nZend\\Expressive\\TemplatedErrorHandler\n and \nZend\\Expressive\\WhoopsErrorHandler\n:\n  The concept of \"final handlers\" will be removed in Expressive 2.0, to be\n  replaced with \"default delegates\" (implementations of\n  \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n that will be called if the\n  middleware pipeline is exhausted, and which will be guaranteed to return a\n  response). Expressive 2.0 will provide tooling to upgrade your dependencies to\n  make the transition seamless; end users will only be affected if they were\n  extending these classes.\n\n\n\n\n\n\nIf you were calling any of these directly, or extending or overriding them, you\nwill need to update your code to work for version 2.0. We recommend not using\nthese.\n\n\nOriginal messages\n\n\nStratigility 1.3 deprecates its internal request and response decorators,\n\nZend\\Stratigility\\Http\\Request\n and \nZend\\Stratigility\\Http\\Response\n,\nrespectively. The main utility of these instances was to provide access in\ninner middleware layers to the original request, original response, and original\nURI.\n\n\nAs such access may still be desired, Stratigility 1.3 introduced\n\nZend\\Stratigility\\Middleware\\OriginalMessages\n. This middleware injects the\nfollowing attributes into the request it passes to \n$next()\n:\n\n\n\n\noriginalRequest\n is the request instance provided to the middleware.\n\n\noriginalUri\n is the URI instance associated with that request.\n\n\noriginalResponse\n is the response instance provided to the middleware.\n\n\n\n\nZend\\Stratigility\\FinalHandler\n was updated to use these when they're\navailable starting with version 1.0.3.\n\n\nWe recommend adding the \nOriginalMessages\n middleware as the outermost (first)\nmiddleware in your pipeline. Using configuration-driven middleware, that would\nlook like this:\n\n\n// config/autoload/middleware-pipeline.global.php\n/* ... */\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            OriginalMessages::class => OriginalMessages::class,\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                OriginalMessages::class, // <----- Add this entry\n                Helper\\ServerUrlMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n\n        /* ... */\n    ],\n];\n\n\n\nIf you are \nprogrammatically creating your pipeline\n,\nuse the following:\n\n\n$app->pipe(OriginalMessages::class);\n/* all other middleware */\n\n\n\nIdentifying and fixing getOriginal calls\n\n\nTo help you identify and update calls in your own code to the \ngetOriginal*()\n\nmethods, we provide a tool via the \nzendframework/zend-expressive-tooling\n\npackage, \nvendor/bin/expressive-migrate-original-messages\n.\n\n\nFirst, install the tooling package; since the tooling it provides is only\nuseful during development, install it as a development requirement:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nOnce installed,  you can execute the tool using:\n\n\n$ ./vendor/bin/expressive-migrate-original-messages\n\n\n\nPassing the arguments \nhelp\n, \n--help\n, or \n-h\n will provide usage information;\nin most cases, it will assume sane defaults in order to run its scans.\n\n\nThe tool updates calls to \ngetOriginalRequest()\n and \ngetOriginalUri()\n to\ninstead use the new request attributes that the \nOriginalMessages\n middleware\ninjects:\n\n\n\n\ngetOriginalRequest()\n becomes \ngetAttribute('originalRequest', $request)\n\n\ngetOriginalUri()\n becomes \ngetAttribute('originalUri', $request->getUri())\n\n\n\n\nIn both cases, \n$request\n will be replaced with whatever variable name you used\nfor the request instance.\n\n\nFor \ngetOriginalResponse()\n calls, which happen on the response instance, the\ntool will instead tell you what files had such calls, and detail how you can\nupdate those calls to use the \noriginalResponse\n request attribute.\n\n\nProgrammatic middleware pipelines\n\n\nWith Expressive 1.0, we recommended creating middleware pipelines and routing\nvia configuration. Starting with 1.1, we recommend \nprogrammatic creation of\npipelines and routing\n.\n\n\nProgrammatic pipelines exercise the existing Expressive API. Methods include:\n\n\n\n\n\n\npipe()\n allows you to pipe middleware for the pipeline; this can optionally\n  take a \n$path\n argument. (If one argument is present, it is assumed to be\n  middleware; with two arguments, the first argument is the \n$path\n.) Paths are\n  literal URI path segments. If the incoming request matches that segment, the\n  middleware will execute; otherwise, it will not. These can be used to provide\n  sub-applications with their own routing.\n\n\n\n\n\n\npipeRoutingMiddleware()\n is used to pipe the internal routing middleware into\n  the pipeline.\n\n\n\n\n\n\npipeDispatchMiddleware()\n is used to pipe the internal dispatch middleware into\n  the pipeline.\n\n\n\n\n\n\npipeErrorMiddleware()\n is used to pipe the legacy Stratigility error\n  middleware into the pipeline. We recommend \nNOT\n using this method, and\n  instead adapting your application to use \nstandard middleware for error\n  handling\n. Otherwise, it acts just like \npipe()\n.\n  Starting in Expressive 1.1, this method will emit a deprecation notice.\n\n\n\n\n\n\nAs an example pipeline:\n\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(Helper\\UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);\n\n\n\nExpressive also provides methods for specifying routed middleware. These\ninclude:\n\n\n\n\nget($path, $middleware, $name = null)\n\n\npost($path, $middleware, $name = null)\n\n\nput($path, $middleware, $name = null)\n\n\npatch($path, $middleware, $name = null)\n\n\ndelete($path, $middleware, $name = null)\n\n\nroute($path, $middleware, array $methods = null, $name = null)\n\n\n\n\nEach returns a \nZend\\Expressive\\Router\\Route\n instance; this is useful if you\nwish to provide additional options to your route:\n\n\n$app->get('/api/ping', Ping::class)\n    ->setOptions([\n        'timestamp' => date(),\n    ]);\n\n\n\nAs an example, the default routes defined in the skeleton application can be\nwritten as follows:\n\n\n$app->get('/', \\App\\Action\\HomePageAction::class, 'home');\n$app->get('/api/ping', \\App\\Action\\PingAction::class, 'api.ping');\n\n\n\nWe recommend rewriting your middleware pipeline and routing configuration into\nprogrammatic/declarative statements. Specifically:\n\n\n\n\nWe recommend putting the pipeline declarations into \nconfig/pipeline.php\n.\n\n\nWe recommend putting the routing declarations into \nconfig/routes.php\n.\n\n\n\n\nOnce you've written these, you will then need to make the following changes to\nyour application:\n\n\n\n\nFirst, enable the \nzend-expressive.programmatic_pipeline\n configuration flag.\n  This can be done in any \nconfig/autoload/*.global.php\n file:\n\n\n\n\nreturn [\n    'zend-expressive' => [\n        'programmatic_pipeline' => true,\n    ],\n];\n\n\n\nOnce enabled, any \nmiddleware_pipeline\n or \nroutes\n configuration will be\n  ignored when creating the \nApplication\n instance.\n\n\n\n\nSecond, update your \npublic/index.php\n to add the following lines immediately\n  prior to calling \n$app->run();\n:\n\n\n\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n\n\nOnce this has been done, the application will use your new programmatic\npipelines instead of configuration. You can remove the \nmiddleware_pipeline\n and\n\nroutes\n configuration after verifying your application continues to work.\n\n\nFor programmatic pipelines to work properly, you will also need to provide error\nhandling middleware, which is discussed in the next section.\n\n\nError handling\n\n\nPrior to version 1.1, error handling was accomplished via two mechanisms:\n\n\n\n\nStratigility \"error middleware\" (middleware with the signature \nfunction\n  ($error, ServerRequestInterface $request, ResponseInterface $response,\n  callable $next)\n). This middleware would be invoked when calling \n$next()\n\n  with a third argument indicating an error, and would be expected to handle it\n  or delegate to the next error middleware.\n\n\n\n\nInternally, Stratigility would execute each middleware within a try/catch\n  block; if an exception were caught, it would then delegate to the next \nerror\n  middleware\n using the caught exception as the \n$err\n argument.\n\n\n\n\nThe \"Final Handler\". This is a handler invoked when the middleware pipeline is\n  exhausted without returning a response, and has the signature \nfunction\n  (ServerRequestInterface $request, ResponseInterface $response, $err = null)\n;\n  it is provided to the middleware pipeline when invoking the outermost\n  middleware; in the case of Expressive, it is composed in the \nApplication\n\n  instance, and passed to the application middleware when it executes \nrun()\n.\n  When invoked, it needs to decide if invocation is due to no middleware\n  executing (HTTP 404 status), middleware calling \n$next()\n with an altered\n  response (response is then returned), or due to invocation of error middleware\n  (calling \n$next()\n with the third, error, argument) with no error middleware\n  returning a response.\n\n\n\n\nExpressive 1.1 updates the minimum supported Stratigility version to 1.3, which\ndeprecates the concept of error middleware, and recommends a \"final handler\"\nthat does no error handling, but instead returns a canned response (typically a\n404). Additionally, it deprecates the practice of wrapping middleware execution\nin a try/catch block, and provides a flag for disabling that behavior entirely,\n\nraise_throwables\n.\n\n\nStarting in Expressive 1.1, you can set the \nraise_throwables\n flag in your\nconfiguration:\n\n\nreturn [\n    'zend-expressive' => [\n        'raise_throwables' => true,\n    ],\n];\n\n\n\nWhen enabled, the internal dispatcher will no longer catch exceptions.\n\n\nThis both allows you to, and \nrequires\n you to, write your own error handling\nmiddleware. This will require two things:\n\n\n\n\nMiddleware with a try/catch block that operates as the outermost (or close to\n  outermost) layer of your application, and which can provide error pages or\n  details to your end users.\n\n\nMiddleware at the innermost layer that is guaranteed to return a response;\n  generally, reaching this means no middleware was able to route the request, and\n  thus a 404 condition.\n\n\n\n\nThe below sections detail approaches to each.\n\n\nError handling middleware\n\n\nError handling middleware generally will look something like this:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    try {\n        $response = $next($request, $response);\n        return $response;\n    } catch (\\Throwable $exception) {\n        // caught PHP 7 throwable\n    } catch (\\Exception $exception) {\n        // caught PHP 5 exception\n    }\n\n    // ...\n    // do something with $exception and generate a response\n    // ...\n\n    return $response;\n}\n\n\n\nStratigility 1.3 provides such an implementation via its\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n. In addition to the try/catch block,\nit also sets up a PHP error handler that will catch any PHP error types in the\ncurrent \nerror_reporting\n mask; the error handler will raise exceptions of the\ntype \nErrorException\n with the PHP error details.\n\n\nStratigility's \nErrorHandler\n allows injection of an \"error response generator\",\nwhich allows you to alter how the error response is generated based on the\ncurrent environment. Error response generators are callables with the signature:\n\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nWe recommend using the Stratigility \nErrorHandler\n and writing and attaching a\ncustom error response generator. As a simple example, the following details a\ngenerator that will use a template to display an error page:\n\n\nnamespace Acme;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedErrorResponseGenerator\n{\n    const TEMPLATE_DEFAULT = 'error::error';\n\n    private $renderer;\n\n    private $template;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $template = TEMPLATE_DEFAULT\n    ) {\n        $this->renderer = $renderer;\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        $e,\n        ServerRequestInterface $request,\n        ResponseInterface $response\n    ) {\n        $response->write($this->renderer->render($this->template, [\n            'exception' => $e,\n            'request'   => $request,\n        ]));\n        return $response;\n    }\n}\n\n\n\nYou might then create a factory for generating the \nErrorHandler\n and attaching\nthis response generator as follows:\n\n\nnamespace Acme\\Container;\n\nuse Acme\\TemplatedErrorResponseGenerator;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass ErrorHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $generator = new TemplatedErrorResponseGenerator(\n            $container->get(TemplateRendererInterface::class)\n        );\n\n        return new ErrorHandler(new Response(), $generator);\n    }\n}\n\n\n\nOnce that is created you can tell your middleware configuration about it:\n\n\n// in config/autoload/middleware-pipeline.global.php\nuse Acme\\Container\\ErrorHandlerFactory;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            ErrorHandler::class => ErrorHandlerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                ErrorHandler::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nAlternately, if using a programmatic pipeline, as detailed in the previous\nsection, you can use the following:\n\n\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(ErrorHandler::class);\n// add all other middleware after it\n\n\n\nNot Found middleware\n\n\nAt the innermost layer of your application, you need middleware guaranteed to\nreturn a response; typically, this indicates a failure to route the request,\nand, as such, an HTTP 404 response.  \nZend\\Stratigility\\Middleware\\NotFoundHandler\n\nprovides an implementation, but is written such that the response body remains\nempty. As such, you might write a custom, templated handler:\n\n\nnamespace Acme;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedNotFoundHandler\n{\n    const TEMPLATE_DEFAULT = 'error::404';\n\n    private $renderer;\n\n    private $template;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $template = self::TEMPLATE_DEFAULT\n    ) {\n        $this->renderer = $renderer;\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        $response = new Response();\n        $response->write($this->renderer->render($this->template));\n        return $response->withStatus(404);\n    }\n}\n\n\n\nSimilar to the discussion of the \nErrorHandler\n above, we'll create a factory\nfor this:\n\n\nnamespace Acme\\Container;\n\nuse Acme\\TemplatedNotFoundHandler;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedNotFoundHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new TemplatedNotFoundHandler(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}\n\n\n\nWe can then register it in our pipeline:\n\n\n// in config/autoload/middleware-pipeline.global.php\nuse Acme\\Container\\NotFoundHandlerFactory;\nuse Acme\\TemplatedNotFoundHandler;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            TemplatedNotFoundHandler::class => TemplatedNotFoundHandlerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        /* ... */\n\n        // After 'routing', but before 'error';\n        // alternately as last item in 'routing' middleware list.\n        'not-found' => [\n            'middleware' => TemplatedNotFoundHandler::class,\n            'priority' => 0,\n        ],\n\n        /* ... */\n    ],\n];\n\n\n\nIf you are using programmatic pipelines, as described in the previous section:\n\n\nuse Acme\\TemplatedNotFoundHandler;\n\n// all other pipeline directives, and then:\n$app->pipe(TemplatedNotFoundHandler::class);\n\n\n\nDetecting error middleware usage\n\n\nIf you use the new error handling paradigm, we recommend that you also audit\nyour application for legacy Stratigility error middleware, as well as invocation\nof error middleware. To do this, we provide a tool via the\n\nzendframework/zend-expressive-tooling\n\npackage, \nvendor/bin/expressive-scan-for-error-middleware\n.\n\n\nFirst, install the tooling as a development requirement:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nThe tool will scan the \nsrc/\n directory by default, but allows you to scan other\ndirectories via the \n--dir\n flag. It will detect and report files with any of\nthe following:\n\n\n\n\nClasses implementing \nZend\\Stratigility\\ErrorMiddlewareInterface\n.\n\n\nInvokable classes implementing the error middleware signature.\n\n\nMethods accepting \n$next\n that invoke it with an error argument.\n\n\n\n\nAs an example running it:\n\n\n$ ./vendor/bin/expressive-scan-for-error-middleware scan\n# or, with a directory argument:\n$ ./vendor/bin/expressive-scan-for-error-middleware scan --dir ./lib\n\n\n\nYou may also call the tool using its \nhelp\n command, or either of the \n--help\n\nor \n-h\n flags to get full usage information.\n\n\nUse this tool to identify potential problem areas in your application, and\nupdate your code to use the new error handling facilities as outlined above.\n\n\nFull example\n\n\nPutting all of the above together \u2014 \noriginal message\nmemoizing\n, \nprogrammatic\npipelines\n, and \nmiddleware-based error\nhandling\n \u2014 might look like the following examples.\n\n\nFirst, we'll tell Expressive to use programmatic pipelines, and to enable the\nnew error handling (by telling it to \"raise throwables\", instead of catching\nthem):\n\n\n// In config/autoload/zend-expressive.global.php:\nreturn [\n    /* ... */\n    'zend-expressive' => [\n        'programmatic_pipeline' => true,\n        'raise_throwables' => true,\n        /* ... */\n    ],\n];\n\n\n\nNext, we'll update \nconfig/autoload/middleware-pipeline.global.php\n to list only\ndependencies:\n\n\nuse Acme\\Container;\nuse Acme\\TemplatedNotFoundHandler;\nuse Zend\\Expressive\\Container\\ApplicationFactory;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            OriginalMessages::class => OriginalMesssages::class,\n        ],\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class,\n            Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class,\n            TemplatedNotFoundHandler::class => Container\\TemplatedNotFoundHandlerFactory::class,\n        ],\n    ],\n];\n\n\n\nWe'll also update \nconfig/autoload/routes.global.php\n to only list dependencies;\nin the following example, we list only the middleware shipped by default with\nthe skeleton application:\n\n\nuse App\\Action;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\nuse Zend\\Expressive\\Router\\RouterInterface;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            RouterInterface::class => FastRouteRouter::class,\n            Action\\PingAction::class => Action\\PingAction::class,\n        ],\n        'factories' => [\n            Action\\HomePageAction::class => Action\\HomePageFactory::class,\n        ],\n    ],\n];\n\n\n\nTo create our pipeline, we will create the file \nconfig/pipeline.php\n:\n\n\nuse Acme\\TemplatedNotFoundHandler;\nuse Zend\\Expressive\\Container\\ApplicationFactory;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(ErrorHandler::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe([\n    ApplicationFactory::ROUTING_MIDDLEWARE,\n    Helper\\UrlHelperMiddleware::class,\n    ApplicationFactory::DISPATCH_MIDDLEWARE,\n]);\n$app->pipe(TemplatedNotFoundHandler::class);\n\n\n\nNote that you can use \narrays\n of middleware just like you did in the\nconfiguration; this allows you to separate middleware into logical groups if\ndesired!\n\n\nTo provide our routed middleware, we will create the file\n\nconfig/pipeline.php\n:\n\n\nuse App\\Action;\n\n$app->get('/', Action\\HomePageAction::class, 'home');\n$app->get('/api/ping', Action\\PingAction::class, 'api.ping');\n\n\n\nThe above exercises the various routing methods of the \nApplication\n class.\n\n\nFinally, we will need to update our \npublic/index.php\n, to tell it to require\nour new pipeline and routing files; we'll do that between retrieving the\napplication from the container, and running the application:\n\n\n$app = $container->get(\\Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();\n\n\n\nWith these changes in place, your application should continue to run as it did\npreviously!\n\n\nLooking forward\n\n\nExpressive 2.0 will ship error handling middleware and \"not found\" middleware,\nas well as tools to convert your application to a programmatic pipeline in such\na way as to utilize these shipped implementations. In the meantime, however, you\ncan adopt programmatic pipelines and the new error handling paradigm within the\nversion 1 series using the configuration flags and guidelines listed above in\norder to make your application forwards-compatible.",
            "title": "To Expressive 1.1"
        },
        {
            "location": "/reference/migration/to-v1-1/#migration-to-expressive-11",
            "text": "Expressive 1.1 should not result in any upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:   Deprecations  Original request and response messages  Recommendation to use programmatic pipelines  Error handling",
            "title": "Migration to Expressive 1.1"
        },
        {
            "location": "/reference/migration/to-v1-1/#deprecations",
            "text": "The following classes and/or methods are deprecated with the 1.1.0 release, and\nwill be removed for the 2.0 release:    Zend\\Expressive\\Application::pipeErrorHandler() : Stratigility v1 error\n  middleware are removed in the Stratigility v2 release, which Expressive 2.0 will\n  adopt.    Zend\\Expressive\\Application::routeMiddleware() : routing middleware moves to\n  a dedicated class starting in Expressive 2.0. If you were referencing the\n  method in order to pipe it as middleware, use  pipeRoutingMiddleware()  or\n   pipe(ApplicationFactory::ROUTING_MIDDLEWARE)  instead.    Zend\\Expressive\\Application::dispatchMiddleware() : dispatch middleware moves\n  to a dedicated class starting in Expressive 2.0.If you were referencing the\n  method in order to pipe it as middleware, use  pipeDispatchMiddleware()  or\n   pipe(ApplicationFactory::DISPATCH_MIDDLEWARE)  instead.    Zend\\Expressive\\Application::getFinalHandler() : this method gets renamed to\n   getDefaultDelegate()  in Expressive 2.0. We recommend retrieving the value\n  from the application dependency injection container if you need it elsewhere.    Zend\\Expressive\\Application::raiseThrowables() : this method becomes a no-op\n  in Stratigility 2.0, on which Expressive 2.0 is based; the behavior it enabled\n  becomes the default behavior in that version.    Zend\\Expressive\\Container\\Exception\\InvalidArgumentException : this exception\n  type is thrown by  ApplicationFactory ; in Expressive 2.0, it throws\n   Zend\\Expressive\\Exception\\InvalidArgumentException  instead.    Zend\\Expressive\\Container\\Exception\\NotFoundException : this exception type\n  is not currently used anyways.    Zend\\Expressive\\ErrorMiddlewarePipe : Stratigility v1 error middleware are\n  removed in the Stratigility v2 release, which Expressive 2.0 will adopt,\n  making this specialized middleware pipe type irrelvant.    Zend\\Expressive\\TemplatedErrorHandler  and  Zend\\Expressive\\WhoopsErrorHandler :\n  The concept of \"final handlers\" will be removed in Expressive 2.0, to be\n  replaced with \"default delegates\" (implementations of\n   Interop\\Http\\ServerMiddleware\\DelegateInterface  that will be called if the\n  middleware pipeline is exhausted, and which will be guaranteed to return a\n  response). Expressive 2.0 will provide tooling to upgrade your dependencies to\n  make the transition seamless; end users will only be affected if they were\n  extending these classes.    If you were calling any of these directly, or extending or overriding them, you\nwill need to update your code to work for version 2.0. We recommend not using\nthese.",
            "title": "Deprecations"
        },
        {
            "location": "/reference/migration/to-v1-1/#original-messages",
            "text": "Stratigility 1.3 deprecates its internal request and response decorators, Zend\\Stratigility\\Http\\Request  and  Zend\\Stratigility\\Http\\Response ,\nrespectively. The main utility of these instances was to provide access in\ninner middleware layers to the original request, original response, and original\nURI.  As such access may still be desired, Stratigility 1.3 introduced Zend\\Stratigility\\Middleware\\OriginalMessages . This middleware injects the\nfollowing attributes into the request it passes to  $next() :   originalRequest  is the request instance provided to the middleware.  originalUri  is the URI instance associated with that request.  originalResponse  is the response instance provided to the middleware.   Zend\\Stratigility\\FinalHandler  was updated to use these when they're\navailable starting with version 1.0.3.  We recommend adding the  OriginalMessages  middleware as the outermost (first)\nmiddleware in your pipeline. Using configuration-driven middleware, that would\nlook like this:  // config/autoload/middleware-pipeline.global.php\n/* ... */\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            OriginalMessages::class => OriginalMessages::class,\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                OriginalMessages::class, // <----- Add this entry\n                Helper\\ServerUrlMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n\n        /* ... */\n    ],\n];  If you are  programmatically creating your pipeline ,\nuse the following:  $app->pipe(OriginalMessages::class);\n/* all other middleware */",
            "title": "Original messages"
        },
        {
            "location": "/reference/migration/to-v1-1/#identifying-and-fixing-getoriginal-calls",
            "text": "To help you identify and update calls in your own code to the  getOriginal*() \nmethods, we provide a tool via the  zendframework/zend-expressive-tooling \npackage,  vendor/bin/expressive-migrate-original-messages .  First, install the tooling package; since the tooling it provides is only\nuseful during development, install it as a development requirement:  $ composer require --dev zendframework/zend-expressive-tooling  Once installed,  you can execute the tool using:  $ ./vendor/bin/expressive-migrate-original-messages  Passing the arguments  help ,  --help , or  -h  will provide usage information;\nin most cases, it will assume sane defaults in order to run its scans.  The tool updates calls to  getOriginalRequest()  and  getOriginalUri()  to\ninstead use the new request attributes that the  OriginalMessages  middleware\ninjects:   getOriginalRequest()  becomes  getAttribute('originalRequest', $request)  getOriginalUri()  becomes  getAttribute('originalUri', $request->getUri())   In both cases,  $request  will be replaced with whatever variable name you used\nfor the request instance.  For  getOriginalResponse()  calls, which happen on the response instance, the\ntool will instead tell you what files had such calls, and detail how you can\nupdate those calls to use the  originalResponse  request attribute.",
            "title": "Identifying and fixing getOriginal calls"
        },
        {
            "location": "/reference/migration/to-v1-1/#programmatic-middleware-pipelines",
            "text": "With Expressive 1.0, we recommended creating middleware pipelines and routing\nvia configuration. Starting with 1.1, we recommend  programmatic creation of\npipelines and routing .  Programmatic pipelines exercise the existing Expressive API. Methods include:    pipe()  allows you to pipe middleware for the pipeline; this can optionally\n  take a  $path  argument. (If one argument is present, it is assumed to be\n  middleware; with two arguments, the first argument is the  $path .) Paths are\n  literal URI path segments. If the incoming request matches that segment, the\n  middleware will execute; otherwise, it will not. These can be used to provide\n  sub-applications with their own routing.    pipeRoutingMiddleware()  is used to pipe the internal routing middleware into\n  the pipeline.    pipeDispatchMiddleware()  is used to pipe the internal dispatch middleware into\n  the pipeline.    pipeErrorMiddleware()  is used to pipe the legacy Stratigility error\n  middleware into the pipeline. We recommend  NOT  using this method, and\n  instead adapting your application to use  standard middleware for error\n  handling . Otherwise, it acts just like  pipe() .\n  Starting in Expressive 1.1, this method will emit a deprecation notice.    As an example pipeline:  $app->pipe(OriginalMessages::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(Helper\\UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);  Expressive also provides methods for specifying routed middleware. These\ninclude:   get($path, $middleware, $name = null)  post($path, $middleware, $name = null)  put($path, $middleware, $name = null)  patch($path, $middleware, $name = null)  delete($path, $middleware, $name = null)  route($path, $middleware, array $methods = null, $name = null)   Each returns a  Zend\\Expressive\\Router\\Route  instance; this is useful if you\nwish to provide additional options to your route:  $app->get('/api/ping', Ping::class)\n    ->setOptions([\n        'timestamp' => date(),\n    ]);  As an example, the default routes defined in the skeleton application can be\nwritten as follows:  $app->get('/', \\App\\Action\\HomePageAction::class, 'home');\n$app->get('/api/ping', \\App\\Action\\PingAction::class, 'api.ping');  We recommend rewriting your middleware pipeline and routing configuration into\nprogrammatic/declarative statements. Specifically:   We recommend putting the pipeline declarations into  config/pipeline.php .  We recommend putting the routing declarations into  config/routes.php .   Once you've written these, you will then need to make the following changes to\nyour application:   First, enable the  zend-expressive.programmatic_pipeline  configuration flag.\n  This can be done in any  config/autoload/*.global.php  file:   return [\n    'zend-expressive' => [\n        'programmatic_pipeline' => true,\n    ],\n];  Once enabled, any  middleware_pipeline  or  routes  configuration will be\n  ignored when creating the  Application  instance.   Second, update your  public/index.php  to add the following lines immediately\n  prior to calling  $app->run(); :   require 'config/pipeline.php';\nrequire 'config/routes.php';  Once this has been done, the application will use your new programmatic\npipelines instead of configuration. You can remove the  middleware_pipeline  and routes  configuration after verifying your application continues to work.  For programmatic pipelines to work properly, you will also need to provide error\nhandling middleware, which is discussed in the next section.",
            "title": "Programmatic middleware pipelines"
        },
        {
            "location": "/reference/migration/to-v1-1/#error-handling",
            "text": "Prior to version 1.1, error handling was accomplished via two mechanisms:   Stratigility \"error middleware\" (middleware with the signature  function\n  ($error, ServerRequestInterface $request, ResponseInterface $response,\n  callable $next) ). This middleware would be invoked when calling  $next() \n  with a third argument indicating an error, and would be expected to handle it\n  or delegate to the next error middleware.   Internally, Stratigility would execute each middleware within a try/catch\n  block; if an exception were caught, it would then delegate to the next  error\n  middleware  using the caught exception as the  $err  argument.   The \"Final Handler\". This is a handler invoked when the middleware pipeline is\n  exhausted without returning a response, and has the signature  function\n  (ServerRequestInterface $request, ResponseInterface $response, $err = null) ;\n  it is provided to the middleware pipeline when invoking the outermost\n  middleware; in the case of Expressive, it is composed in the  Application \n  instance, and passed to the application middleware when it executes  run() .\n  When invoked, it needs to decide if invocation is due to no middleware\n  executing (HTTP 404 status), middleware calling  $next()  with an altered\n  response (response is then returned), or due to invocation of error middleware\n  (calling  $next()  with the third, error, argument) with no error middleware\n  returning a response.   Expressive 1.1 updates the minimum supported Stratigility version to 1.3, which\ndeprecates the concept of error middleware, and recommends a \"final handler\"\nthat does no error handling, but instead returns a canned response (typically a\n404). Additionally, it deprecates the practice of wrapping middleware execution\nin a try/catch block, and provides a flag for disabling that behavior entirely, raise_throwables .  Starting in Expressive 1.1, you can set the  raise_throwables  flag in your\nconfiguration:  return [\n    'zend-expressive' => [\n        'raise_throwables' => true,\n    ],\n];  When enabled, the internal dispatcher will no longer catch exceptions.  This both allows you to, and  requires  you to, write your own error handling\nmiddleware. This will require two things:   Middleware with a try/catch block that operates as the outermost (or close to\n  outermost) layer of your application, and which can provide error pages or\n  details to your end users.  Middleware at the innermost layer that is guaranteed to return a response;\n  generally, reaching this means no middleware was able to route the request, and\n  thus a 404 condition.   The below sections detail approaches to each.",
            "title": "Error handling"
        },
        {
            "location": "/reference/migration/to-v1-1/#error-handling-middleware",
            "text": "Error handling middleware generally will look something like this:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    try {\n        $response = $next($request, $response);\n        return $response;\n    } catch (\\Throwable $exception) {\n        // caught PHP 7 throwable\n    } catch (\\Exception $exception) {\n        // caught PHP 5 exception\n    }\n\n    // ...\n    // do something with $exception and generate a response\n    // ...\n\n    return $response;\n}  Stratigility 1.3 provides such an implementation via its Zend\\Stratigility\\Middleware\\ErrorHandler . In addition to the try/catch block,\nit also sets up a PHP error handler that will catch any PHP error types in the\ncurrent  error_reporting  mask; the error handler will raise exceptions of the\ntype  ErrorException  with the PHP error details.  Stratigility's  ErrorHandler  allows injection of an \"error response generator\",\nwhich allows you to alter how the error response is generated based on the\ncurrent environment. Error response generators are callables with the signature:  function (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  We recommend using the Stratigility  ErrorHandler  and writing and attaching a\ncustom error response generator. As a simple example, the following details a\ngenerator that will use a template to display an error page:  namespace Acme;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedErrorResponseGenerator\n{\n    const TEMPLATE_DEFAULT = 'error::error';\n\n    private $renderer;\n\n    private $template;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $template = TEMPLATE_DEFAULT\n    ) {\n        $this->renderer = $renderer;\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        $e,\n        ServerRequestInterface $request,\n        ResponseInterface $response\n    ) {\n        $response->write($this->renderer->render($this->template, [\n            'exception' => $e,\n            'request'   => $request,\n        ]));\n        return $response;\n    }\n}  You might then create a factory for generating the  ErrorHandler  and attaching\nthis response generator as follows:  namespace Acme\\Container;\n\nuse Acme\\TemplatedErrorResponseGenerator;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass ErrorHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $generator = new TemplatedErrorResponseGenerator(\n            $container->get(TemplateRendererInterface::class)\n        );\n\n        return new ErrorHandler(new Response(), $generator);\n    }\n}  Once that is created you can tell your middleware configuration about it:  // in config/autoload/middleware-pipeline.global.php\nuse Acme\\Container\\ErrorHandlerFactory;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            ErrorHandler::class => ErrorHandlerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                ErrorHandler::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];  Alternately, if using a programmatic pipeline, as detailed in the previous\nsection, you can use the following:  use Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(ErrorHandler::class);\n// add all other middleware after it",
            "title": "Error handling middleware"
        },
        {
            "location": "/reference/migration/to-v1-1/#not-found-middleware",
            "text": "At the innermost layer of your application, you need middleware guaranteed to\nreturn a response; typically, this indicates a failure to route the request,\nand, as such, an HTTP 404 response.   Zend\\Stratigility\\Middleware\\NotFoundHandler \nprovides an implementation, but is written such that the response body remains\nempty. As such, you might write a custom, templated handler:  namespace Acme;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedNotFoundHandler\n{\n    const TEMPLATE_DEFAULT = 'error::404';\n\n    private $renderer;\n\n    private $template;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $template = self::TEMPLATE_DEFAULT\n    ) {\n        $this->renderer = $renderer;\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        $response = new Response();\n        $response->write($this->renderer->render($this->template));\n        return $response->withStatus(404);\n    }\n}  Similar to the discussion of the  ErrorHandler  above, we'll create a factory\nfor this:  namespace Acme\\Container;\n\nuse Acme\\TemplatedNotFoundHandler;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedNotFoundHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new TemplatedNotFoundHandler(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}  We can then register it in our pipeline:  // in config/autoload/middleware-pipeline.global.php\nuse Acme\\Container\\NotFoundHandlerFactory;\nuse Acme\\TemplatedNotFoundHandler;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            TemplatedNotFoundHandler::class => TemplatedNotFoundHandlerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        /* ... */\n\n        // After 'routing', but before 'error';\n        // alternately as last item in 'routing' middleware list.\n        'not-found' => [\n            'middleware' => TemplatedNotFoundHandler::class,\n            'priority' => 0,\n        ],\n\n        /* ... */\n    ],\n];  If you are using programmatic pipelines, as described in the previous section:  use Acme\\TemplatedNotFoundHandler;\n\n// all other pipeline directives, and then:\n$app->pipe(TemplatedNotFoundHandler::class);",
            "title": "Not Found middleware"
        },
        {
            "location": "/reference/migration/to-v1-1/#detecting-error-middleware-usage",
            "text": "If you use the new error handling paradigm, we recommend that you also audit\nyour application for legacy Stratigility error middleware, as well as invocation\nof error middleware. To do this, we provide a tool via the zendframework/zend-expressive-tooling \npackage,  vendor/bin/expressive-scan-for-error-middleware .  First, install the tooling as a development requirement:  $ composer require --dev zendframework/zend-expressive-tooling  The tool will scan the  src/  directory by default, but allows you to scan other\ndirectories via the  --dir  flag. It will detect and report files with any of\nthe following:   Classes implementing  Zend\\Stratigility\\ErrorMiddlewareInterface .  Invokable classes implementing the error middleware signature.  Methods accepting  $next  that invoke it with an error argument.   As an example running it:  $ ./vendor/bin/expressive-scan-for-error-middleware scan\n# or, with a directory argument:\n$ ./vendor/bin/expressive-scan-for-error-middleware scan --dir ./lib  You may also call the tool using its  help  command, or either of the  --help \nor  -h  flags to get full usage information.  Use this tool to identify potential problem areas in your application, and\nupdate your code to use the new error handling facilities as outlined above.",
            "title": "Detecting error middleware usage"
        },
        {
            "location": "/reference/migration/to-v1-1/#full-example",
            "text": "Putting all of the above together \u2014  original message\nmemoizing ,  programmatic\npipelines , and  middleware-based error\nhandling  \u2014 might look like the following examples.  First, we'll tell Expressive to use programmatic pipelines, and to enable the\nnew error handling (by telling it to \"raise throwables\", instead of catching\nthem):  // In config/autoload/zend-expressive.global.php:\nreturn [\n    /* ... */\n    'zend-expressive' => [\n        'programmatic_pipeline' => true,\n        'raise_throwables' => true,\n        /* ... */\n    ],\n];  Next, we'll update  config/autoload/middleware-pipeline.global.php  to list only\ndependencies:  use Acme\\Container;\nuse Acme\\TemplatedNotFoundHandler;\nuse Zend\\Expressive\\Container\\ApplicationFactory;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            OriginalMessages::class => OriginalMesssages::class,\n        ],\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class,\n            Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class,\n            TemplatedNotFoundHandler::class => Container\\TemplatedNotFoundHandlerFactory::class,\n        ],\n    ],\n];  We'll also update  config/autoload/routes.global.php  to only list dependencies;\nin the following example, we list only the middleware shipped by default with\nthe skeleton application:  use App\\Action;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\nuse Zend\\Expressive\\Router\\RouterInterface;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            RouterInterface::class => FastRouteRouter::class,\n            Action\\PingAction::class => Action\\PingAction::class,\n        ],\n        'factories' => [\n            Action\\HomePageAction::class => Action\\HomePageFactory::class,\n        ],\n    ],\n];  To create our pipeline, we will create the file  config/pipeline.php :  use Acme\\TemplatedNotFoundHandler;\nuse Zend\\Expressive\\Container\\ApplicationFactory;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(ErrorHandler::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe([\n    ApplicationFactory::ROUTING_MIDDLEWARE,\n    Helper\\UrlHelperMiddleware::class,\n    ApplicationFactory::DISPATCH_MIDDLEWARE,\n]);\n$app->pipe(TemplatedNotFoundHandler::class);  Note that you can use  arrays  of middleware just like you did in the\nconfiguration; this allows you to separate middleware into logical groups if\ndesired!  To provide our routed middleware, we will create the file config/pipeline.php :  use App\\Action;\n\n$app->get('/', Action\\HomePageAction::class, 'home');\n$app->get('/api/ping', Action\\PingAction::class, 'api.ping');  The above exercises the various routing methods of the  Application  class.  Finally, we will need to update our  public/index.php , to tell it to require\nour new pipeline and routing files; we'll do that between retrieving the\napplication from the container, and running the application:  $app = $container->get(\\Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();  With these changes in place, your application should continue to run as it did\npreviously!",
            "title": "Full example"
        },
        {
            "location": "/reference/migration/to-v1-1/#looking-forward",
            "text": "Expressive 2.0 will ship error handling middleware and \"not found\" middleware,\nas well as tools to convert your application to a programmatic pipeline in such\na way as to utilize these shipped implementations. In the meantime, however, you\ncan adopt programmatic pipelines and the new error handling paradigm within the\nversion 1 series using the configuration flags and guidelines listed above in\norder to make your application forwards-compatible.",
            "title": "Looking forward"
        },
        {
            "location": "/reference/migration/to-v2/",
            "text": "Migration to Expressive 2.0\n\n\nExpressive 2.0 should not result in many upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:\n\n\n\n\nSignature changes\n\n\nRemoved functionality\n\n\nDeprecated functionality\n\n\nPSR-11 support\n\n\nUsage of http-interop middleware\n\n\nOriginal request and response messages\n\n\nError handling\n\n\nFinal handlers become default delegates\n\n\nProgrammatic middleware pipelines\n\n\nImplicit handling of \nHEAD\n and \nOPTIONS\n requests\n\n\nRouterInterface changes\n\n\nURL helper changes\n\n\nzend-view renderer changes\n\n\nTwig renderer changes\n\n\n\n\nSignature changes\n\n\nThe following signature changes were made that could affect \nclass extensions\n:\n\n\n\n\nZend\\Expressive\\Application::__call($method, array $args)\n: previously, the\n  \n$args\n argument was not typehinted; it now is. If you are extending this\n  class and overriding that method, you will need to update your method\n  signature accordingly.\n\n\n\n\nAdditionally, a number of signatures change due to updating Expressive to\nsupport \nPSR-11\n instead of\n\ncontainer-interop\n\n(which was the basis for PSR-11). Essentially, these were a matter of updating\ntypehints on \nInterop\\Container\\ContainerInterface\n to\n\nPsr\\Container\\ContainerInterface\n. Signatures affected include:\n\n\n\n\nZend\\Expressive\\AppFactory::create()\n\n\nZend\\Expressive\\Application::__construct()\n\n\nZend\\Expressive\\Container\\ApplicationFactory::__invoke()\n\n\nZend\\Expressive\\Container\\ErrorHandlerFactory::__invoke()\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory::__invoke()\n\n\nZend\\Expressive\\Container\\NotFoundDelegateFactory::__invoke()\n\n\nZend\\Expressive\\Container\\NotFoundHandlerFactory::__invoke()\n\n\nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::__invoke()\n\n\nZend\\Expressive\\Container\\WhoopsFactory::__invoke()\n\n\nZend\\Expressive\\Container\\WhoopsPageHandlerFactory::__invoke()\n\n\n\n\nIn each of the above cases, updating your import statements from\n\nInterop\\Container\\ContainerInterface\n to \nPsr\\Container\\ContainerInterface\n\nwill make your code work again.\n\n\nThe following exceptions now implement PSR-11 exception interfaces instead of container-interop variants:\n\n\n\n\nZend\\Expressive\\Container\\Exception\\InvalidServiceException\n\n\n\n\nIn the above case, if you were previously catching the container-interop\nexception on which it was based, your code should still work so long as you\nhave container-interop installed. You should likely update it to catch the more\ngeneral \nPsr\\Container\\ContainerExceptionInterface\n instead, however.\n\n\nRemoved functionality\n\n\nThe following classes and/or methods were removed for the Expressive 2.0\nrelease:\n\n\n\n\n\n\nZend\\Expressive\\Application::pipeErrorHandler()\n. Stratigility 2.0 dropped\n  its \nErrorMiddlewareInterface\n and the concept of error middleware (middleware\n  supporting an additional \n$error\n argument in its signature); this method was\n  thus no longer relevant.\n\n\n\n\n\n\nZend\\Expressive\\Application::routeMiddleware()\n. Routing middleware was\n  extracted to the class \nZend\\Expressive\\Middleware\\RouteMiddleware\n.\n\n\n\n\n\n\nZend\\Expressive\\Application::dispatchMiddleware()\n. Dispatch middleware was\n  extracted to the class \nZend\\Expressive\\Middleware\\DispatchMiddleware\n.\n\n\n\n\n\n\nZend\\Expressive\\Application::getFinalHandler()\n. Stratigility 2 supports the\n  http-interop/http-middleware project, and now uses \ndelegates\n. This method\n  was renamed to \ngetDefaultDelegate()\n, and now returns an\n  \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instance.\n\n\n\n\n\n\nZend\\Expressive\\Container\\Exception\\InvalidArgumentException\n. This exception\n  was thrown by \nZend\\Expressive\\Container\\ApplicationFactory\n previously; that\n  class now throws \nZend\\Expressive\\Exception\\InvalidArgumentException\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Container\\Exception\\NotFoundException\n. This exception type\n  was never used internally.\n\n\n\n\n\n\nZend\\Expressive\\ErrorMiddlewarePipe\n. With the removal of Stratigility 1\n  error middleware, this specialized \nMiddlewarePipe\n no longer has any use.\n\n\n\n\n\n\nZend\\Expressive\\Container\\TemplatedErrorHandlerFactory\n. See the section on\n  \nfinal handler changes\n for more\n  information.\n\n\n\n\n\n\nZend\\Expressive\\Container\\WhoopsErrorHandlerFactory\n. See the section on\n  \nfinal handler changes\n for more\n  information.\n\n\n\n\n\n\nZend\\Expressive\\TemplatedErrorHandler\n. See the section on\n  \nfinal handler changes\n for more\n  information.\n\n\n\n\n\n\nZend\\Expressive\\WhoopsErrorHandler\n. See the section on\n  \nfinal handler changes\n for more\n  information.\n\n\n\n\n\n\nDeprecated functionality\n\n\n\n\nZend\\Expressive\\Application::raiseThrowables()\n. Stratigility 2.0 makes the\n  method a no-op, as exceptions are no longer caught by the middleware\n  dispatcher. As such, the \nraise_throwables\n configuration argument now is no\n  longer used, either.\n\n\n\n\nPSR-11 support\n\n\nIn previous versions of Expressive, we consumed\n\ncontainer-interop\n,\nwhich provides \nInterop\\Container\\ContainerInterface\n, a shared interface for\ndependency injection containers. container-interop served as a working group for the \n\nPSR-11\n specification.\n\n\nIn the weeks prior to the Expressive 2.0 release, PSR-11 was formally accepted,\nand the package \npsr/container\n was released. As such, we have updated\nExpressive to consume the interfaces PSR-11 exposes.\n\n\nNo supported implementations currently directly implement PSR-11, however.\nFortunately, the container-interop 1.2.0 release acts as a\nforwards-compatibility measure by altering every interface it exposes to extend\nthose from PSR-11, making existing container-interop implementations \nde facto\n\nPSR-11 implementations!\n\n\nThe result is a (mostly) transparent upgrade for users of Expressive. As newer\nversions of container implementations are released supporting PSR-11 directly,\nyou will be able to upgrade immediately; we will also periodically update the\nskeleton to pick up these new versions when present. (The one caveat to\nupgrading is \nsignature changes\n within Expressive classes\nbased on the new psr/container interface names.)\n\n\nAs long as you have container-interop 1.2.0 installed, your existing factories\nthat typehint against its interface will continue to work. However, we\nrecommend updating them to instead typehint against PSR-11, which will allow\nyou to drop the container-interop requirement once your chosen container\nimplementation no longer requires it.\n\n\n\n\nDo not update blindly!\n\n\nIf you are implementing interfaces from other packages in your factory\nimplementations, be sure to check and see if those interfaces update to PSR-11\nbefore making changes.\n\n\nAs an example, zend-servicemanager v3 does not update\n\nZend\\ServiceManager\\Factory\\FactoryInterface\n and siblings to typehint\nagainst PSR-11, as doing so would break backwards compatibility.\n\n\n\n\nhttp-interop\n\n\nStratigility 2.0 provides the ability to work with \nhttp-interop middleware\n0.4.1\n.\n\n\nThis specification, which is being developed as the basis of\n\nPSR-15\n,\ndefines what is known as \nlambda\n or \nsingle-pass\n middleware, vs the\n\ndouble-pass\n middleware traditionally used by Stratigility and Expressive.\n\n\nDouble-pass refers to the fact that two arguments are passed to the delegation\nfunction \n$next\n: the request and response. Lambda or single-pass middleware\nonly pass a single argument, the request.\n\n\nStratigility 2.0 provides support for dispatching either style of middleware.\n\n\nSpecifically, your middleware can now implement:\n\n\n\n\nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n, which defines a single\n  method, \nprocess(Psr\\Http\\Message\\ServerRequestInterface $request,\n  Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate)\n.\n\n\nCallable middleware that follows the above signature (the typehint for the\n  request argument is optional).\n\n\n\n\nBoth styles of middleware may be piped directly to the middleware pipeline or as\nrouted middleware within Expressive. In each case, you can invoke the\nnext middleware layer using \n$delegate->process($request)\n.\n\n\nIn Expressive 2.0, \nApplication\n will continue to accept the legacy double-pass\nsignature, but will require that you either:\n\n\n\n\nProvide a \n$responsePrototype\n (a \nResponseInterface\n instance) to the\n  \nApplication\n instance prior to piping or routing such middleware.\n\n\nDecorate the middleware in a \nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n\n  instance (which also requires a \n$responsePrototype\n).\n\n\n\n\nIf you use \nZend\\Expressive\\Container\\ApplicationFactory\n to create your\n\nApplication\n instance, a response prototype will be injected for you from the\noutset.\n\n\nWe recommend that you begin writing middleware to follow the http-interop\nstandard at this time. As an example:\n\n\nnamespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass XClacksOverheadMiddleware implements MiddlewareInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n}\n\n\n\nAlternately, you can write this as a callable:\n\n\nnamespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass XClacksOverheadMiddleware\n{\n    /**\n     * @param ServerRequestInterface $request\n     * @param DelegateInterface $delegate\n     * @return ResponseInterface\n     */\n    public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n}\n\n\n\nOriginal messages\n\n\nIn the \nmigration to version 1.1 guide\n, we detail the fact that\nStratigility 1.3 deprecated its internal request and response decorators.\nStratigility 2.0, on which Expressive 2.0 is based, removes them entirely.\n\n\nIf your code relied on the various \ngetOriginal*()\n methods those decorators\nexposed, you will need to update your code in two ways:\n\n\n\n\nYou will need to add \nZend\\Stratigility\\Middleware\\OriginalMessages\n to your\n  middleware pipeline, as the outermost (or close to outermost) layer.\n\n\nYou will need to update your code to call on the request instance's\n  \ngetAttribute()\n method with one of \noriginalRequest\n, \noriginalUri\n, or\n  \noriginalResponse\n to retrieve the values.\n\n\n\n\nTo address the first point, see the \nExpressive 1.1 migration\ndocumentation\n, which details how to update your\nconfiguration or programmatic pipeline.\n\n\nFor the second point, we provide a tool via the\n\nzendframework/zend-expressive-tooling\n\npackage which will help you in this latter part of the migration. Install it as\na development requirement via composer:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nAnd then execute it via:\n\n\n$ ./vendor/bin/expressive-migrate-original-messages\n\n\n\nThis tool will update calls to \ngetOriginalRequest()\n and \ngetOriginalUri()\n to\ninstead use the new request attributes that the \nOriginalMessages\n middleware\ninjects:\n\n\n\n\ngetOriginalRequest()\n becomes \ngetAttribute('originalRequest', $request)\n\n\ngetOriginalUri()\n becomes \ngetAttribute('originalUri', $request->getUri())\n\n\n\n\nIn both cases, \n$request\n will be replaced with whatever variable name you used\nfor the request instance.\n\n\nFor \ngetOriginalResponse()\n calls, which happen on the response instance, the\ntool will instead tell you what files had such calls, and detail how you can\nupdate those calls to use the \noriginalResponse\n request attribute.\n\n\nError handling\n\n\nAs noted in the \nExpressive 1.1 migration docs\n,\nStratigility 1.3 introduced the ability to tell it to no longer catch exceptions\ninternally, paving the way for middleware-based error handling. Additionally, it\ndeprecated its own \nErrorMiddlewareInterface\n and duck-typed implementations of\nthe interface in favor of middleware-based error handling. Finally, it\ndeprecated the \n$e\n/\n$error\n argument to \"final handlers\", as that argument\nwould be used only when attempting to invoke \nErrorMiddlewareInterface\n\ninstances.\n\n\nStratigility 2.0, on which Expressive 2.0 is based, no longer catches exceptions\ninternally, removes the \nErrorMiddlewareInterface\n entirely, and thus the\n\n$e\n/\n$error\n argument to final handlers.\n\n\nAs such, you \nMUST\n provide your own error handling with Expressive 2.0.\n\n\nError handling middleware will typically introduce a try/catch block:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    try {\n        $response = $next($request, $response);\n        return $response;\n    } catch (\\Throwable $exception) {\n        // caught PHP 7 throwable\n    } catch (\\Exception $exception) {\n        // caught PHP 5 exception\n    }\n\n    // ... \n    // do something with $exception and generate a response\n    // ...\n\n    return $response;\n}\n\n\n\nAdditionally, you will need middleware registered as your innermost layer that\nis guaranteed to return a response. Generally, if you hit that layer, no other\nmiddleware is capable of handling the request, indicating a 400 (Bad Request) or\n404 (Not Found) HTTP status. With the combination of an error handler at the\noutermost layer, and a \"not found\" handler at the innermost layer, you can\nhandle any error in your application.\n\n\nStratigility 1.3 and 2.0 provide an error handler implementation via\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n. In addition to the try/catch block,\nit also sets up a PHP error handler that will catch any PHP error types in the\ncurrent \nerror_reporting\n mask; the error handler will raise exceptions of the\ntype \nErrorException\n with the PHP error details.\n\n\nErrorHandler\n allows injection of an \"error response generator\", which allows\nyou to alter how the error response is generated based on the current\nenvironment. Error response generators are callables with the signature:\n\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nExpressive 2.0 provides the following functionality to assist with your error\nhandling needs:\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n will output a canned\n  plain/text message, or use a supplied template renderer to generate content\n  for the response. It accepts the following arguments to its constructor:\n\n\n\n\n\n\n$isDevelopmentMode = false\n: whether or not the application is in\n  development mode. If so, it will output stack traces when no template\n  renderer is used (see below), or supply the exception to the template via\n  the \nerror\n variable if a renderer is present.\n\n\n\n\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface $renderer\n: if\n  supplied, the results of rendering a template will be injected into\n  the response. Templates are passed the following variables:\n\n\n\n\nresponse\n: the response at the time of rendering\n\n\nrequest\n: the request at the time of rendering\n\n\nuri\n: the URI at the time of rendering\n\n\nstatus\n: the response status code\n\n\nreason\n: the response reason phrase\n\n\nerror\n: the exception; this is only provided when in development mode.\n\n\n\n\n\n\n\n\n$template = 'error::error'\n: the template to render, with a default value\n  if none is provided.\n\n\n\n\n\n\n\n\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory\n can create an\n  instance of the \nErrorResponseGenerator\n using the following:\n\n\n\n\n\n\nThe \ndebug\n top-level configuration value is used to set the\n  \n$isDevelopmentMode\n flag.\n\n\n\n\n\n\nIf a \nZend\\Expressive\\Template\\TemplateRendererInterface\n service is\n  registered, it will be provided to the constructor.\n\n\n\n\n\n\nThe value of \nzend-expressive.error_handler.template_error\n, if present,\n  will be used to seed the \n$template\n argument.\n\n\n\n\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator\n uses Whoops to \n  generate the error response. Its constructor takes a single argument, a\n  \nWhoops\\Run\n instance. If a \nWhoops\\Handler\\PrettyPageHandler\n is registered\n  with the instance, it will add a data table with request details derived from\n  the \nServerRequestInterface\n instance.\n\n  \nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory\n can create an\n  instance, and will use the \nZend\\Expressive\\Whoops\n service to seed the\n  \nWhoops\\Run\n argument.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\NotFoundHandler\n can be used as the innermost\n  layer of your pipeline in order to return a 404 response. (Typically, if you\n  get to the innermost layer, no middleware was able to handle the request,\n  indicating a 404.) By default, it will produce a canned plaintext response.\n  However, you can also provide an optional \nTemplateRendererInterface\n instance\n  and \n$template\n in order to provided templated content.\n\n  The constructor arguments are:\n\n\n\n\n\n\nResponseInterface $responsePrototype\n: this is an empty response on which\n  to set the 404 status and inject the 404 content.\n\n\n\n\n\n\nTemplateRendererInterface $renderer\n: optionally, you may provide a\n  renderer to use in order to provide templated response content.\n\n\n\n\n\n\n$template = 'error::404'`: optionally, you may provide a\n  template to render; if none is provided, a sane default is used.\n\n\n\n\n\n\n\n\n\n\nZend\\Expressive\\Container\\NotFoundHandlerFactory\n can create an instance of\n  the \nNotFoundHandler\n for you, and will use the following to do so:\n\n\n\n\n\n\nThe \nZend\\Expressive\\Template\\TemplateRendererInterface\n service, if\n  available.\n\n\n\n\n\n\nThe \nzend-expressive.error_handler.template_404\n configuration value, if\n  available, will be used for the \n$template\n.\n\n\n\n\n\n\n\n\n\n\nZend\\Expressive\\Container\\ErrorHandlerFactory\n will create an instance of\n  \nZend\\Stratigility\\Middleware\\ErrorHandler\n, and use the\n  \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n service to seed\n  it.\n\n  As such, register one of the following as a factory for the\n  \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n service:\n\n\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory\n\n\nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory\n\n\n\n\n\n\n\n\nError handler configuration example\n\n\nIf you are using configuration-driven middleware, your middleware pipeline\nconfiguration may look like this in order to make use of the new error handling\nfacilities:\n\n\n// config/autoload/middleware-pipeline.global.php\n\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    // Add the following section to enable the new error handling:\n    'zend-expressive' => [\n        'raise_throwables' => true,\n    ],\n\n    'dependencies' => [\n        'invokables' => [\n            // See above section on \"Original messages\":\n            OriginalMessages::class => OriginalMessages::class,\n        ],\n        'factories' => [\n            Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class,\n            Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class,\n\n            // Add the following three entries:\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n            Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class,\n        ],\n    ],\n\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                OriginalMessages::class,\n                Helper\\ServerUrlMiddleware::class,\n                ErrorHandler::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n\n        'routing' => [\n            'middleware' => [\n                Application::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        'not-found' => [\n            'middleware' => Middleware\\NotFoundHandler::class,\n            'priority' => 0,\n        ],\n\n        // Remove the section \"error\"\"\n    ],\n];\n\n\n\nIf you are defining a programmatic pipeline (see more below on this), the\npipeline might look like:\n\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(Helper\\UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(Middleware\\NotFoundHandler::class);\n\n\n\nError handling and PHP errors\n\n\nAs noted above, \nZend\\Stratigility\\Middleware\\ErrorHandler\n also creates a PHP\nerror handler that casts PHP errors to \nErrorException\n instances. More\nspecifically, it uses the current \nerror_reporting\n value to determine \nwhich\n\nerrors it should cast this way.\n\n\nThis can be problematic when deprecation errors are triggered.  If they are cast\nto exceptions, code that would normally run will now result in error pages.\n\n\nWe recommend adding the following line to your \npublic/index.php\n towards the\ntop of the file:\n\n\nerror_reporting(error_reporting() & ~E_USER_DEPRECATED);\n\n\n\nThis will prevent the error handler from casting deprecation notices to\nexceptions, while keeping the rest of your error reporting mask intact.\n\n\nRemoving legacy error middleware\n\n\nStratigility version 1-style error middleware (middleware implementing\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n, or duck-typing its signature,\nwhich included an \n$error\n argument as the first argument to the middleware) is\nno longer supported with Stratigility version 2 and Expressive 2.0. You will\nneed to find any instances of them in your application, or cases where your\nmiddleware invokes error middleware via the third argument to \n$next()\n.\n\n\nWe provide a tool to assist you with that via the package \n\nzendframework/zend-expressive-tooling\n:\n\nvendor/bin/expressive-scan-for-error-middleware\n. Run the command from your\nproject root, optionally passing the \nhelp\n, \n--help\n, or \n-h\n commands for\nusage. The tool will detect each of these for you, flagging them for you to\nupdate or remove.\n\n\nFinal handlers become default delegates\n\n\nOne ramification of supporting \nhttp-interop middleware\n is that\nthe concept of \"final handlers\" changes. In Stratigility 1.X and Expressive 1.X,\na \"final handler\" was invoked when the middleware pipeline was exhausted;\nhowever, due to how Stratigility caught exceptions, this also meant that the\nfinal handler often acted as the application error handler, reporting errors to\nend users.\n\n\nWith the \nerror handling changes noted above\n, error handling\nis moved to dedicated middleware. However, there is still a need to have\nsomething that can execute once the middleware pipeline is exhausted. Such a\nsituation typically indicates no middleware was able to handle the request, or\nthat the request was somehow malformed.\n\n\nIn Expressive 2.0, we have removed final handlers, and replaced them with the\nconcept of \"default delegates\". \nDelegates\n are\n\nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instances, which are invoked\nby middleware when they wish to \ndelegate\n processing of the request to\nsomething else. Internally, Stratigility 2.0 and Expressive 2.0 use a delegate\nto iterate through the middleware pipeline. For Expressive 2.0, a \ndefault\ndelegate\n is a delegate executed when the application's internal middleware\npipeline is exhausted.\n\n\nThe ramifications for end users are as follows:\n\n\n\n\n\n\nThe \n$finalHandler\n argument to \nApplication\n's constructor, which previously\n  was a \ncallable\n, is now called \n$defaultDelegate\n, and needs to be a\n  \nDelegateInterface\n instance.\n\n\n\n\n\n\ngetFinalHandler()\n no longer exists; we have \nadded\n \ngetDefaultDelegate()\n.\n\n\n\n\n\n\nThe service \nZend\\Expressive\\FinalHandler\n is no longer used. A new service,\n  \nZend\\Expressive\\Delegate\\DefaultDelegate\n, is used by \nApplicationFactory\n,\n  and, if present, will be used to inject the \n$defaultDelegate\n argument of the\n  \nApplication\n constructor.\n\n\n\n\n\n\nWe have removed the following classes, which either provided final handlers,\n  or acted as factories for them:\n\n\n\n\nZend\\Expressive\\TemplatedErrorHandler\n\n\nZend\\Expressive\\WhoopsErrorHandler\n\n\nZend\\Expressive\\Container\\TemplatedErrorHandlerFactory\n\n\nZend\\Expressive\\Container\\WhoopsErrorHandlerFactory\n\n\n\n\n\n\n\n\nIf you use the \nvendor/bin/expressive-pipeline-from-config\n tool to migrate your\napplication to programmatic pipelines, as described below, the \nDefaultDelegate\n\nservice will be mapped to \nZend\\Expressive\\Container\\NotFoundDelegateFactory\n,\nwhich will provide an instance of \nZend\\Expressive\\Delegate\\NotFoundDelegate\n.\nThis new class will produce a 404 response, using a template if the\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n service is present, but\notherwise producing a plain text response.\n\n\nApplication's built using the 2.0 version of the skeleton application will have\nthese features enabled by default.\n\n\n\n\nNotFoundDelegate and NotFoundHandler\n\n\nZend\\Expressive\\Middleware\\NotFoundHandler\n, which is intended as innermost\nmiddleware for producing a 404 response, composes and proxies to a\n\nNotFoundDelegate\n instance to produce its response.\n\n\n\n\nProgrammatic middleware pipelines\n\n\nStarting with Expressive 1.1, we recommended \nprogrammatic creation of\npipelines and routing\n; the \nExpressive 1.1 migration\nguide\n provides more detail.\n\n\nWith Expressive 2.0, this is now the \ndefault\n option shipped in the skeleton.\n\n\nIf you are upgrading from version 1 and are not currently using programmatic\npipelines, we provide a migration tool that will convert your application to do\nso. The tool is available via the package\n\nzendframework/zend-expressive-tooling\n.\nYou may install this package in one of the following ways:\n\n\n\n\nVia the vendor binary \n./vendor/bin/expressive-tooling\n:\n\n\n\n\n$ ./vendor/bin/expressive-tooling        # install\n$ ./vendor/bin/expressive-tooling remove # uninstall\n\n\n\n\n\nUsing Composer:\n\n\n\n\n$ composer require --dev zendframework/zend-expressive-tooling # install\n$ composer remove --dev zendframework/zend-expressive-tooling  # uninstall\n\n\n\nOnce installed, you will use the \nvendor/bin/expressive-pipeline-from-config\n\ncommand.\n\n\nThis command does the following:\n\n\n\n\n\n\nReads your \nmiddleware_pipeline\n configuration, and generates a programmatic\n  pipeline for you, which is then stored in \nconfig/pipeline.php\n. The generated\n  pipeline contains the following additions:\n\n\n\n\n\n\nThe first middleware in the pipeline is \nZend\\Stratigility\\Middleware\\OriginalMessages\n,\n  which injects the incoming request, URI, and response as the request\n  attributes \noriginalRequest\n, \noriginalUri\n, and \noriginalResponse\n,\n  respectively. (This can aid URI generation in nested middleware later.)\n\n\n\n\n\n\nThe second middleware in the pipeline is \nZend\\Stratigility\\Middleware\\ErrorHandler\n.\n\n\n\n\n\n\nThe last middleware in the pipeline is \nZend\\Expressive\\Middleware\\NotFoundHandler\n.\n\n\n\n\n\n\n\n\n\n\nReads your \nroutes\n configuration, and generates a programmatic\n  routing table for you, which is then stored in \nconfig/routes.php\n.\n\n\n\n\n\n\nAdds a new configuration file, \nconfig/autoload/programmatic-pipeline.global.php\n, \n  which enables the \nprogrammatic_pipelines\n configuration flag. Additionally,\n  it adds dependency configuration for the new error handlers.\n\n\n\n\n\n\nInserts two lines before the \n$app->run()\n statement of your\n  \npublic/index.php\n, one each to require \nconfig/pipeline.php\n and\n  \nconfig/routes.php\n.\n\n\n\n\n\n\nYour \nmiddleware_pipeline\n and \nroutes\n configuration are not removed at this\ntime, to allow you to test and verify your application first; however, due to\nthe configuration in \nconfig/autoload/programmatic-pipeline.global.php\n, these\nare now ignored.\n\n\nIf you wish to use Whoops in your development environment, you may add the\nfollowing to a local configuration file (e.g., \nconfig/autoload/local.php\n):\n\n\nuse Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory;\nuse Zend\\Expressive\\Middleware\\ErrorResponseGenerator;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorResponseGenerator::class => WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];\n\n\n\nOther things you may want to do:\n\n\n\n\n\n\nThe \nErrorHandler\n entry could potentially be moved inwards a few layers. As\n  an example, the \nServerUrlMiddleware\n has no possibility of raising an\n  exception or error, and could be moved outwards; you could do similarly for\n  any middleware that only injects additional response headers.\n\n\n\n\n\n\nRemove any Stratigility-style error middleware (middleware expecting an error\n  as the first argument). If any specialized error handling should occur, add\n  additional middleware into the pipeline that can catch exceptions, and have\n  that middleware re-throw for exceptions it cannot handle. (Use the\n  \nvendor/bin/expressive-scan-for-error-middleware\n command from\n  zendframework/zend-expressive-tooling to assist in this.)\n\n\n\n\n\n\nConsider providing your own \nZend\\Stratigility\\NoopFinalHandler\n\n  implementation; this will now only be invoked if the queue is exhausted, and\n  could return a generic 404 page, raise an exception, etc.\n\n\n\n\n\n\nHandling HEAD and OPTIONS requests\n\n\nPrior to 2.0, it was possible to route middleware that could not handle \nHEAD\n\nand/or \nOPTIONS\n requests. Per \nRFC 7231, section 4.1\n,\n\"all general-purpose servers MUST support the methods GET and HEAD. All other\nmethods are OPTIONAL.\" Additionally, most servers and implementors agree that\n\nOPTIONS\n \nshould\n be supported for any given resource, so that consumers can\ndetermine what methods are allowed for the given resource.\n\n\nTo make this happen, the Expressive project implemented several features.\n\n\nFirst, zend-expressive-router 1.3.0 introduced several features in both\n\nZend\\Expressive\\Router\\Route\n and \nZend\\Expressive\\Router\\RouteResult\n to help\nconsumers implement support for \nHEAD\n and \nOPTIONS\n in an automated way. The\n\nRoute\n class now has two new methods, \nimplicitHead()\n and \nimplicitOptions()\n;\nthese each return a boolean \ntrue\n value if support for those methods is\n\nimplicit\n \u2014 i.e., not defined explicitly for the route. The \nRouteResult\n\nclass now introduces a new factory method, \nfromRoute()\n, that will create an\ninstance from a \nRoute\n instance; this then allows consumers of a \nRouteResult\n\nto query the \nRoute\n to see if a matched \nHEAD\n or \nOPTIONS\n request needs\nautomated handling. Each of the supported router implementations were updated to\nuse this method, as well as to return a successful routing result if \nHEAD\n\nand/or \nOPTIONS\n requests are submitted, but the route does not explicitly\nsupport the method.\n\n\nWithin Expressive itself, we now offer two new middleware to provide this\nautomation:\n\n\n\n\nZend\\Expressive\\Middleware\\ImplicitHeadMiddleware\n\n\nZend\\Expressive\\Middleware\\ImplicitOptionsMiddleware\n\n\n\n\nIf you want to support these methods automatically, each of these should be\nenabled between the routing and dispatch middleware. If you use the\n\nexpressive-pipeline-from-config\n tool as documented in the\n\nprogrammatic pipeline migration section\n,\nentries for each will be injected into your generated pipeline.\n\n\nPlease see the \nchapter on the implicit methods middleware\n\nfor more information on each.\n\n\nRouter interface changes\n\n\nExpressive 2.0 uses zendframework/zend-expressive-router 2.1+. Version 2.0 of\nthat package introduced a change to the \nZend\\Expressive\\Router\\RouterInterface::generateUri()\n\nmethod; it now accepts an additional, optional, third argument, \narray $options = []\n,\nwhich can be used to pass router-specific options when generating a URI. As an\nexample, the implementation that uses zendframework/zend-router might use these\noptions to pass a translator instance in order to translate a path segment to\nthe currently selected locale.\n\n\nFor consumers, his represents no backwards-incompatible change; consumers may\nopt-in to the new argument at will. For those implementing the interface,\nupgrading will require updating your router implementation's signature to match\nthe new interface:\n\n\npublic function generateUri(\n    string $name,\n    array $substitutions = [],\n    array $options = []\n) : string\n\n\n\nURL helper changes\n\n\nExpressive 2.0 uses zendframework/zend-expressive-helpers version 3.0+. This new\nversion updates the signature of the \nZend\\Expressive\\Helper\\UrlHelper\n from:\n\n\nfunction (\n    $routeName,\n    array $routeParams = []\n) : string\n\n\n\nto:\n\n\nfunction (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string\n\n\n\nFor consumers, this should represent a widening of features, and will not\nrequire any changes, unless you wish to opt-in to the new arguments. See the\n\nUrlHelper documentation\n for information\non each argument.\n\n\nFor any users who were \nextending\n the class, you will need to update your\nextension accordingly.\n\n\nzend-view renderer changes\n\n\nExpressive 2.0 will use zend-expressive-zendviewrenderer 1.3+ if that renderer\nis chosen. Starting with 1.3.0 of that renderer, you may now pass a boolean\n\nfalse\n value for the \nlayout\n variable when calling either \naddDefaultParam()\n\nor \nrender()\n on the renderer instance in order to disable the layout.\n\n\nTwig renderer changes\n\n\nExpressive 2.0 will use zend-expressive-twigrenderer 1.3+ if that renderer\nis chosen. Starting with 1.3.0 of that renderer, Twig 2.1+ is now supported.",
            "title": "To Expressive 2.0"
        },
        {
            "location": "/reference/migration/to-v2/#migration-to-expressive-20",
            "text": "Expressive 2.0 should not result in many upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:   Signature changes  Removed functionality  Deprecated functionality  PSR-11 support  Usage of http-interop middleware  Original request and response messages  Error handling  Final handlers become default delegates  Programmatic middleware pipelines  Implicit handling of  HEAD  and  OPTIONS  requests  RouterInterface changes  URL helper changes  zend-view renderer changes  Twig renderer changes",
            "title": "Migration to Expressive 2.0"
        },
        {
            "location": "/reference/migration/to-v2/#signature-changes",
            "text": "The following signature changes were made that could affect  class extensions :   Zend\\Expressive\\Application::__call($method, array $args) : previously, the\n   $args  argument was not typehinted; it now is. If you are extending this\n  class and overriding that method, you will need to update your method\n  signature accordingly.   Additionally, a number of signatures change due to updating Expressive to\nsupport  PSR-11  instead of container-interop \n(which was the basis for PSR-11). Essentially, these were a matter of updating\ntypehints on  Interop\\Container\\ContainerInterface  to Psr\\Container\\ContainerInterface . Signatures affected include:   Zend\\Expressive\\AppFactory::create()  Zend\\Expressive\\Application::__construct()  Zend\\Expressive\\Container\\ApplicationFactory::__invoke()  Zend\\Expressive\\Container\\ErrorHandlerFactory::__invoke()  Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::__invoke()  Zend\\Expressive\\Container\\NotFoundDelegateFactory::__invoke()  Zend\\Expressive\\Container\\NotFoundHandlerFactory::__invoke()  Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::__invoke()  Zend\\Expressive\\Container\\WhoopsFactory::__invoke()  Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::__invoke()   In each of the above cases, updating your import statements from Interop\\Container\\ContainerInterface  to  Psr\\Container\\ContainerInterface \nwill make your code work again.  The following exceptions now implement PSR-11 exception interfaces instead of container-interop variants:   Zend\\Expressive\\Container\\Exception\\InvalidServiceException   In the above case, if you were previously catching the container-interop\nexception on which it was based, your code should still work so long as you\nhave container-interop installed. You should likely update it to catch the more\ngeneral  Psr\\Container\\ContainerExceptionInterface  instead, however.",
            "title": "Signature changes"
        },
        {
            "location": "/reference/migration/to-v2/#removed-functionality",
            "text": "The following classes and/or methods were removed for the Expressive 2.0\nrelease:    Zend\\Expressive\\Application::pipeErrorHandler() . Stratigility 2.0 dropped\n  its  ErrorMiddlewareInterface  and the concept of error middleware (middleware\n  supporting an additional  $error  argument in its signature); this method was\n  thus no longer relevant.    Zend\\Expressive\\Application::routeMiddleware() . Routing middleware was\n  extracted to the class  Zend\\Expressive\\Middleware\\RouteMiddleware .    Zend\\Expressive\\Application::dispatchMiddleware() . Dispatch middleware was\n  extracted to the class  Zend\\Expressive\\Middleware\\DispatchMiddleware .    Zend\\Expressive\\Application::getFinalHandler() . Stratigility 2 supports the\n  http-interop/http-middleware project, and now uses  delegates . This method\n  was renamed to  getDefaultDelegate() , and now returns an\n   Interop\\Http\\ServerMiddleware\\DelegateInterface  instance.    Zend\\Expressive\\Container\\Exception\\InvalidArgumentException . This exception\n  was thrown by  Zend\\Expressive\\Container\\ApplicationFactory  previously; that\n  class now throws  Zend\\Expressive\\Exception\\InvalidArgumentException  instead.    Zend\\Expressive\\Container\\Exception\\NotFoundException . This exception type\n  was never used internally.    Zend\\Expressive\\ErrorMiddlewarePipe . With the removal of Stratigility 1\n  error middleware, this specialized  MiddlewarePipe  no longer has any use.    Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory . See the section on\n   final handler changes  for more\n  information.    Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory . See the section on\n   final handler changes  for more\n  information.    Zend\\Expressive\\TemplatedErrorHandler . See the section on\n   final handler changes  for more\n  information.    Zend\\Expressive\\WhoopsErrorHandler . See the section on\n   final handler changes  for more\n  information.",
            "title": "Removed functionality"
        },
        {
            "location": "/reference/migration/to-v2/#deprecated-functionality",
            "text": "Zend\\Expressive\\Application::raiseThrowables() . Stratigility 2.0 makes the\n  method a no-op, as exceptions are no longer caught by the middleware\n  dispatcher. As such, the  raise_throwables  configuration argument now is no\n  longer used, either.",
            "title": "Deprecated functionality"
        },
        {
            "location": "/reference/migration/to-v2/#psr-11-support",
            "text": "In previous versions of Expressive, we consumed container-interop ,\nwhich provides  Interop\\Container\\ContainerInterface , a shared interface for\ndependency injection containers. container-interop served as a working group for the  PSR-11  specification.  In the weeks prior to the Expressive 2.0 release, PSR-11 was formally accepted,\nand the package  psr/container  was released. As such, we have updated\nExpressive to consume the interfaces PSR-11 exposes.  No supported implementations currently directly implement PSR-11, however.\nFortunately, the container-interop 1.2.0 release acts as a\nforwards-compatibility measure by altering every interface it exposes to extend\nthose from PSR-11, making existing container-interop implementations  de facto \nPSR-11 implementations!  The result is a (mostly) transparent upgrade for users of Expressive. As newer\nversions of container implementations are released supporting PSR-11 directly,\nyou will be able to upgrade immediately; we will also periodically update the\nskeleton to pick up these new versions when present. (The one caveat to\nupgrading is  signature changes  within Expressive classes\nbased on the new psr/container interface names.)  As long as you have container-interop 1.2.0 installed, your existing factories\nthat typehint against its interface will continue to work. However, we\nrecommend updating them to instead typehint against PSR-11, which will allow\nyou to drop the container-interop requirement once your chosen container\nimplementation no longer requires it.",
            "title": "PSR-11 support"
        },
        {
            "location": "/reference/migration/to-v2/#do-not-update-blindly",
            "text": "If you are implementing interfaces from other packages in your factory\nimplementations, be sure to check and see if those interfaces update to PSR-11\nbefore making changes.  As an example, zend-servicemanager v3 does not update Zend\\ServiceManager\\Factory\\FactoryInterface  and siblings to typehint\nagainst PSR-11, as doing so would break backwards compatibility.",
            "title": "Do not update blindly!"
        },
        {
            "location": "/reference/migration/to-v2/#http-interop",
            "text": "Stratigility 2.0 provides the ability to work with  http-interop middleware\n0.4.1 .  This specification, which is being developed as the basis of PSR-15 ,\ndefines what is known as  lambda  or  single-pass  middleware, vs the double-pass  middleware traditionally used by Stratigility and Expressive.  Double-pass refers to the fact that two arguments are passed to the delegation\nfunction  $next : the request and response. Lambda or single-pass middleware\nonly pass a single argument, the request.  Stratigility 2.0 provides support for dispatching either style of middleware.  Specifically, your middleware can now implement:   Interop\\Http\\ServerMiddleware\\MiddlewareInterface , which defines a single\n  method,  process(Psr\\Http\\Message\\ServerRequestInterface $request,\n  Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) .  Callable middleware that follows the above signature (the typehint for the\n  request argument is optional).   Both styles of middleware may be piped directly to the middleware pipeline or as\nrouted middleware within Expressive. In each case, you can invoke the\nnext middleware layer using  $delegate->process($request) .  In Expressive 2.0,  Application  will continue to accept the legacy double-pass\nsignature, but will require that you either:   Provide a  $responsePrototype  (a  ResponseInterface  instance) to the\n   Application  instance prior to piping or routing such middleware.  Decorate the middleware in a  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper \n  instance (which also requires a  $responsePrototype ).   If you use  Zend\\Expressive\\Container\\ApplicationFactory  to create your Application  instance, a response prototype will be injected for you from the\noutset.  We recommend that you begin writing middleware to follow the http-interop\nstandard at this time. As an example:  namespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass XClacksOverheadMiddleware implements MiddlewareInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n}  Alternately, you can write this as a callable:  namespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass XClacksOverheadMiddleware\n{\n    /**\n     * @param ServerRequestInterface $request\n     * @param DelegateInterface $delegate\n     * @return ResponseInterface\n     */\n    public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n}",
            "title": "http-interop"
        },
        {
            "location": "/reference/migration/to-v2/#original-messages",
            "text": "In the  migration to version 1.1 guide , we detail the fact that\nStratigility 1.3 deprecated its internal request and response decorators.\nStratigility 2.0, on which Expressive 2.0 is based, removes them entirely.  If your code relied on the various  getOriginal*()  methods those decorators\nexposed, you will need to update your code in two ways:   You will need to add  Zend\\Stratigility\\Middleware\\OriginalMessages  to your\n  middleware pipeline, as the outermost (or close to outermost) layer.  You will need to update your code to call on the request instance's\n   getAttribute()  method with one of  originalRequest ,  originalUri , or\n   originalResponse  to retrieve the values.   To address the first point, see the  Expressive 1.1 migration\ndocumentation , which details how to update your\nconfiguration or programmatic pipeline.  For the second point, we provide a tool via the zendframework/zend-expressive-tooling \npackage which will help you in this latter part of the migration. Install it as\na development requirement via composer:  $ composer require --dev zendframework/zend-expressive-tooling  And then execute it via:  $ ./vendor/bin/expressive-migrate-original-messages  This tool will update calls to  getOriginalRequest()  and  getOriginalUri()  to\ninstead use the new request attributes that the  OriginalMessages  middleware\ninjects:   getOriginalRequest()  becomes  getAttribute('originalRequest', $request)  getOriginalUri()  becomes  getAttribute('originalUri', $request->getUri())   In both cases,  $request  will be replaced with whatever variable name you used\nfor the request instance.  For  getOriginalResponse()  calls, which happen on the response instance, the\ntool will instead tell you what files had such calls, and detail how you can\nupdate those calls to use the  originalResponse  request attribute.",
            "title": "Original messages"
        },
        {
            "location": "/reference/migration/to-v2/#error-handling",
            "text": "As noted in the  Expressive 1.1 migration docs ,\nStratigility 1.3 introduced the ability to tell it to no longer catch exceptions\ninternally, paving the way for middleware-based error handling. Additionally, it\ndeprecated its own  ErrorMiddlewareInterface  and duck-typed implementations of\nthe interface in favor of middleware-based error handling. Finally, it\ndeprecated the  $e / $error  argument to \"final handlers\", as that argument\nwould be used only when attempting to invoke  ErrorMiddlewareInterface \ninstances.  Stratigility 2.0, on which Expressive 2.0 is based, no longer catches exceptions\ninternally, removes the  ErrorMiddlewareInterface  entirely, and thus the $e / $error  argument to final handlers.  As such, you  MUST  provide your own error handling with Expressive 2.0.  Error handling middleware will typically introduce a try/catch block:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    try {\n        $response = $next($request, $response);\n        return $response;\n    } catch (\\Throwable $exception) {\n        // caught PHP 7 throwable\n    } catch (\\Exception $exception) {\n        // caught PHP 5 exception\n    }\n\n    // ... \n    // do something with $exception and generate a response\n    // ...\n\n    return $response;\n}  Additionally, you will need middleware registered as your innermost layer that\nis guaranteed to return a response. Generally, if you hit that layer, no other\nmiddleware is capable of handling the request, indicating a 400 (Bad Request) or\n404 (Not Found) HTTP status. With the combination of an error handler at the\noutermost layer, and a \"not found\" handler at the innermost layer, you can\nhandle any error in your application.  Stratigility 1.3 and 2.0 provide an error handler implementation via Zend\\Stratigility\\Middleware\\ErrorHandler . In addition to the try/catch block,\nit also sets up a PHP error handler that will catch any PHP error types in the\ncurrent  error_reporting  mask; the error handler will raise exceptions of the\ntype  ErrorException  with the PHP error details.  ErrorHandler  allows injection of an \"error response generator\", which allows\nyou to alter how the error response is generated based on the current\nenvironment. Error response generators are callables with the signature:  function (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  Expressive 2.0 provides the following functionality to assist with your error\nhandling needs:    Zend\\Expressive\\Middleware\\ErrorResponseGenerator  will output a canned\n  plain/text message, or use a supplied template renderer to generate content\n  for the response. It accepts the following arguments to its constructor:    $isDevelopmentMode = false : whether or not the application is in\n  development mode. If so, it will output stack traces when no template\n  renderer is used (see below), or supply the exception to the template via\n  the  error  variable if a renderer is present.    Zend\\Expressive\\Template\\TemplateRendererInterface $renderer : if\n  supplied, the results of rendering a template will be injected into\n  the response. Templates are passed the following variables:   response : the response at the time of rendering  request : the request at the time of rendering  uri : the URI at the time of rendering  status : the response status code  reason : the response reason phrase  error : the exception; this is only provided when in development mode.     $template = 'error::error' : the template to render, with a default value\n  if none is provided.      Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory  can create an\n  instance of the  ErrorResponseGenerator  using the following:    The  debug  top-level configuration value is used to set the\n   $isDevelopmentMode  flag.    If a  Zend\\Expressive\\Template\\TemplateRendererInterface  service is\n  registered, it will be provided to the constructor.    The value of  zend-expressive.error_handler.template_error , if present,\n  will be used to seed the  $template  argument.      Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator  uses Whoops to \n  generate the error response. Its constructor takes a single argument, a\n   Whoops\\Run  instance. If a  Whoops\\Handler\\PrettyPageHandler  is registered\n  with the instance, it will add a data table with request details derived from\n  the  ServerRequestInterface  instance. \n   Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory  can create an\n  instance, and will use the  Zend\\Expressive\\Whoops  service to seed the\n   Whoops\\Run  argument.    Zend\\Expressive\\Middleware\\NotFoundHandler  can be used as the innermost\n  layer of your pipeline in order to return a 404 response. (Typically, if you\n  get to the innermost layer, no middleware was able to handle the request,\n  indicating a 404.) By default, it will produce a canned plaintext response.\n  However, you can also provide an optional  TemplateRendererInterface  instance\n  and  $template  in order to provided templated content. \n  The constructor arguments are:    ResponseInterface $responsePrototype : this is an empty response on which\n  to set the 404 status and inject the 404 content.    TemplateRendererInterface $renderer : optionally, you may provide a\n  renderer to use in order to provide templated response content.    $template = 'error::404'`: optionally, you may provide a\n  template to render; if none is provided, a sane default is used.      Zend\\Expressive\\Container\\NotFoundHandlerFactory  can create an instance of\n  the  NotFoundHandler  for you, and will use the following to do so:    The  Zend\\Expressive\\Template\\TemplateRendererInterface  service, if\n  available.    The  zend-expressive.error_handler.template_404  configuration value, if\n  available, will be used for the  $template .      Zend\\Expressive\\Container\\ErrorHandlerFactory  will create an instance of\n   Zend\\Stratigility\\Middleware\\ErrorHandler , and use the\n   Zend\\Stratigility\\Middleware\\ErrorResponseGenerator  service to seed\n  it. \n  As such, register one of the following as a factory for the\n   Zend\\Stratigility\\Middleware\\ErrorResponseGenerator  service:   Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory  Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory",
            "title": "Error handling"
        },
        {
            "location": "/reference/migration/to-v2/#error-handler-configuration-example",
            "text": "If you are using configuration-driven middleware, your middleware pipeline\nconfiguration may look like this in order to make use of the new error handling\nfacilities:  // config/autoload/middleware-pipeline.global.php\n\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    // Add the following section to enable the new error handling:\n    'zend-expressive' => [\n        'raise_throwables' => true,\n    ],\n\n    'dependencies' => [\n        'invokables' => [\n            // See above section on \"Original messages\":\n            OriginalMessages::class => OriginalMessages::class,\n        ],\n        'factories' => [\n            Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class,\n            Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class,\n\n            // Add the following three entries:\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n            Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class,\n        ],\n    ],\n\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                OriginalMessages::class,\n                Helper\\ServerUrlMiddleware::class,\n                ErrorHandler::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n\n        'routing' => [\n            'middleware' => [\n                Application::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        'not-found' => [\n            'middleware' => Middleware\\NotFoundHandler::class,\n            'priority' => 0,\n        ],\n\n        // Remove the section \"error\"\"\n    ],\n];  If you are defining a programmatic pipeline (see more below on this), the\npipeline might look like:  $app->pipe(OriginalMessages::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(Helper\\UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(Middleware\\NotFoundHandler::class);",
            "title": "Error handler configuration example"
        },
        {
            "location": "/reference/migration/to-v2/#error-handling-and-php-errors",
            "text": "As noted above,  Zend\\Stratigility\\Middleware\\ErrorHandler  also creates a PHP\nerror handler that casts PHP errors to  ErrorException  instances. More\nspecifically, it uses the current  error_reporting  value to determine  which \nerrors it should cast this way.  This can be problematic when deprecation errors are triggered.  If they are cast\nto exceptions, code that would normally run will now result in error pages.  We recommend adding the following line to your  public/index.php  towards the\ntop of the file:  error_reporting(error_reporting() & ~E_USER_DEPRECATED);  This will prevent the error handler from casting deprecation notices to\nexceptions, while keeping the rest of your error reporting mask intact.",
            "title": "Error handling and PHP errors"
        },
        {
            "location": "/reference/migration/to-v2/#removing-legacy-error-middleware",
            "text": "Stratigility version 1-style error middleware (middleware implementing Zend\\Stratigility\\ErrorMiddlewareInterface , or duck-typing its signature,\nwhich included an  $error  argument as the first argument to the middleware) is\nno longer supported with Stratigility version 2 and Expressive 2.0. You will\nneed to find any instances of them in your application, or cases where your\nmiddleware invokes error middleware via the third argument to  $next() .  We provide a tool to assist you with that via the package  zendframework/zend-expressive-tooling : vendor/bin/expressive-scan-for-error-middleware . Run the command from your\nproject root, optionally passing the  help ,  --help , or  -h  commands for\nusage. The tool will detect each of these for you, flagging them for you to\nupdate or remove.",
            "title": "Removing legacy error middleware"
        },
        {
            "location": "/reference/migration/to-v2/#final-handlers-become-default-delegates",
            "text": "One ramification of supporting  http-interop middleware  is that\nthe concept of \"final handlers\" changes. In Stratigility 1.X and Expressive 1.X,\na \"final handler\" was invoked when the middleware pipeline was exhausted;\nhowever, due to how Stratigility caught exceptions, this also meant that the\nfinal handler often acted as the application error handler, reporting errors to\nend users.  With the  error handling changes noted above , error handling\nis moved to dedicated middleware. However, there is still a need to have\nsomething that can execute once the middleware pipeline is exhausted. Such a\nsituation typically indicates no middleware was able to handle the request, or\nthat the request was somehow malformed.  In Expressive 2.0, we have removed final handlers, and replaced them with the\nconcept of \"default delegates\".  Delegates  are Interop\\Http\\ServerMiddleware\\DelegateInterface  instances, which are invoked\nby middleware when they wish to  delegate  processing of the request to\nsomething else. Internally, Stratigility 2.0 and Expressive 2.0 use a delegate\nto iterate through the middleware pipeline. For Expressive 2.0, a  default\ndelegate  is a delegate executed when the application's internal middleware\npipeline is exhausted.  The ramifications for end users are as follows:    The  $finalHandler  argument to  Application 's constructor, which previously\n  was a  callable , is now called  $defaultDelegate , and needs to be a\n   DelegateInterface  instance.    getFinalHandler()  no longer exists; we have  added   getDefaultDelegate() .    The service  Zend\\Expressive\\FinalHandler  is no longer used. A new service,\n   Zend\\Expressive\\Delegate\\DefaultDelegate , is used by  ApplicationFactory ,\n  and, if present, will be used to inject the  $defaultDelegate  argument of the\n   Application  constructor.    We have removed the following classes, which either provided final handlers,\n  or acted as factories for them:   Zend\\Expressive\\TemplatedErrorHandler  Zend\\Expressive\\WhoopsErrorHandler  Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory  Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory     If you use the  vendor/bin/expressive-pipeline-from-config  tool to migrate your\napplication to programmatic pipelines, as described below, the  DefaultDelegate \nservice will be mapped to  Zend\\Expressive\\Container\\NotFoundDelegateFactory ,\nwhich will provide an instance of  Zend\\Expressive\\Delegate\\NotFoundDelegate .\nThis new class will produce a 404 response, using a template if the Zend\\Expressive\\Template\\TemplateRendererInterface  service is present, but\notherwise producing a plain text response.  Application's built using the 2.0 version of the skeleton application will have\nthese features enabled by default.",
            "title": "Final handlers become default delegates"
        },
        {
            "location": "/reference/migration/to-v2/#notfounddelegate-and-notfoundhandler",
            "text": "Zend\\Expressive\\Middleware\\NotFoundHandler , which is intended as innermost\nmiddleware for producing a 404 response, composes and proxies to a NotFoundDelegate  instance to produce its response.",
            "title": "NotFoundDelegate and NotFoundHandler"
        },
        {
            "location": "/reference/migration/to-v2/#programmatic-middleware-pipelines",
            "text": "Starting with Expressive 1.1, we recommended  programmatic creation of\npipelines and routing ; the  Expressive 1.1 migration\nguide  provides more detail.  With Expressive 2.0, this is now the  default  option shipped in the skeleton.  If you are upgrading from version 1 and are not currently using programmatic\npipelines, we provide a migration tool that will convert your application to do\nso. The tool is available via the package zendframework/zend-expressive-tooling .\nYou may install this package in one of the following ways:   Via the vendor binary  ./vendor/bin/expressive-tooling :   $ ./vendor/bin/expressive-tooling        # install\n$ ./vendor/bin/expressive-tooling remove # uninstall   Using Composer:   $ composer require --dev zendframework/zend-expressive-tooling # install\n$ composer remove --dev zendframework/zend-expressive-tooling  # uninstall  Once installed, you will use the  vendor/bin/expressive-pipeline-from-config \ncommand.  This command does the following:    Reads your  middleware_pipeline  configuration, and generates a programmatic\n  pipeline for you, which is then stored in  config/pipeline.php . The generated\n  pipeline contains the following additions:    The first middleware in the pipeline is  Zend\\Stratigility\\Middleware\\OriginalMessages ,\n  which injects the incoming request, URI, and response as the request\n  attributes  originalRequest ,  originalUri , and  originalResponse ,\n  respectively. (This can aid URI generation in nested middleware later.)    The second middleware in the pipeline is  Zend\\Stratigility\\Middleware\\ErrorHandler .    The last middleware in the pipeline is  Zend\\Expressive\\Middleware\\NotFoundHandler .      Reads your  routes  configuration, and generates a programmatic\n  routing table for you, which is then stored in  config/routes.php .    Adds a new configuration file,  config/autoload/programmatic-pipeline.global.php , \n  which enables the  programmatic_pipelines  configuration flag. Additionally,\n  it adds dependency configuration for the new error handlers.    Inserts two lines before the  $app->run()  statement of your\n   public/index.php , one each to require  config/pipeline.php  and\n   config/routes.php .    Your  middleware_pipeline  and  routes  configuration are not removed at this\ntime, to allow you to test and verify your application first; however, due to\nthe configuration in  config/autoload/programmatic-pipeline.global.php , these\nare now ignored.  If you wish to use Whoops in your development environment, you may add the\nfollowing to a local configuration file (e.g.,  config/autoload/local.php ):  use Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory;\nuse Zend\\Expressive\\Middleware\\ErrorResponseGenerator;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorResponseGenerator::class => WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];  Other things you may want to do:    The  ErrorHandler  entry could potentially be moved inwards a few layers. As\n  an example, the  ServerUrlMiddleware  has no possibility of raising an\n  exception or error, and could be moved outwards; you could do similarly for\n  any middleware that only injects additional response headers.    Remove any Stratigility-style error middleware (middleware expecting an error\n  as the first argument). If any specialized error handling should occur, add\n  additional middleware into the pipeline that can catch exceptions, and have\n  that middleware re-throw for exceptions it cannot handle. (Use the\n   vendor/bin/expressive-scan-for-error-middleware  command from\n  zendframework/zend-expressive-tooling to assist in this.)    Consider providing your own  Zend\\Stratigility\\NoopFinalHandler \n  implementation; this will now only be invoked if the queue is exhausted, and\n  could return a generic 404 page, raise an exception, etc.",
            "title": "Programmatic middleware pipelines"
        },
        {
            "location": "/reference/migration/to-v2/#handling-head-and-options-requests",
            "text": "Prior to 2.0, it was possible to route middleware that could not handle  HEAD \nand/or  OPTIONS  requests. Per  RFC 7231, section 4.1 ,\n\"all general-purpose servers MUST support the methods GET and HEAD. All other\nmethods are OPTIONAL.\" Additionally, most servers and implementors agree that OPTIONS   should  be supported for any given resource, so that consumers can\ndetermine what methods are allowed for the given resource.  To make this happen, the Expressive project implemented several features.  First, zend-expressive-router 1.3.0 introduced several features in both Zend\\Expressive\\Router\\Route  and  Zend\\Expressive\\Router\\RouteResult  to help\nconsumers implement support for  HEAD  and  OPTIONS  in an automated way. The Route  class now has two new methods,  implicitHead()  and  implicitOptions() ;\nthese each return a boolean  true  value if support for those methods is implicit  \u2014 i.e., not defined explicitly for the route. The  RouteResult \nclass now introduces a new factory method,  fromRoute() , that will create an\ninstance from a  Route  instance; this then allows consumers of a  RouteResult \nto query the  Route  to see if a matched  HEAD  or  OPTIONS  request needs\nautomated handling. Each of the supported router implementations were updated to\nuse this method, as well as to return a successful routing result if  HEAD \nand/or  OPTIONS  requests are submitted, but the route does not explicitly\nsupport the method.  Within Expressive itself, we now offer two new middleware to provide this\nautomation:   Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware  Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware   If you want to support these methods automatically, each of these should be\nenabled between the routing and dispatch middleware. If you use the expressive-pipeline-from-config  tool as documented in the programmatic pipeline migration section ,\nentries for each will be injected into your generated pipeline.  Please see the  chapter on the implicit methods middleware \nfor more information on each.",
            "title": "Handling HEAD and OPTIONS requests"
        },
        {
            "location": "/reference/migration/to-v2/#router-interface-changes",
            "text": "Expressive 2.0 uses zendframework/zend-expressive-router 2.1+. Version 2.0 of\nthat package introduced a change to the  Zend\\Expressive\\Router\\RouterInterface::generateUri() \nmethod; it now accepts an additional, optional, third argument,  array $options = [] ,\nwhich can be used to pass router-specific options when generating a URI. As an\nexample, the implementation that uses zendframework/zend-router might use these\noptions to pass a translator instance in order to translate a path segment to\nthe currently selected locale.  For consumers, his represents no backwards-incompatible change; consumers may\nopt-in to the new argument at will. For those implementing the interface,\nupgrading will require updating your router implementation's signature to match\nthe new interface:  public function generateUri(\n    string $name,\n    array $substitutions = [],\n    array $options = []\n) : string",
            "title": "Router interface changes"
        },
        {
            "location": "/reference/migration/to-v2/#url-helper-changes",
            "text": "Expressive 2.0 uses zendframework/zend-expressive-helpers version 3.0+. This new\nversion updates the signature of the  Zend\\Expressive\\Helper\\UrlHelper  from:  function (\n    $routeName,\n    array $routeParams = []\n) : string  to:  function (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string  For consumers, this should represent a widening of features, and will not\nrequire any changes, unless you wish to opt-in to the new arguments. See the UrlHelper documentation  for information\non each argument.  For any users who were  extending  the class, you will need to update your\nextension accordingly.",
            "title": "URL helper changes"
        },
        {
            "location": "/reference/migration/to-v2/#zend-view-renderer-changes",
            "text": "Expressive 2.0 will use zend-expressive-zendviewrenderer 1.3+ if that renderer\nis chosen. Starting with 1.3.0 of that renderer, you may now pass a boolean false  value for the  layout  variable when calling either  addDefaultParam() \nor  render()  on the renderer instance in order to disable the layout.",
            "title": "zend-view renderer changes"
        },
        {
            "location": "/reference/migration/to-v2/#twig-renderer-changes",
            "text": "Expressive 2.0 will use zend-expressive-twigrenderer 1.3+ if that renderer\nis chosen. Starting with 1.3.0 of that renderer, Twig 2.1+ is now supported.",
            "title": "Twig renderer changes"
        }
    ]
}